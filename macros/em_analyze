#!/uns/bin/perl -w
#### PROFILE VERSION: #!/uns/bin/perl -wd:DProf
# $Id$
# evilmacros

# TERMS:
#   project file == a file passed in via -i, or on cmd line
#                   it is also called an NI (not-included) file
#   system file == a file that got parsed because another file
#                  #include-d it
#   ncnb == non-comment, non-blank; a line containing code
#   c_ == count of, an integer variable
#   rg_ = region, an array of indices for extracting slices from another array
#   _ni = non-include; for a file, means it was on command line (?)
#   mi = method of inclusion; why this file is being processed

# Used below to debug the ccd categorization
#while (<>) {
#  m/^.*: (\S+) in $/;
#  my $curr_ccdCategory = ccd_lexical_category($1);
#  print STDERR "CCD_LEXICAL_CATEGORY: $1 in ",
#  $cond_category_name[$curr_ccdCategory], "\n";
#}
#exit 0;



# FIX: I want to use '-$' like cpp does, not '-l'; how to do this?
my $getopts_option_letters = 'ihvtIAaue1pTlL:g:d:E:P:n:F:M';

# Remove the asterisks below when the options are known to the users.
sub usage ( ) {
  die "@_\nUsage: $0 [-$getopts_option_letters] <files>
New options marked with *; options with ':', above, take an argument
  -i  use files listed on stdin [one per line] in addition to any on cmd line
  -h  display this help message
  -v  be verbose and list files as they are processed to stderr
  -t  use [TAB] as the OFS for the statistics files (not space)
  -I  ignore include files--just parse files passed in
  -A  do the second pass on all files, not just those passed in
  -a  do macro statistics on all files, not just those passed in
  -u  suppress macro use analysis
  -e  suppress macro dependence analysis
  -1  do only the first pass (don't do function parsing, usage)
	This is a numeral 1, not a lowercase L.
* -L [num]  print info about all lines depending on more than num macros
* -l  forbid the use of `\$' in identifiers, per ANSI standard
	This is a lowercase L, not a numeral 1.
* -g [num]  set the num'th debugging option to true  {ought to be able to name}
	-g 0 turns off all debugging flags.
* -T  run tests instead of main code body
* -d [directory:package]  use state filenames \"package\" under the given directory
	If basename is not supplied, use extensions (sans .) as whole name.
  -E [file]  send evil macros to file instead of stdout
  -P [file]  send parse errors to file instead of stdout
  -p  send parse errors to stdout even if also sending to file
* -n [directory]  also prepend \"directory\" to elements of include path
	This permits use of customized library header files.
* -F [directory] Use the fast version of modules in [directory]
     (this just puts the directory ahead of the other dirs in @INC for Perl)
  -M Provide (lots of) additional memory debugging output to stderr

(Note: -{E,P} options take precedence over the -d option)

e.g.

find-c | $0 -iv -d ~/macros/data/stable:pkgname

 or

cat c-files-listing | $0 -i -d ~/macros/data/stable:pkgname
";
}

# To run on all packages:
#   link to (don't copy) Makefile; edit first three lines; make data_analyze
#
# # Puts a list of failed packages in "failures".
# TM=/tmp/$USER/macros/data/stable
# (assume c-files-listing has find-c output; otherwise, use "find-c")
# for i in *(/); do echo $i; pushd $i; NM=${i%%-*}; cat c-files-listing | em_analyze -i -d $TM:$NM > $TM/$NM.out 2> $TM/$NM.err || (cd ..; echo $i >> failures); popd; done
# 
# # or (older version)
# for i in *(/); do echo $i; pushd $i; cat c-files-listing | em_analyze -i -d $TM:${i%%-*} >$TM/${i%%-*}.out 2> $TM/${i%%-*}.err; popd; done
#
# For a second run for first-run failures:
# for i in *(/); do if [[ ! -s $TM/${i%%-*}.state ]]; then echo $i; pushd $i; cat c-files-listing | em_analyze -i -d $TM2:${i%%-*}1 >$TM2/${i%%-*}.out 2>$TM2/${i%%-*}.err ; popd; fi; done
#
#
# alias find-c='find . \( -name UNUSED -o -name CVS -o -name SCCS -o -name RCS \) -prune -o \( -name "*.[chCH]" -o -name "*.[cC][cC]" -o -name "*.[cC][pP][pP]" \) -print'
# (Note that c-files-listing can cache this output for each package -- then
#  it doesn't rebuild the list each time)
# It's best to operate on an entire project, so you know all the
# functions, macros, etc.

## Other interesting options: -A -T -g 6
# find-c | em_analyze -v -p -d ../../:evilout -i
# echo c-files-listing | em_analyze -v -p -d ../../:evilout -i

# Harbison & Steele p. 53:
#   ISO C reaffirms that macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.


###########################################################################
### To do
###

# fixgjb:
#    Change current_line_no() into two functions which return
#    the first and last physical lines associated with the current lines being
#    processed; in general, prefer the former to the latter, except when
#    the end of a function definition, etc.
#
# Small code stuff:
#  * when body = expression + semicolon, warn; but check that every use of
# 	the macro is followed by a semicolon, and if so, eliminate the one
# 	in the body (ie, converts to function not returning void).
#       Or check the context: is it void?
#  * Maybe look at whole functions at a time rather than being line-oriented,
#    or break on semicolons or braces instead of newlines.  But sometimes
#    when we're confused, restarting at the next newline is the right thing to do.

# All calls to get_fulltoken_line should check the result value before
# using it (might get to end of file).

# Uniformize uses of $type_declarator_re.
# Probably don't need the type special cases any more.

# Break some huge regexps into separate tests for smaller pieces, which is
# more efficient.

# Optionally specify values for certain macros (such as __STDC__: always
# take the true branch and omit a lot of hard declaration-munging
# nonsense).

# Collect statistics on number of lines dependent on each particular macro.

# Small projects:
#  * Recognize macros that build assembly code, and treat/report specially?
# 	(What % of interesting macros are such?  Very few, I think.)
#  * Look for macro definitions from makefiles (-D option to compiler)
# 	We can't know all the things that are macros, but can try.
#	[Greg will do this.]
#  * Try other (non-gcc) preprocessors on the problematic stuff, to see if they
# 	deal with it identically.
#  * Get more packages (eg GNAT), until nishin:/tmp is full.  Then stop.
#	In particular, get elk and saoimage.
# 	/tmp policy is basically that they'll try not to blow stuff away
#  * Add additional pass for function and global types before inferring macro
# 	invocation types.  Does a tool already exist to compute this for us?
#	Perhaps this isn't necessary if processing #includes in order??
# 
# Major projects:
#  * convert from macros into language constructs; see if code still works.
# 	Perhaps do this by hand for some small codebase.
# 	Need to worry about new files, #include, extern, etc.
#  * dependentmacros, showing which macros' values depend on the values of
# 	other macros.  Perhaps only the non-dependent ones need to be true
# 	macros, while the others can be turned into consts.
#	Also do this per line a la Krone & Snelting.
#  * do type inference for macro arguments, type lookup for globals and functions.
# 	This entails checking for free variables and more.
#  * find all non-dependent macros -- including those mentioned in #if lines.
#       (maybe do this automatically by reading lots of standard header files?
# 	Then note which header files have been read so we don't reread them.)
#  * check for side effects in macros (eg, function calls in an argumentless
# 	macro probably prevent it from being turned into a const, unless
# 	the call is to a known side-effect-less library function.  This requires
#	me to write side-effect specifications for library functions; don't
#	do so unless I determine this is valuable.  This is interesting only
#	in constant-like macros that make function calls; the compiler will
#	do it for function-like macros that get converted in to functions.
#  * Track assigned-to lvalues, but remember whether it's to a macro arg (in
# 	which case it must be passed by reference) or to a global (which is
# 	hunky-dory) or to a local (which is evil).  The latter is evil anyway,
#	so maybe assignment is never a problem?
#  * Check for/recognize template-like macros (that take a type as an argument).
#  * for lightweight (non-parsing) tool, determine the effect a macro would
# 	have on parser state, e.g. like a function call, a block, a
# 	statement, a constant, etc.
#  * Move conditional compilation into inline functions (to unclutter source).
#	For instance, change #if #def #else #def #endif into
#	inline { #if #else #endif }; is the latter really better?

#  * Analysis of purpose of each define and other preprocessor command (eg,
# 	portability, efficiency, etc.), like that done by hand for gzip.

# Perhaps do something special about macros that expand into reserved words.
# Specially recognize types, partical declarations.
# 
# I want to recognize that these are type macros (maybe hard, maybe not) and
# that for each the two alternate definitions are equivalent.
# #  define EXTERN(type, array)  extern type * near array
# #  define DECLARE(type, array, size)  type * near array
# #  define EXTERN(type, array)  extern type array[]
# #  define DECLARE(type, array, size)  type array[size]
# 
# deflate.c defines check_match sometimes as a macro and sometimes as a
# function.  (This is for debugging, but one can imagine other reasons.)
# Perhaps remember what the macro is dependenton and if exclusive with the
# definition, don't conflict; also cope with this later.
# 
# PreventMI line count should include the #ifdef and the #endif.
# 
# Look for shadowed globals, also for whether specific globals are ever
# assigned (which is irrelevant for function-like macros, but essential for
# const-like macros).
# 
# Another use of macros is to either "import" or "export" in a header file
# depending on whether you are that DLL or some other user.



###########################################################################
### Strictures
###

require 5.004;  # uses "for my $var"

# Use strict requires that for each global, either
#  * all uses are fully qualified with the package name ($main::$true), or
#  * it is declared with "my" or appears in a use vars qw( ... ) declaration.
use strict;
# Verbose error messages; not sure whether I like it.
# use diagnostics;

use Carp;
use Data::Dumper;
use English;			# Permit use of $MATCH for $& and so forth.
use File::Basename;
use IO::Handle;

use checkargs;
use cline;
use paren;

use em_constants;
use em_util;
use em_depend;


###########################################################################
### Types
###

sub type_to_num ( $ )
{
  my ($type) = check_args(1, @_);
  # print "type = $type; type_num{type} = $type_num{$type} \n";
  # Compress multiple spaces to just one, but don't remove all space!
  $type =~ s/\s+/ /og;
  if (defined($type_num{$type}))
    { return $type_num{$type}; }
  else
    { return $type; }
}


### Numeric types

# This doesn't yet do the right thing.
sub infer_int_type ( $ )
{
  my ($int) = check_args(1, @_);
  if ($int =~ /^0[xX]/)
    # Hex
    { # return first of ($typeUINT $typeLONG $typeULONG) in which the number fits
      return $typeUINT; }
  elsif ($int =~ /^0/)
    { return $typeINT; }	# was unsigned int in non-ANSI C.
  else
    { # return first of ($typeINT $typeLONG $typeULONG) in which the number fits
      return $typeINT; }
}

sub type_integral_p ( $ )
{ my ($type) = check_args(1, @_);
  return (($type eq $typeBOOL)
	  || ($type eq $typeCHAR) || ($type eq $typeUCHAR) || ($type eq $typeSCHAR)
	  || ($type eq $typeSHORT) || ($type eq $typeUSHORT)
	  || ($type eq $typeINT) || ($type eq $typeUINT)
	  || ($type eq $typeLONG) || ($type eq $typeULONG));
}

### Type manipulation: arrays, pointers, functions

sub type_dereference ( $ )
{ my ($type) = check_args(1, @_);
  if ($type eq $typeSTRING)
    { return $typeCHAR; }
  if ($type =~ /(\*|\[\])\s*$/)
    { return $PREMATCH; }
  return $typeUNKNOWN;
}

# A function type looks like ( ),( ),( )->( )
# The full parentheses are necessary (but I don't think they are sufficient)
# to avoid misparsing nested function types.  Maybe that doesn't happen...

# sub type_apply ...

# FIX: this is completely wrong.
sub construct_function_type($@)
{ my ($return_type, @arg_types) = check_args_at_least(1, @_);
  return $return_type;
}

# FIX: this is completely wrong.
sub construct_array_type($;$)
{ my ($elt_type, $size) = check_args_range(1, 2, @_);
  # ignore $size
  return $elt_type;
}


### Type conversions

# Perhaps these should be arrays instead.

sub type_unsignify ( $ )
{
  my ($type) = check_args(1, @_);
  if (($type eq $typeCHAR) || ($type eq $typeSCHAR))
    { return $typeUCHAR; }
  elsif ($type eq $typeSHORT)
    { return $typeUSHORT; }
  elsif ($type eq $typeINT)
    { return $typeUINT; }
  elsif ($type eq $typeLONG)
    { return $typeULONG; }
  else
    { return $type; }
}

sub type_signed ( $ )
{
  my ($type) = check_args(1, @_);
  if (($type eq $typeCHAR) || ($type eq $typeUCHAR))
    { return $typeSCHAR; }
  elsif ($type eq $typeUSHORT)
    { return $typeSHORT; }
  elsif ($type eq $typeUINT)
    { return $typeINT; }
  elsif ($type eq $typeULONG)
    { return $typeLONG; }
  else
    { return $type; }
}

sub type_longify ( $ )
{
  my ($type) = check_args(1, @_);
  # print "type_longify $type (", type_name($type), ")\n";
  if ($type eq $typeCHAR)
    { return $typeLONG; }
  elsif ($type eq $typeUCHAR)
    { return $typeULONG; }
  elsif ($type eq $typeSCHAR)
    { return $typeLONG; }
  elsif ($type eq $typeSHORT)
    { return $typeLONG; }
  elsif ($type eq $typeUSHORT)
    { return $typeULONG; }
  elsif ($type eq $typeINT)
    { return $typeLONG; }
  elsif ($type eq $typeUINT)
    { return $typeULONG; }
  elsif ($type eq $typeLONG)
    { return $typeLONG; }
  elsif ($type eq $typeULONG)
    { return $typeULONG; }
  else
    { return $type; }
}

# The "usual binary conversions"; H&S p. 176
# except that if types are identical, it returns them.
# Can also return short, ushort.
sub type_lub ( $$ )
{ my ($t1, $t2) = check_args(2, @_);
  # This test works whether $t1, $t2 are numbers or strings
  if ($t1 eq $t2)
    { return $t1; }
  if (!is_number($t1))
    { $t1 = $typeUNKNOWN; }
  if (!is_number($t2))
    { $t2 = $typeUNKNOWN; }
  if ($t1 > $t2)
    { ($t1, $t2) = ($t2, $t1); }
  # If either $t1 or $t2 is a string, its numeric equivalent is zero
  if ($t1 == 0)			# 0 == $typeFAIL
    { return $typeFAIL; }
  if ($t2 == $typeUNKNOWN)
    { return $typeUNKNOWN; }
  if (($t2 == $typeLDOUBLE) || ($t2 == $typeDOUBLE) || ($t2 == $typeFLOAT)
      || ($t2 = $typeULONG) || ($t2 = $typeLONG)
      || ($t2 == $typeUINT) || ($t2 == $typeINT)
      || ($t2 == $typeUSHORT)  || ($t2 == $typeSHORT))
    { return $t2; }
  # Otherwise, differing char types.
  return $typeSHORT;
}

### Parsing types

# FIX: GJB
# Given a basetype and declarator string, return a type and an identifier.
sub parse_declarator ( $$ )
{ my ($basetype, $declarator) = check_args(2, @_);
  if ($declarator !~ /$identifier_re/o)
    { parse_error("parse_declarator($basetype, $declarator): no word in declarator");
      return ("$basetype $declarator", "no identifier"); }
  my $id = $MATCH;
  my $prefix = $PREMATCH;
  my $suffix = $POSTMATCH;
  while ($id =~ /^$type_qualifier_re$/o)
    { if ($suffix !~ /$identifier_re/o)
	{ parse_error("parse_declarator($basetype, $declarator): no non-type-qualifier word in declarator");
	  return ("$basetype $declarator", "no identifier"); }
      $id = $MATCH;
      $prefix .= $PREMATCH;
      $suffix = $POSTMATCH; }
  if (($suffix =~ /$identifier_re/o) && ($PREMATCH !~ /\[/))
    { parse_error("multiple words in declarator $declarator");
      # Fix: Don't know how to deal with this yet.
      mdie("multiple words in declarator $declarator"); }
  return ("$prefix($basetype)$suffix", $id);
}

# FIX: GJB
# Given a type string, return a type
sub parse_type ( $ )
{ my ($type) = check_args(1, @_);
  return $type;
}


###########################################################################
### Variables
###

## Integers:


my @rg_physical_lines = (0) x $c_ftype;
my @rg_ncnb_lines = (0) x $c_ftype;
my @rg_cpp_phys_lines = (0) x $c_ftype;
my @rg_cpp_phys_ncnb_lines = (0) x $c_ftype;

my @rg_cpp_cmds = (0) x $c_ftype;

# $rg_category_counts[$ft_index]->{"uncategorized"} ==
# the number of times a macro definition was categorized as uncategorized
# for files of type $ft_index
# (much like @rg_cpp_cmds list of hashes)
my @rg_category_counts;

# Conditional Compilation Directive category counts
# $rg_ccd_cat_counts[$ft_index][$ccatType] ==
# the number of type a CCD of type $ccatType was used in files of type $ft_index
my @rg_ccd_cat_counts;

my @rg_cppcmdcounts;


#my $physical_lines = 0;		# as they appear to tools
#my $ncnb_physical_lines = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines = 0;	# cpp physical lines
#my $cpp_physical_ncnb_lines = 0; # cpp physical lines
#
## Not-include file version of the above
#my $physical_lines_ni = 0;	# as they appear to tools
#my $ncnb_physical_lines_ni = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines_ni = 0;	# cpp physical lines
#my $cpp_physical_ncnb_lines_ni = 0; # cpp physical lines


### These variables (cppBLAH) now get summed
# from the rg_XXX variables, above.
# See compute_global_cpp_sums

# my $cpp_cmds;			# total preprocessor commands
# my $cpp_cmds_ni;		# total preprocessor commands
# my $cpp_cmds_hdr;
# my $cpp_cmds_hdr_ni;
# my $cpp_cmds_c;
# my $cpp_cmds_c_ni;

# Initialize cppcmdcount{"define"} to avoid uninitialized values
# when processing the macros (in case there were no macros).
my %cppcmdcount = (
   "define" => 0,
   "elif" => 0,
   "else" => 0,
   "endif" => 0,
   "error" => 0,
   "ident" => 0,
   "if" => 0,
   "ifdef" => 0,
   "ifndef" => 0,
   "import" => 0,
   "include" => 0,
   "include_next" => 0,
   "line" => 0,
   "pragma" => 0,
   "undef" => 0,
   "%OTHER%" => 0,
); # number of uses of each cpp command
# cppcmdcount_ni is like cppcmdcount, but only for files listed on cmd line
# ni == "not includes"
my %cppcmdcount_ni = (); # number of uses of each cpp command, NI
my %cppcmdcount_hdr_ni = (); # number of uses of each cpp command, header NI
my %cppcmdcount_c_ni = (); # number of uses of each cpp command, code NI


my $symtab_scopes = 0;	# the number of enclosing scopes, less the global scope
## Strings:
my $line = "";			# current line

# @files_function_lines is an array, referenced by filenumber, of an
# in-order list of elements like:  (start_line, function_name, end_line)
my @files_function_lines;

# %function_to_locs is a hash from function name to a list of lists of
#   (fileno,start,end), one per definition of that function.
my %function_to_locs;

# hashes "file:function name" to a list of macro names that it uses
my %function_name_to_macros_it_uses = ();

# If remove "current" from these names, look for other vars of those names.
my $current_file_name;		# the current file name
my $current_file_number;
my $current_ftype_index;		# the index of the @ftype_'s for the current file

# current_line_no is now a function
#my $current_line_no;		# the current line number
my $current_function;		# the current function
my $current_function_start_line; # the first line of the current function
				# (sometimes function headers span lines)
my %functions = ();		# keys are all functions encountered
				#   values are fileno:lineno, separated by ;
my %typedefs = ();		# keys are all typedefs encountered

my $current_macro_line_number;	# Used by current_line_no when categorizing macros

# @file_inclusion_method, a string like "#include<>", tells where file got added
my @files = ($built_in_fake_filename);         # list of files to process
my %file_numbers;
my @file_inclusion_method = ("BuiltIn");

# files that are included should be pushed onto both @files and
# @files_included -- the latter is used only to prevent multiple inclusion
my @files_included;

# Output field separator
my $outOFS;

# @include_path is a list of places to look for included files
use vars '@include_path';


## The %macrosXXX are annotations per macro.
## The @mdef_XXXX arrays are annotations per macro *definition*.

my %macros = ();	# for each macro name, list of indexes for info about it

my %macros_c_undefs = ();	# hashes macro names to the number of times they
				# are #undef-d

my %macros_uses = ();		# hashes macro names to an array
                                # listing the number of times they are
                                # used in (code,macro,cond)

# count of uses is half the number of keys in %macros_file_line_uses
my %macros_file_line_uses = ();	# hashes macro names to an array
				# where consecutive elements
                                # list the filenumber and physical line
				# on which it appears

# can compute the number of uses at global scope with macros_uses and
# the length of the list in macros_used_in_functions
my %macros_used_in_functions = (); # hashes macro names to list of
				# "fileno:function"s that use it.  Will
				# contain same function name
				# repeatedly if the macro is used more
				# than once in that function.

# Two types of elements: macros and other symbols (which CPP treats as zero
# and which are probably bugs anyway; I'll assume everything is a macro).
my %macros_used_by_cpp = ();	# colon-separated file number and line number

sub introduce_new_macro ( $ )
{ my ($name) = check_args(1, @_);
  if (!$name)
    { croak "Empty name for new macro"; }
  # $macros{$name} = [];  is the same as below
  # Also remember, @$macros{$names} is different from @{$macros{$names}}
  #                ^^^^^^^^ assoc array slice           ^^^^^^^^^^^^^^^ ref to array, so @ derefs
  @{$macros{$name}} = ();
  $macros_uses{$name} = [0,0,0,0]; #length is $#i_usage_all+1
  $macros_c_undefs{$name} = 0;
  $macros_used_in_functions{$name} = [];
  $macros_file_line_uses{$name} = [];
}


# # Number of macros defined before parsing -- don't reuse the first
# # $cBuiltinMacros elements of @mdef_XXXXX arrays
# my $cBuiltinMacros = 0;
# Total number of entries in @mdef_XXXX arrays; rename $c_mdef?
my $cMacrosInTables = 0;

# Also want to have summary info true about all definitions...
# FIX: This data structure of parallel arrays could be improved
my @mdef_name;
my @mdef_formals;
my @mdef_body;			# with comments; for user output
# my @mdef_body_noc;		# no comments; for processing (does contain unsimplified strings and character literals)
my @mdef_body_simple;		# no comments; strings and chars are simplified
my @mdef_fileno;
my @mdef_line;
my @mdef_physical_lines;
my @mdef_physical_ncnb_lines;
my @mdef_freefuns;
my @mdef_direct_inclusion_dependenton;		# cpp conditions, not just symbols
my @mdef_direct_expansion_uses;	# direct expansion uses (symbols in body/expansion)
my @mdef_category;
my @mdef_type;			# a C type, like UINT; not always meaningful
my @mdef_properties;
my @mdef_free_vars;		# comma-separated list of variable names
my @mdef_evilness;

# These are for aggregate information -- that is, information about a macro
# gleaned by combining information about all its definitions.
# fix: "mn" stands for "macro name".
my %mntype;
my %mncategory;
my %macro_direct_inclusion_dependentons; # list of lists of cpp conditions under
				# which some version of the macro is defined

my %file_direct_inclusion_dependentons; # list of dependentons
my %file_direct_inclusion_dependent_macros; # from the above, merged
my %file_inclusion_dependent_macros; # from the above, merged
my %file_included_by;		# hash of references to lists of files that include this one

# Each of these counts how many lines depend on a specific number of macros.
my @incl_dependence_count = ();
my @exp_dependence_count = ();
my @either_dependence_count = ();

# These hashes map to a number; the dependees are transitive, not just direct.
my %inclusion_dependee_lines = ();
my %expansion_dependee_lines = ();
# Count each line (which can be both incl and exp dependent on a symbol) once.
my %either_dependee_lines = ();


# This is a hack.
# Macros which expand to their argument or the empty list, for function arg decls.
my %fun_decl_arg_macros;
my %semi_fun_decl_arg_macros;
my %void_macros;

## Debugging; should add more
my $fDebugCmdProcessing = $false;
my $fDebugCommentRemoval = $false;
my $debug_scopes = $false;
my $debug_type_match = $false;
my $debug_parse_function = $false;
my $debug_parse_expression = $false;
my $debug_parse_statement = $false;
my $debug_parse_declaration = $false;
my $debug_merge_branches = $false;
my $debug_parse_array_init = $false;
my $debug_peek = $false;
my $debug_getline = $false;	# a LOT of output; use only on small inputs
my $debug_categorize_macro = $false;
my $debug_cpp_if_comments = $false;
my $debug_dependences = $false;
my $debug_dependences_internal = $false;
my $debug_ccd_categories = $false;

my $compute_transitive_dependence_info = $true;

## Command-line processing; add to $getopts_option_letters if you change this
# Are these in any order?
use vars qw($opt_i $opt_I $opt_h $opt_v $opt_t $opt_d $opt_l
	    $opt_E $opt_P $opt_p $opt_n $opt_F $opt_M
	    $opt_u $opt_e $opt_1 $opt_A $opt_a $opt_g $opt_L $opt_T);
my $fIgnoreIncludes = $false;


###########################################################################
### Pass 1: collect information about preprocessor use
###

# These indicate the pass, for getline_handle_preprocessor_command.
# Since they're dynamically bound with "local", can't declare them with "my".
use vars qw($finding_macro_defs $finding_macro_uses $categorizing_macros $merge_cpp_if_branches);
$finding_macro_defs = $false;
$finding_macro_uses = $false;
$categorizing_macros = $false;
$merge_cpp_if_branches = $false;

# List (actually stack) of #if conditions for the current line.
my @current_inclusion_dependenton = ();


### Read files, save info about macros
sub find_macro_definitions ( )
{
  check_args(0, @_);
  if ($finding_macro_defs)
    { mdie("Called find_macro_definitions, but already finding macrodefs"); }
  local $finding_macro_defs = $true;
# Do not use a foreach, since we're pushing on to the end of @files,
#   and the list foreach uses does not get updated
#  foreach my $this_file (@files)
  # skip index 0, which is built_in_fake_filename
  for (my $ifiles = 1; $ifiles <= $#files; $ifiles++)
    { $current_file_number = $ifiles;
      $current_file_name = $files[$current_file_number];
      $current_ftype_index = compute_ftype_index($current_file_number);

      print STDERR "file: \"$current_file_name\"" if $opt_v;
      if (!open(INPUT,$current_file_name)) {
	# fix: Add quiet option; then this will occur unless that is set.
	print STDERR " -- failed open\n" if $opt_v;
	next; # skip to next file if open fails
      } else {
	print STDERR "\n" if $opt_v;
      }

      check_file_boundary();
      while ($line = get_fulltoken_line())
	{
	  # Amazingly enough, all the work is done by get_fulltoken_line, which
	  # calls process_macro_definition.
	}
      check_file_boundary();
      close(INPUT);
    }
}

# Given a macro definition (everything after "#define", with no leading or
# trailing space), enter it into the appropriate global arrays.
# This occurs during the first pass.
sub process_macro_definition ( $$$$ )
{
  my ($def,$def_noc,$macro_physical_lines,$macro_physical_ncnb_lines)
    = check_args(4, @_);
  # print "process_macro_definition <<$def>>\n";
  # macrosplit should be extended to deal with line breaks.
  $def =~ s/\\?\n//g;		# backslash is optional; can have line breaks in comments
  # $def_noc =~ s/\\\n//g;
  my ($name_ignore, $args_ignore, $body) = macrosplit($def);
  my ($name, $args, $body_noc) = macrosplit($def_noc);
  my $body_simple = cline_simplify($body_noc);
  # print "process_macro_definition $name $macro_physical_lines $macro_physical_ncnb_lines\n";
  # print STDERR "PARSED: $name\n";
  if (!defined($args)) { $args = ""; }
  # print "parsed: |$name|$args|$body|\n";
  # Do not just use $cppcmdcount{"define"}, since our builtins require
  # some space in the @mdef_XXXXX arrays
  my $this_macro_index = $cMacrosInTables;
  $cMacrosInTables++;

  ## First, add information about this macro, if necessary.

  # initialize all the parallel arrays here,
  # so that we don't have to check the defined-ness later
  if (!defined($macros{$name}))
    { introduce_new_macro($name); }

  ## Second, add information about this macro definition.

  push @{$macros{$name}}, $this_macro_index;
  # print "def number $#{$macros{$name}}:";
  # for (my $i = 0; $i <= $#{$macros{$name}}; $i++)
  #   { print " $macros{$name}[$i]"; }
  # print "\n";
  $mdef_name[$this_macro_index] = $name;
  $mdef_formals[$this_macro_index] = $args;
  $mdef_body[$this_macro_index] = $body;
  # $mdef_body_noc[$this_macro_index] = $body_noc;
  $mdef_body_simple[$this_macro_index] = $body_simple;

  # We track both the physical lines in a macro definition
  # (mdef_physical_lines) which is the extent of the macro (where it appears
  # in the file) and the physical code lines (mdef_physical_ncnb_lines)
  # which does not count comment only lines in a macro definition
  # eg.
  # --begin, non-inclusive--
  # #define BOOL int /* we do not
  #                     have a built
  #                     in type so we
  #                     use bool */
  # --end, non-inclusive--
  # would count as 4 physical lines, 1 ncnb (non-comment,non-blank)
  # line, 1 cpp_physical_code_line, and 4 cpp_physical_lines

  $mdef_physical_lines[$this_macro_index] = $macro_physical_lines;
  $mdef_physical_ncnb_lines[$this_macro_index] = $macro_physical_ncnb_lines;
  $mdef_direct_inclusion_dependenton[$this_macro_index]
    = simplify_dependenton([ @current_inclusion_dependenton ]);
  if ((!defined($current_file_name)) || (!defined($current_file_number)))
    { mdie("undefined current_file_name or _number while processing $name"); }
  $mdef_fileno[$this_macro_index] = $current_file_number;
  $mdef_line[$this_macro_index] = current_line_no();
  # PERLNOTE: be careful not to do
  # $mdef_direct_expansion_uses[$this_macro_index] = ();  ##WRONG
  # you'll get a weird error message at the point of use
  # mdef_direct_expansion_uses is a list of references to arrays
  @{$mdef_direct_expansion_uses[$this_macro_index]} = ();
}

# process_macro_undefinition handles #undef-s
sub process_macro_undefinition ( $$ ) {
  my ($cpp_cmd_arg, $cpp_cmd_arg_noc) = check_args(2, @_);

  # Pull out first word
  if ($cpp_cmd_arg_noc =~ /^$identifier_re/o)
    { my $macro_name  = $MATCH;
      $macros_c_undefs{$macro_name}++; }
  else
    { evilprint("No macro name follows #undef: $cpp_cmd_arg\n"); }
}


###########################################################################
### Dependenton processing
###


# A "dependenton" is (a reference to) an ordered list of strings, each
# string a cpp condition that is a sensible argument to #if.  A
# "dependentons" is an unordered list of such.


# Remove duplicate elements produced by "#if FOO #if FOO <body> #endif #endif".
# (Of dubious utility -- duplication wasn't happening where I thought it was,
# for I'd overlooked a trailing underscore.)
# (But it does seem likely to be useful for file inclusion dependences...)
sub simplify_dependenton ( $ )
{ my ($dep_array_ref) = check_args(1, @_);
  if (scalar(@{$dep_array_ref}) < 2)
    { return $dep_array_ref; }

  my @dep_array = @{$dep_array_ref};
  # print "simplify_dependenton (", scalar(@{$dep_array_ref}), ",", scalar(@dep_array), "): @dep_array\n";
  for (my $i = 0; $i < $#dep_array; $i++)
    { for (my $j = $i+1; $j <= $#dep_array; $j++)
	{ if ($dep_array[$i] eq $dep_array[$j])
	    { splice(@dep_array, $j, 1);
	      # print "spliced dep_array $j (size now ", scalar(@dep_array), "): @dep_array\n";
	      $j--; } } }
  # print "simplify_dependenton returning @dep_array\n";
  return [ @dep_array ];
}


# The argument should already be reduced
sub macros_in_dependentons ( @ )
{ my @dependentons = check_args_at_least(0, @_);
  my %result_hash = ();
  for my $dependenton (@dependentons)
    { for my $cond_arr (@{$dependenton})
	{ for my $condition (@{$cond_arr})
	    { if ($debug_dependences)
		{ print "macros in condition $condition: ", macros_in($condition), "\n"; }
	      for my $macro (macros_in($condition))
		{ $result_hash{$macro} = $true; } } } }
  return keys(%result_hash);
}


# ## Not currently called anywhere -- and currently contains type errors!
# # Given a macro name, return a list of some of (direct)
# # must include, expansion, and may include dependences.
# sub macro_must_and_may_dependences ( $ )
# {
#   my $macro_name = check_args(1, @_);
#   my $must_dependences = macro_defined_dependentons($macro_name);
#   my %must_dep = ();
#   my %may_dep = ();
#   # Bad use of must_dependences!
#   for my $dep (@{$must_dependences})
#     { $must_dep{$dep} = $true; }
#   for my $mdef_dep (map { $mdef_direct_inclusion_dependenton[$_] } @{$macros{$macro_name}})
#     { if (! (defined($must_dep{$mdef_dep})))
# 	{ $may_dep{$mdef_dep} = $true; } }
#   return ($must_dependences, keys %may_dep);
# }


# Given a macro name, try to merge the inclusion_dependentons for all its
# definitions, and return a single dependenton or $false.  If a dependenton
# is returned, then the the macro is defined iff the resulting conditions
# are true (more precisely, it is not defined if the conditions are not
# true, because we don't remember what guards a #include).  The macro's
# value may also depend on other conditions, because two definitions
# dependent on (foo, !bar) and (foo, bar) yield a defined_dependenton of
# (foo).
sub macro_defined_dependentons ( $ )
{
  my ($macro_name) = check_args(1, @_);
  if (!wantarray)
    { croak "Should only call macro_defined_dependentons in list context"; }

  my @dependentons = map { $mdef_direct_inclusion_dependenton[$_] } @{$macros{$macro_name}};

  #   print "macro_defined_dependenton $macro_name (", scalar(@dependentons), ")...\n";
  #   for my $dep (@dependentons)
  #     { print "    @{$dep}\n"; }

  return reduce_dependentons(@dependentons);
}


## Is this useful?  I don't think so.
# # Try to merge the given inclusion_dependentons, and return a single
# # dependenton or $false.
# sub merge_dependentons ( @ )
# {
#   my @dependentons = check_args_at_least(0, @_);
# 
#   # Perhaps use a named loop instead of the gotos.
# MDLOOP:
#   if (scalar(@dependentons) == 1)
#     { return $dependentons[0]; }
# 
#   # Try to find two definitions that can be merged.
#   for my $index1 (0..$#dependentons-1)
#     { for my $index2 ($index1+1..$#dependentons)
# 	{ my $merged = merge_dependenton($dependentons[$index1], $dependentons[$index2]);
# 	  if ($merged)
# 	    { # $index2 > $index1, so do $index2 first
# 	      # splice returns the removed element, so don't use the result.
# 	      splice(@dependentons, $index2, 1);
# 	      splice(@dependentons, $index1, 1);
# 	      # Would shift be better, to not redo failures?  Probably short anyway.
# 	      push(@dependentons, $merged);
# 	      goto MDLOOP; } } }
#   # print "merge_dependentons FALSE\n";
#   # Don't return [ ]; if we failed, we don't want anyone to use the result.
#   return $false;
# }

# Given a list of (references to) dependenton lists,
# return a shorter such list, possibly containing only one reference.
sub reduce_dependentons ( @ )
{ my @dependentons = check_args_at_least(0, @_);
  if (!wantarray)
    { croak "Should only call reduce_dependentons in list context"; }

  # Try to merge each pair of dependentons; if successful, add that
  # dependenton and remember from whence it came.  Finally, go from
  # shortest to longest, selecting dependentons that add one of the
  # original ones until the originals are exhausted (covered).

  my $last_len = 0;

  if ($debug_dependences_internal)
    { print "reduce_dependentons <= length=", scalar(@dependentons), "\n"; }

  { my $i = 1;
  OUTER:
    while ($i <= $#dependentons)
      { # print "checking $i\n";
	for my $j (0 .. $i-1)
	  { # print "checking $j,$i\n";
	    if (array_equal($dependentons[$j], $dependentons[$i]))
	      { splice(@dependentons, $i, 1);
		next OUTER; } }
	$i++; } }

  my $len = scalar(@dependentons);
  if ($debug_dependences_internal)
    { print "reduce_dependentons <= length=$len without duplicates\n"; }

  if ($len < 2)
    { return @dependentons; }

  # array of hashes
  my @subsumed = map { { $_ => $true } } (0 .. $#dependentons);

  while ($last_len < $len)
    {
      if ($debug_dependences_internal)
	{ print "Looping with $last_len,$len\n"; }
      # Try to find two definitions that can be merged.
      for my $index1 ($last_len..$len-1)
	{ for my $index2 (0..$index1-1)
	    { my $merged = merge_dependenton($dependentons[$index1], $dependentons[$index2]);
	      if ($debug_dependences_internal)
		{ print "merged $index1 and $index2 into "
		    , ($merged ? "@{$merged}" : "<<NOTHING>>"), "\n"; }
	      if ($merged)
		{ my $duplicate = $false;
		  for my $index3 (0..$#dependentons)
		    { if (array_equal($merged, $dependentons[$index3]))
			{ $duplicate = $true;
			  $subsumed[$index3]->{$index1} = $true;
			  $subsumed[$index3]->{$index2} = $true;
			  # push(@{$subsumed[$index3]}, $index1, $index2);
			} }
		  if (!$duplicate)
		    { push(@dependentons, $merged);
		      my %combined = ( %{$subsumed[$index1]}, %{$subsumed[$index2]}, $#dependentons, $true );
		      if ($debug_dependences_internal)
			{ print "combined: ", join(" ", keys(%combined)), "\n"; }
		      $subsumed[$#dependentons] = \%combined; } } } }
      $last_len = $len;
      $len = scalar(@dependentons);
    }

  my @sorted_indices = sort { (scalar(@{$dependentons[$a]}) cmp scalar(@{$dependentons[$b]}))
				|| (scalar(%{$subsumed[$a]}) cmp scalar(%{$subsumed[$b]})) } (0 .. $#dependentons);

  if ($debug_dependences_internal)
    { print "sorted indices: ", join(" ", @sorted_indices), "\n"; }

  my @result = ();
  my @subsumed_by_any = ();
  for my $index (@sorted_indices)
    { if (!defined($subsumed_by_any[$index]))
	{ push(@result, $dependentons[$index]); }
      if ($debug_dependences_internal)
	{ print "$index <@{$dependentons[$index]}> subsumes ", join(" ", keys %{$subsumed[$index]}), "\n"; }
      foreach my $subidx (keys %{$subsumed[$index]})
	{ $subsumed_by_any[$subidx] = $true; } }

  # Testing, delete later
  if (scalar(@subsumed_by_any) != scalar(@dependentons))
    { die "Bad subsumed_by_any length ", scalar(@subsumed_by_any), " should be ", scalar(@dependentons); }
  for my $i (0 .. $#subsumed_by_any)
    { if (!defined($subsumed_by_any[$i]) || !$subsumed_by_any[$i])
	{ die "Bad subsumed_by_any[$i] '$subsumed_by_any[$i]'"; } }
  if (!scalar(@result))
    { die "Empty result"; }

  return @result;
}


sub format_dependentons ( @ )
{ my @dependentons = check_args_at_least(0, @_);
  # print "format_dependentons <= @dependentons\n";
  return join(' ; ', map { "@{$_}" } @dependentons);
}


## Using prototype (@\@) is a clever idea, but it doesn't work.  Try
##   my @foo = (1, 2, 3);
##   my @bar = (1, 2, 3);
##   check(sub {eval $_[0]}, 'array_equal(@foo, @bar)');

# Both arguments should be references to arrays.
sub array_equal ( $$ )
{ my ($ref1,$ref2) = check_args(2, @_);
  if (!ref($ref1) || !ref($ref2))
    { croak "Arguments to array_equal should be references to arrays: '$ref1' '$ref2'" }
  # print "'$ref1' '$ref2'  <<@{$ref1}>> <<@{$ref2}>>\n";
  if (scalar(@{$ref1}) != scalar(@{$ref2}))
    { return $false; }
  for my $i (0..$#{$ref2})
    { if ($ref1->[$i] ne $ref2->[$i])
	{ return $false; } }
  return $true;
}


# This code avoids misclassifying a function as a macro when both exist;
# but is it worth it?

# $macro_dep is a list of conditions under which the macro is defined --
# more precisely, if they are not satisfied, the macro is not defined.
# Return false if it contains a condition which is false in the current
# conditional compilation environment, but such that all previous
# conditions are true.
sub macro_active ( $$ )
{ my ($macro_name, $line_inclusion_dependenton) = check_args(2, @_);

  # No longer necessary, since this is always an array ref, never $false.
  #   if (!$macro_direct_inclusion_dependenton{$macro_name})
  #     { return $true; }

  # print "macro_active <= $macro_name\n";
  # print "mdid: '$macro_direct_inclusion_dependentons{$macro_name}'";

  if (!$compute_transitive_dependence_info)
    { return $true; }

  if (scalar(@{$macro_direct_inclusion_dependentons{$macro_name}}) == 0)
    { # die "Empty macro_direct_inclusion_dependentons for $macro_name";
      return $true; }

  #   print "macro_active $macro_name\n";
  #   print "  ldep ", scalar(@{$line_inclusion_dependenton}), ": @{$line_inclusion_dependenton}\n";
  #   print "  mdep ", scalar(@{$macro_direct_inclusion_dependenton{$macro_name}}), ": @{$macro_direct_inclusion_dependenton{$macro_name}}\n";

  # This hash may not be worth building; but it simplifies control structure.
  my %ldeps = ();
  for my $ldep (@{$line_inclusion_dependenton})
    { $ldeps{$ldep} = $true; }
  for my $mdepon (@{$macro_direct_inclusion_dependentons{$macro_name}})
    { for my $mdep (@{$mdepon})
	{ if (exists($ldeps{negate_cpp_if_condition($mdep)}))
	    { # This macro condition is contradicted by the current line.
	      last; }
	  if (!exists($ldeps{$mdep}))
	    { # This macro condition isn't mentioned by the current line.
	      return $true; }
	  # This macro condition is supported by the current line, so continue.
	}
      # Every condition in the macro dependence is true in the line dependence.
      return $true;
    }
  # None of the macro dependences was satisfied.
  return $false;
}


# What should this do for
#    macro_defined_dependenton __BIT_TYPES_DEFINED__ (2)...
#        !defined(__BIT_TYPES_DEFINED__) (defined(BSD) && (BSD >= 199306)) ||  (defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199312))
#        !defined(__BIT_TYPES_DEFINED__)
# The macro is not defined if __BIT_TYPES_DEFINED__ is true, but
# merge_dependenton returns false (which is effectively "always defined").

## Used only in reduce_dependentons.
# Takes a pair of references to dependenton arrays.
# If the dependentons are the same for all but the last element, return all
# but that last element.  Otherwise return $false.
sub merge_dependenton ( $$ )
{ my ($do1, $do2) = check_args(2, @_);
  my $len1 = scalar(@{$do1});		# actually maximal index, not length
  my $len2 = scalar(@{$do2});

  if ($len1 != $len2)
    { return $false; }
  if ($len1 == 0)
    { return [ ]; }
  my $maxidx = $len1-1;
  for my $i (0..$maxidx-1)
    { if ($do1->[$i] ne $do2->[$i])
	{ return $false; } }
  if ($do1->[$maxidx] eq $do2->[$maxidx])
    { # The two dependenton arrays are identical
      return [ @{$do1} ]; }
  if ($do1->[$maxidx] ne negate_cpp_if_condition($do2->[$maxidx]))
    { return $false; }
  # The two dependenton arrays are identical, except last element is negated.
  my $result = [ @{$do1} ];
  pop(@{$result});
  return $result;
}



# potential problem:  if arg == "!(!(...))", then  (nif(nif($arg)) ne $arg)
sub negate_cpp_if_condition ( $ )
{
  my ($cond) = check_args(1, @_);
  if ($cond =~ /^!defined\($identifier_re\)$/o)
    { return substr($cond,1); }
  elsif ($cond =~ /^!\((.*)\)$/)
    { my $negated = $1;
      # avoid converting "!(A) && (B)" into "A) && (B".
      if (paren_change($negated))
	{ return "!($cond)"; }
      else
	{ return $1; } }
  else
    { return "!($cond)"; }
}


# Not sure whether it would be faster and just as effective to merely check
# for a set of common trivially false conditions, like this used to do.
sub cpp_trivially_false_condition ( $ )
{ my ($cond) = check_args(1, @_);
  if (($cond eq "0") || ($cond =~ /^0\s*&&/))
    { return $true; }
  elsif ($cond =~ /^\(\s*(.*)\s*\)$/)
    { return cpp_trivially_false_condition($1); }
  elsif ($cond =~ /^!\s*1$/)
    { return $true; }
  elsif ($cond =~ /^!\((.*)\)$/)
    { my $negated = $1;
      if (paren_change($negated))
	{ return $false; }
      else
	{ return cpp_trivially_true_condition(negate_cpp_if_condition($cond)); } }
  else
    { return $false; }
}


# Just like the above, with 0 and 1 reversed
sub cpp_trivially_true_condition( $ )
{ my ($cond) = check_args(1, @_);
  if (($cond eq "1") || ($cond =~ /^1\s*\|\|/))
    { return $true; }
  elsif ($cond =~ /^\(\s*(.*)\s*\)$/)
    { return cpp_trivially_true_condition($1); }
  elsif ($cond =~ /^!\s*0$/)
    { return $true; }
  elsif ($cond =~ /^!\((.*)\)$/)
    { my $negated = $1;
      if (paren_change($negated))
	{ return $false; }
      else
	{ return cpp_trivially_false_condition(negate_cpp_if_condition($cond)); } }
  else
    { return $false; }
}


###########################################################################
### Dependence processing
###

# These hashes map a macro name to another hash representing a set of macro names.
# They are transitive dependences, not just direct dependences.

my %macro_inclusion_dependenton;
my %macro_inclusion_dependees;	# inverse of inclusion_dependenton
my %macro_expansion_dependenton;
my %macro_expansion_dependees;	# inverse of expansion_dependenton

my %file_includers;
my %file_includees;	# inverse of inclusion_dependenton

# These hashes map a macro name to another hash representing a set of macro names.
# They are transitive dependences, not just direct dependences.

# It's gross that these variables and functions are at the top level, but
# Perl has no first-class closures or nested procedures so far as I know.
my %local_inclusion_dependenton;
my %local_inclusion_dependees;	# inverse of inclusion_dependenton
my %local_expansion_dependenton;
my %local_expansion_dependees;	# inverse of expansion_dependenton

# An element is on the worklist if its dependence information has changed
# but macros dependent on it haven't been updated.
my @local_dependence_worklist;
my %local_dependence_worklist_members;


sub undef_local_inclusion_depend_vars ( )
{ check_args(0, @_);
  # First, really initialize the data to be empty.
  undef %local_inclusion_dependenton;
  undef %local_inclusion_dependees;
  undef %local_expansion_dependenton;
  undef %local_expansion_dependees;
  undef @local_dependence_worklist;
  undef %local_dependence_worklist_members;
}


# Not used, I think.
sub clear_local_inclusion_depend_vars ( )
{ check_args(0, @_);
  # First, really initialize the data to be empty.
  for my $name (keys %macros)
    { $local_inclusion_dependenton{$name} = {};
      $local_inclusion_dependees{$name} = {};
      $local_expansion_dependenton{$name} = {};
      $local_expansion_dependees{$name} = {}; }

  # Now caller should initialize the dependences with direct information
}

sub check_dependence_invariants ( )
{ check_args(0, @_);
  print "check_dependence_invariants...\n";
  my ($key, $value);
  while (($key, $value) = each %local_inclusion_dependenton)
    { for my $value_elt (keys %{$value})
	{ if (!defined($local_inclusion_dependees{$value_elt}{$key}))
	    { print @{$value}, "\n";
	      print keys %{$local_inclusion_dependees{$value_elt}}, "\n";
	      croak "$key is inclusion dependent on $value_elt, which doesn't list it as a dependee"; } } }
  while (($key, $value) = each %local_inclusion_dependees)
    { for my $value_elt (keys %{$value})
	{ if (!defined($local_inclusion_dependenton{$value_elt}{$key}))
	    { print @{$value}, "\n";
	      print keys %{$local_inclusion_dependenton{$value_elt}}, "\n";
	      croak "$key is inclusion dependent on $value_elt, which doesn't list it as a dependee"; } } }

  while (($key, $value) = each %local_expansion_dependenton)
    { for my $value_elt (keys %{$value})
	{ if (!defined($local_expansion_dependees{$value_elt}{$key}))
	    { print @{$value}, "\n";
	      print keys %{$local_expansion_dependees{$value_elt}}, "\n";
	      croak "$key is expansion dependent on $value_elt, which doesn't list it as a dependee"; } } }
  while (($key, $value) = each %local_expansion_dependees)
    { for my $value_elt (keys %{$value})
	{ if (!defined($local_expansion_dependenton{$value_elt}{$key}))
	    { print @{$value}, "\n";
	      print keys %{$local_expansion_dependenton{$value_elt}}, "\n";
	      croak "$key is expansion dependent on $value_elt, which doesn't list it as a dependee"; } } }

  { my @sorted_wl_1 = sort @local_dependence_worklist;
    my @sorted_wl_2 = sort keys %local_dependence_worklist_members;
    if (scalar(@sorted_wl_1) != scalar(@sorted_wl_2))
      { print "@sorted_wl_1\n@sorted_wl_2\n";
	croak "Worklist sizes not in agreement: " . scalar(@local_dependence_worklist) . " " . scalar(keys %local_dependence_worklist_members); }
    for (my $i = 0; $i <= $#sorted_wl_1; $i++)
      { if ($sorted_wl_1[$i] ne $sorted_wl_2[$i])
	  { print join(" ", @sorted_wl_1), "\n";
	    print join(" ", @sorted_wl_2), "\n";
	    croak "Disagreement in worklists at $i: $sorted_wl_1[$i] $sorted_wl_2[$i]"; } } }

  print "check_dependence_invariants...done\n";
}


sub add_inclusion_dependence ( $$ )
{ my ($dependent, $controller) = check_args(2, @_);
  if ((!$dependent) || (!$controller))
    { croak "Empty argument: <$dependent> <$controller>"; }
  if ($debug_dependences)
    { print "Adding inclusion dependence: $dependent dependent on $controller\n"; }
  # if ($debug_dependences)
  #   { check_dependence_invariants(); }
  if (!defined($local_inclusion_dependenton{$dependent}{$controller}))
    { if (defined($local_inclusion_dependees{$controller}{$dependent}))
	{ mdie("This can't happen: $dependent $controller"); }
      $local_inclusion_dependenton{$dependent}{$controller} = $true;
      $local_inclusion_dependees{$controller}{$dependent} = $true;
      if (!defined($local_dependence_worklist_members{$dependent}))
	{ push(@local_dependence_worklist, $dependent);
	  $local_dependence_worklist_members{$dependent} = $true; } }
  # if ($debug_dependences)
  #   { check_dependence_invariants(); }
}

sub add_expansion_dependence ( $$ )
{ my ($dependent, $controller) = check_args(2, @_);
  if ((!$dependent) || (!$controller))
    { croak "Empty argument: <$dependent> <$controller>"; }
  if ($debug_dependences)
    { print "Adding expansion dependence: $dependent dependent on $controller\n"; }
  # if ($debug_dependences)
  #   { check_dependence_invariants(); }
  if (!defined($local_expansion_dependenton{$dependent}{$controller}))
    { if (defined($local_expansion_dependees{$controller}{$dependent}))
	{ mdie("This can't happen: $dependent $controller"); }
      $local_expansion_dependenton{$dependent}{$controller} = $true;
      $local_expansion_dependees{$controller}{$dependent} = $true;
      if (!defined($local_dependence_worklist_members{$dependent}))
	{ push(@local_dependence_worklist, $dependent);
	  $local_dependence_worklist_members{$dependent} = $true; } }
  # if ($debug_dependences)
  #   { check_dependence_invariants(); }
}


# This runs before pass 2, so that it can quickly determine complete
# transitive dependences given direct dependences.
sub transitive_closure_dependences ( )
{ check_args(0, @_);

  if ($opt_v) { print STDERR "Computing transitive dependences...\n"; }

  # Maybe put some debugging output here.

  # Expand the direct information into its transitive closure.
  # It would be more efficient to work from the leaves inward where possible.

  # To be clever, could initialize the worklist with elements in reverse
  # postorder instead of random order.  This will work well if the dependences
  # are mostly tree-structured.

  if ($debug_dependences)
    { check_dependence_invariants(); }

  my $worklist_shifts = 0;

  while (scalar(@local_dependence_worklist))
    { my $elt = shift(@local_dependence_worklist);
      $worklist_shifts++;
      if ($worklist_shifts % 100 == 0)
	{ if ($opt_v) {print STDERR "Removed $worklist_shifts worklist elements (last $elt), ", scalar(@local_dependence_worklist), " remaining.\n"; } }
      if (!defined($local_dependence_worklist_members{$elt}))
	{ print "@local_dependence_worklist\n";
	  print (sort keys %local_dependence_worklist_members); print "\n";
	  mdie("Element $elt from worklist wasn't in members hash"); }
      delete($local_dependence_worklist_members{$elt});
      if (defined($local_dependence_worklist_members{$elt}))
	{ mdie("This can't possibly happen"); }
      if ($debug_dependences)
	{ print "removed $elt from dependence worklist (", scalar(@local_dependence_worklist), ",", scalar(keys %local_dependence_worklist_members), ")\n"; }

      # In the comments below, "IC =I=> IE" means "IE is inclusion-dependent
      # on IC".  IC stands for inclusion controller and IE for inclusion
      # controlee.

      {
	# It might be slightly faster to play this game only with the changes
	# rather than the whole dependences; but don't bother until we know that
	# this is a problem.
	my @i_controllers = keys %{$local_inclusion_dependenton{$elt}};
	my @i_controlees = keys %{$local_inclusion_dependees{$elt}};
	my @e_controllers = keys %{$local_expansion_dependenton{$elt}};
	my @e_controlees = keys %{$local_expansion_dependees{$elt}};

	if ($debug_dependences)
	  { check_dependence_invariants(); }

	for my $i_controller (@i_controllers)
	  { # We know that $i_controller =I=> $elt
	    { for my $i_controllee (@i_controlees)
		{ # IC =I=> this =I=> IE  implies  IC =I=> IE
		  add_inclusion_dependence($i_controllee, $i_controller); } }
	    { for my $e_controllee (@e_controlees)
		{ # IC =I=> this =E=> EE  implies  IC =I=> EE
		  add_inclusion_dependence($e_controllee, $i_controller); } } }

	for my $e_controller (@e_controllers)
	  { # We know that $e_controller =E=> $elt
	    { for my $i_controllee (@i_controlees)
		{ # EC =E=> this =I=> IE  implies  EC =I=> IE
		  add_inclusion_dependence($i_controllee, $e_controller); } }
	    { for my $e_controllee (@e_controlees)
		{ # EC =E=> this =E=> EE  implies  EC =E=> EE
		  add_expansion_dependence($e_controllee, $e_controller); } } } }

      if ($debug_dependences)
	{ check_dependence_invariants(); }
    }

  # whew, done computing %local_inclusion_dependenton %local_inclusion_dependees
  # %local_expansion_dependenton %local_expansion_dependees.

  if ($opt_v) { print STDERR "Computing transitive dependences...done\n"; }
}


###
### Now uses of the above
###

sub compute_transitive_dependences ( )
{
  compute_transitive_file_dependences();
  compute_transitive_macro_dependences();
  undef_local_inclusion_depend_vars();
}

# Very similar to compute_transitive_macro_dependences.
sub compute_transitive_file_dependences ( )
{ check_args(0, @_);

  if ($opt_v) { print STDERR "Computing transitive file dependences...\n"; }

  %local_inclusion_dependenton = ();
  %local_inclusion_dependees = ();
  %local_expansion_dependenton = ();
  %local_expansion_dependees = ();
  for my $name (@files)
    { $local_inclusion_dependenton{$name} = {};
      $local_inclusion_dependees{$name} = {};
      $local_expansion_dependenton{$name} = {};
      $local_expansion_dependees{$name} = {}; }

  # Initialize the dependences with direct information
  for my $file (@files)
    { for my $including_file (@{$file_included_by{$file}})
	{ add_inclusion_dependence($file, $including_file); } }

  transitive_closure_dependences();

  %file_includers = %local_inclusion_dependenton;
  %file_includees = %local_inclusion_dependees;

  # Testing
  { my $key;
    my $value;
    while (($key, $value) = each %local_expansion_dependenton)
      { if (0 != scalar(keys %{$value}))
	  { die "Non-empty local_expansion_dependenton for key $key: "
	      . join(" ; ", @{$value}); } }
    while (($key, $value) = each %local_expansion_dependees)
      { if (0 != scalar(keys %{$value}))
	  { die "Non-empty local_expansion_dependentees for key $key: "
	      . join(" ; ", @{$value}); } } }

  # Set %file_[direct_]inclusion_dependent_macros
  for my $file (@files)
    { if ($debug_dependences)
	{ print "setting file_direct_inclusion_dependent_macros{$file}\n"; }
      my @macros_depended_on;
      if (!exists($file_direct_inclusion_dependentons{$file}))
	{ @macros_depended_on = (); }
      else
	{ my @reduced_dependentons
	    = reduce_dependentons($file_direct_inclusion_dependentons{$file});
	  @macros_depended_on = macros_in_dependentons(@reduced_dependentons); }
      $file_direct_inclusion_dependent_macros{$file} = \@macros_depended_on; }
  for my $file (@files)
    { my %macros_depended_on = ();
      for my $macro (@{$file_direct_inclusion_dependent_macros{$file}})
	{ $macros_depended_on{$macro} = $true; }
      # print "file_includers{$file} = $file_includers{$file}\n";
      for my $includer (keys %{$file_includers{$file}})
	{ for my $macro (@{$file_direct_inclusion_dependent_macros{$includer}})
	    { $macros_depended_on{$macro} = $true; } }
      my @macros_depended_on = keys %macros_depended_on;
      $file_inclusion_dependent_macros{$file} = \@macros_depended_on; }
}


# This runs before pass 2, so that it can quickly determine complete
# transitive dependences given direct dependences.
sub compute_transitive_macro_dependences ( )
{ check_args(0, @_);

  if ($opt_v) { print STDERR "Computing transitive macro dependences...\n"; }

  %local_inclusion_dependenton = ();
  %local_inclusion_dependees = ();
  %local_expansion_dependenton = ();
  %local_expansion_dependees = ();
  for my $name (keys %macros)
    { $local_inclusion_dependenton{$name} = {};
      $local_inclusion_dependees{$name} = {};
      $local_expansion_dependenton{$name} = {};
      $local_expansion_dependees{$name} = {}; }

  # Initialize the dependences with direct information
  for my $name (keys %macros)
    { my @mddepons = macro_defined_dependentons($name);
      $macro_direct_inclusion_dependentons{$name} = \@mddepons;
      for my $index (@{$macros{$name}})
	{
	  # direct inclusion dependences are mdef_direct_inclusion_dependenton
	  for my $incl_dep (@{$mdef_direct_inclusion_dependenton[$index]})
	    { for my $word (macros_in($incl_dep))
		{ add_inclusion_dependence($name, $word); } }
	  ## This version depends on mdef_direct_expansion_uses; compute the
	  ## same info myself so needn't wait until after pass 2.
	  # # direct expansion dependences are mdef_direct_expansion_uses
	  # for my $exp_dep (@{$mdef_direct_expansion_uses[$this_macro_index]})
	  #  { add_expansion_dependence($name, $exp_dep); }
	  for my $exp_dep (macros_in($mdef_body_simple[$index]))
	    { add_expansion_dependence($name, $exp_dep); } } }

  for my $name (keys %macros)
    { my %files = ();
      for my $i (@{$macros{$name}})
	{ my $thisfile = $files[$mdef_fileno[$i]];
	  # print "for macro $name, $thisfile\n";
	  if (!exists($files{$thisfile}))
	    { $files{$thisfile} = $true;
	      for my $includer (keys %{$file_includers{$thisfile}})
		# No worklist: file_included_by is transitively closed
		{ $files{$includer} = $true; } } }
      if ($debug_dependences)
	{ print "macro $name: transitive files ", (keys %files), "\n"; }
      for my $thisfile (keys %files)
	{ if ($debug_dependences)
	    { print "file_direct_inclusion_dependent_macros{$thisfile} = @{$file_direct_inclusion_dependent_macros{$thisfile}}\n";
	      print "file_inclusion_dependent_macros{$thisfile} = @{$file_inclusion_dependent_macros{$thisfile}}\n"; }
	  for my $fdep (@{$file_inclusion_dependent_macros{$thisfile}})
	    { if ($debug_dependences)
		{ print "adding dependence $name $fdep due to $thisfile\n"; }
	      add_inclusion_dependence($name, $fdep); } } }

  transitive_closure_dependences();

  %macro_inclusion_dependenton = %local_inclusion_dependenton;
  %macro_inclusion_dependees = %local_inclusion_dependees;
  %macro_expansion_dependenton = %local_expansion_dependenton;
  %macro_expansion_dependees = %local_expansion_dependees;

  if ($opt_v)
    { print STDERR "Computing transitive macro dependences...done\n"; }
}

## Now taken care of in compute_transitive_file_dependences, I think.
# sub apply_file_dependences_to_macros ( )
# { check_args(0, @_);
# 
#   # Add file_includees and file_includers to macro info.
# 
# 
#    for my $file (@files)
#      { $file_direct_inclusion_dependenton{$file}
#        = reduce_dependentons($file_direct_inclusion_dependentons{$file});
# 
#        # It's a bit inexact to have just one set of dependences for the
#        # entire file (instead of noting different inclusions from different
#        # including files have different dependences), but this is probably
#        # good enough.
# 
#        for my $depon (@{$file_direct_inclusion_dependentons})
#  	{
#  	  # direct inclusion dependences are mdef_direct_inclusion_dependenton
#  	  for my $incl_dep (@{$depon})
#  	    { for my $word (macros_in($incl_dep))
#  		{ add_inclusion_dependence($name, $word); } }
#  	  ## This version depends on mdef_direct_expansion_uses; compute the
#  	  ## same info myself so needn't wait until after pass 2.
#  	  # # direct expansion dependences are mdef_direct_expansion_uses
#  	  # for my $exp_dep (@{$mdef_direct_expansion_uses[$this_file_index]})
#  	  #  { add_expansion_dependence($name, $exp_dep); }
#  	  for my $exp_dep (files_appearing_in($mdef_body_simple[$index]))
#  	    { add_expansion_dependence($name, $exp_dep); } } }
# }


###########################################################################
### Miscellaneous?  (Greg, where do these belong?  Surely not here...)
###

# Return a sorted version of the list
# passed in, with duplicates removed
sub UniquifyAndSortList ( @ ) {
  my (@list) = check_args_at_least(0, @_);
  if (!wantarray) {
    croak "UniquifyAndSortList should return to an array context.";
  }
  my %seen = ();
  foreach (@list) {
    $seen{$_} = $true;
  }
  return sort (keys %seen);
}

# Returns a list of the categories for the various definitions
# of the macro with a given name
sub CategoriesForMacroName ( $ ) {
  my ($name) = check_args(1,@_);
  my @list = ();
  for (my $iDef = 0; $iDef <= $#{$macros{$name}}; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    mdie() if !defined($macros{$name});
    mdie() if !defined($macros{$name}[$iDef]);
    mdie() if !defined($mdef_category[$index]);
    push @list, $categoryname[$mdef_category[$index]];
  }
  #print STDERR "CFMN\n";
  return UniquifyAndSortList(@list);
}

# Returns a list of the inclusion methods of the various
# files in which the macro with a given name is defined
sub InclusionMethodsForMacroName ( $ ) {
  my ($name) = check_args(1,@_);
  my @list = ();
  for (my $iDef = 0 ; $iDef <= $#{$macros{$name}}; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    mdie() if !defined($macros{$name});
    mdie() if !defined($macros{$name}[$iDef]);
    mdie() if !defined($mdef_fileno[$index]);
    mdie() if !defined($files[$mdef_fileno[$index]]);
    my $fileno = $mdef_fileno[$index];
    my $filename = $files[$fileno];
    mdie("$filename has no inclusion method") if !defined($file_inclusion_method[$fileno]);
    push @list, $file_inclusion_method[$filename];
  }
  #print STDERR "IMFMN\n";
  return UniquifyAndSortList(@list);
}


###########################################################################
### Read lines
###

use vars '$current_raw_fulltoken_line';	# not "my" because dynamically bound
$current_raw_fulltoken_line = "";

# Shouldn't be in a character constant across lines.
# my $incharconst = $false;
use vars '$commaop';		# not "my" because dynamically bound
$commaop = $true;		# whether commas should be operators or not
				# (they shouldn't in arglists, initializers)


# Wrapper for get_fulltoken_cline: read next line from <INPUT>, until no
#   continuation char and not in string or comment.
# Returns the simplified line.  Maybe should also return info about ncnb,
#   etc.; currently global variables are set in this function, which seems
#   fine.
# 
# Constructing simplified values are a bit wasteful on the first pass, when we
# only care about macro definitions; special-case that?
sub get_fulltoken_line (;$)
{ my ($continuation) = check_args_range(0, 1, @_);
  if (!defined($continuation))
    { $continuation = $false; }

  if ($debug_getline)
    { print "Called get_fulltoken_line; cline_simplify = $cline_simplify_strings\n"; }

  my ($raw_result, $simple_result, $phys_lines, $ncnb_lines, $warnings)
    = get_fulltoken_cline(\*INPUT);
  for my $warning (@{$warnings})
    { evilprint($warning); }

  # don't check $simple_result, which might be simplified to "" (= false)
  if (not ($raw_result))
    { return $raw_result; }
  # This screws something up really badly.
  # if (not ($simple_result))
  #  { return $simple_result; }

  # Save the raw line for the convenience of error messages; don't return
  # it, for the convenience of callers.
  # ***** peekline will have to cope with this.
  if ($continuation)
    { $current_raw_fulltoken_line
	= append_lines($current_raw_fulltoken_line, $raw_result); }
  else
    { $current_raw_fulltoken_line = $raw_result; }

  if ($debug_getline)
    { print STDERR "in get_fulltoken_line $phys_lines, finding",
        ($finding_macro_defs ? " defs" : ""),
        ($finding_macro_uses ? " uses" : ""),
        ": <<$simple_result>><<$raw_result>>\n"; }

  {
    # First pass
    if ($finding_macro_defs) {
      $rg_physical_lines[$current_ftype_index] += $phys_lines;
      $rg_ncnb_lines[$current_ftype_index] += $ncnb_lines;
    }

    # Look for uses only on the second pass.
    if ($finding_macro_uses) {
      # and also only if -a is set or this is a project file
      # don't do it if -u is set (user want to ignore usage)
      if (!$opt_u && ($opt_a || !file_was_included($current_file_number))) {
	if (!defined($simple_result))
	  { mdie("How can $simple_result not be defined??"); }
	analyze_for_macro_use($simple_result);
	# print STDERR "analyze_for_macro_use returned from $simple_result";
      }
    }

    if (defined($simple_result) && ($simple_result =~ /^\s*\#/))
      { # Preprocessor line; usually just return "\n";
	if ($finding_macro_defs) {
	  $rg_cpp_phys_lines[$current_ftype_index] += $phys_lines;
	  $rg_cpp_phys_ncnb_lines[$current_ftype_index] += $ncnb_lines;
	}
	my $result = getline_handle_preprocessor_line($raw_result, $simple_result, $phys_lines, $ncnb_lines);
	if ($debug_getline)
	  { print "get_fulltoken_line returning (via getline_handle_preprocessor_line) <<$result>>\n"; }
	return $result;
      }
  }

  if (!defined($simple_result))
    {    $simple_result = " ";}
  elsif ($simple_result eq "")
    { mdie("empty get_fulltoken_line result '$simple_result'"); }
  if ($debug_getline)
    { print "get_fulltoken_line returning <<$simple_result>>\n";
      if ($simple_result eq "EXT char *sig_name[] = { SIG_NAME };\n")
	{ carp "here!\n"; } }

  return ($simple_result);
}

# Two arguments: token, line, line limit.
# Two result values: success, lines.
sub get_fulltoken_lines_to ( $$$ )
{ my ($regexp, $line, $limit) = check_args(3, @_);
  if ($line =~ /$regexp/)	# no /o
    { return($true, $line); }
  my $nextline;
  while (($limit > 0) && ($nextline = get_fulltoken_line($true)))
    { my $success = ($nextline =~ /$regexp/); # no /o
      $line = append_lines($line, $nextline);
      if ($success)
	{ return ($true, $line); } }
  parse_error("Didn't match regexp '$regexp' after $limit lines: $line");
  return($false, $line)
}


sub peek_fulltoken_line ( $ )
{
  my ($arg) = check_args(1, @_);
  my ($raw, $simple, $phys, $ncnb, $warnings) = peek_fulltoken_cline(\*INPUT, $arg);
  return($simple);
}


## FIX:  throttle these after a certain number of lines have been read.

# find_close_{paren,brace}_read is like find_close_{paren,brace}, but:
#  * return a second result, orginarily the argument string
#  * read lines to try to balance, in which case the second return value can
#    differ from the first input value, and the first result is never $false
# These were more efficient when integrated with find_close_{paren,brace}, but
# this version is more modular.

sub find_close_paren_read ($;$)
{ my ($exp, $pos) = check_args_range(1, 2, @_);
  if (!defined($pos))
    { $pos = 0; }
  if ($debug_getline)
    { print "find_close_paren_read $exp $pos\n"; }
  my $index = find_close_delimiter('(', $exp, $pos);
  while ($index eq $false)
    { my $nextline = get_fulltoken_line($true);
      $exp .= $nextline;
      $index = find_close_delimiter('(', $exp, $pos); }
  if ($debug_getline)
    { print "find_close_paren_read $exp returned $index in $exp\n"; }
  return ($index, $exp);
}

sub find_close_brace_read ($;$)
{ my ($exp, $pos) = check_args_range(1, 2, @_);
  if (!defined($pos))
    { $pos = 0; }
  if ($debug_getline)
    { print "find_close_paren_read $exp $pos\n"; }
  my $index = find_close_delimiter('{', $exp, $pos);
  while ($index eq $false)
    { my $nextline = get_fulltoken_line($true);
      # print "find_close_brace_read ($pos) adding '$nextline' to '$exp'.\n";
      $exp .= $nextline;
      $index = find_close_delimiter('{', $exp, $pos); }
  if ($debug_getline)
    { print "find_close_brace_read $exp returned $index in $exp\n"; }
  return ($index, $exp);
}


sub update_for_cond_comp_directive ( $$ ) {
  my ($cpp_cmd,$args) = check_args(2, @_);
  # args has no leading or trailing space

  my @words = ();

  # Note: macros_in can only be used on the second pass
#  if ($cpp_cmd eq "if" || $cpp_cmd eq "elif") {
#    @words = words_in(cline_simplify($args));
#  } else {
#    @words = ($args);
#  }
  @words = possible_macro_names_in(cline_simplify($args));
  my $ccdCategory;
  if (cpp_trivially_false_condition($args) ||
      cpp_trivially_true_condition($args)) {
    $ccdCategory = $ccatCOMMENTING;
  } else {
    if (scalar(@words) == 0) {
      if ($args =~ /^\s*'~'\s*==\s*'~'\s*$/) {
	# it's something like: #if '\n' == '\r'  (from gs/zfileio.c)
	# which is checking what character literals actually are
	$ccdCategory = $ccatPORT_LANLIB;
	goto CCD_DONE;
      }
      print STDERR "CCD_LEXICAL_CATEGORY: No words!\n  #$cpp_cmd, $args\n";
      return;
    }
    foreach my $word (@words) {
      my $curr_ccdCategory = ccd_lexical_category($word);
      if ($debug_ccd_categories) {
	print CCD_CATEG "$word in ",
	$cond_category_name[$curr_ccdCategory], "\n";
      }
      if (defined($ccdCategory) && $curr_ccdCategory != $ccdCategory) {
	if ($debug_ccd_categories) {
	  print CCD_CATEG "$word in mixed, now\n";
	}
	$ccdCategory = $ccatMIXED;
	last;
      }
      $ccdCategory = $curr_ccdCategory;
    }
    # Allow redef suppression to override a previous categorization
    if ($#words == 0 &&
	($cpp_cmd eq "ifndef" || $args =~ /\!\s*defined/)) {
      # now look at next two lines and see if this is an ccatREDEF_SUPPRESION
      my $simple = "";
      my $simple2 = "";
      my $iLinesPeeked = 1;
      my $word = $words[0];
      while ($simple = peek_fulltoken_line($iLinesPeeked++)) {
	last if ($simple !~ /^\s*$/);
      }
      if ($simple =~ /^\s*\#\s*define\s+$word/) { # no /o on regexp match
	while ($simple2 = peek_fulltoken_line($iLinesPeeked++)) {
	  last if ($simple2 !~ /^\s*$/);
	}
	if ($simple2 =~ /^\s*\#\s*endif/) {
	  $ccdCategory = $ccatREDEF_SUPPRESION;
	}
      }
      if ($debug_ccd_categories) {
	print CCD_CATEG "other -> $cond_category_name[$ccdCategory], from\n 1: $simple 2: $simple2\n";
      }
    }
  }
 CCD_DONE:
  $rg_ccd_cat_counts[$current_ftype_index][$ccdCategory]++;
}


sub ccd_lexical_category ( $ ) {
  my ($mname) = check_args(1, @_);

  my $orig_mname = $mname;
  $mname =~ s/^_*(.*?)_*$/$1/;  # Remove leading/trailing underscores

#  print STDERR "Trying '$mname'\n";

  if ($mname =~ /^.*(TRACE|DEBUG).*$/) {
    return $ccatDEBUG;
  }

  if (# Language implementation
      ($mname =~ /^(
__GNU[CG]__|BORLANDC|BUGGY_MSC|DECC|DECCXX|DJGPP|GNUC|GNU_LIBRARY|HAVE_GCC|
MSC|MSC_VER|MWERKS|PUREC|SC|THINK_C|TURBOC|Think_C|VAXC|WATCOMC|ZTC|applec
)$/x)
      # Language version (and bool)
      || ($mname =~ /^(lint|LINT|c_plusplus|cplusplus|LIBC|STDC|STANDARD_C|HAS_BOOL)$/)
      # Headers/prototypes
      || ($mname =~ /^(
STDC_HEADERS|KR_headers|(I_)?(STD|VAR)ARGS?|(NeedFunctionP|has_p)rototypes|
HaveProtos|PROTOTYPE|FUNCPROTO|(NO_)?PROTO|(HAVE|USE)_PROTO(TYPE)?S?
)$/x)) {
    return $ccatPORT_LANLIB;
  }
  if ($mname =~ /^(const|static|inline|volatile|signed|unsigned)$/) {
#    return $ccatPORT_LANMACRO;
    return $ccatPORT_LANLIB;  # This was too small a category, so merge in with above
  }
  if ($mname =~ /^(STACK_DIRECTION|STACK_GROWS_DOWNWARD|STACK_GROWTH_DOWN|
arch_.*|
X1[01](R[23456])?|
X(t|lib)SpecificationRelease|
BYTEORDER|
SIZEOF_.*|
BSD_(TYPES|TERMIOS|SETPGRP|PGRPS|GETPGRP)|
HAVE_.+|
SEVEN_?BIT|
NOSTDHDRS|SV_BSDSIG|
NON_UNIX_STDIO|NO_?(STDLIB|UNISTD|LIMITS)|
.+_MISSING|BROKEN_.+|NO_FCNTL|_POSIX_VERSION|READLINE_LIBRARY|
BSD_SIGNALS|(SYSV|BSD)_SIGNALS|POSIX_(SOURCE|SIGNALS|VERSION)|
ELF|COFF|.+_BUG|
(I_)?(MEMORY|STRING|UNISTD|NET_ERRNO|STDLIB|UTIME|NON_BLOCKING_IO|FCNTL|SYS_FILE|SYS_TIME(S|_KERNEL))|
HAS_[_A-Z0-9]+|has_[_a-z0-9]+|bad_(create0|unlink|fchmod)|__CHAR_UNSIGNED__)
$/x) {
    return $ccatPORT_FEATURE;
  }
  if ($mname =~ /^(
strr?chr|
errno|
SIG_?[0-9A-Z]{2,8}|
S_I(READ|WRITE|EXEC)|
S_I([RWX](USR|GRP|OTH(ER)?))|
S_I([RWX]UGO|READ|RWXU(SR)?|RWXG(RP)?|RWXO(T[HR])?)|
O_(CREAT|BINARY|(SH|EX)LOCK|EXCL|RDONLY|RDWR|APPEND|WRONLY|NONBLOCK|NDELAY)|
F_(TLOCK|TEST|SETOWN.*|SETFL|OK|LOCK|GETOWN|FREESP|DUPFD|CHSIZE)|
[ug]id_t|[FS](MPB|NWK|MPC|MT|SOCK|LNK|REG|BLK|DIR|CHR|F?IFO|[UG]ID|VTX|)|
TIOC[0-9A-Z]{1,9}|
r?index|(b|mem)(cmp|copy|zero|set|move)|
open2?|close|chdir|creat|NULL|malloc|
str(error|n?cpy|n?move)|
is(alnum|alpha|cntrl|digit|lower|letter|upper|space|punct|print|xdigit|blank|graph|ascii)|
to(upper|lower|ascii)|
Xt.*|Xm.*|Xlib.*|
(U?CHAR|LONG|INT|DOUBLE|FLOAT|SHORT)_(MAX|MIN)|
(MIN|MAX)(SHO?RT|INT|LONG|FLOAT|DOUBLE)|
(CHAR|SHO?RT|INT|LONG|PTR|DOUBLE|FLOAT)BITS|
E(PERM|NOENT|SRCH|INTR|IO|NXIO|2BIG|NOEXEC|BADE|BADF|BADMSG|BADR|CHILD|AGAIN|NOMEM|ACCES|FAULT|
  NOTBLK|CONN(ABORTED|REFUSED|RESET)|BUSY|EXIST|XDEV|NODEV|NOTDIR|ISDIR|ALIGN|ALREADY|INVAL|NFILE|
  NOTTY|TXTBSY|FBIG|NOSPC|SPIPE|ROFS|MLINK|PIPE|DOM|DUPPKG|(NET|HOST)(DOWN|UNREACH)|RANGE|DEADLK|
  NAMETOOLONG|NOLCK|NOSYS|NOTEMPTY|LOOP|WOULDBLOCK|DESTADDRREQ|NOMSG|IDRM|CHRNG|BFONT|NOSTR|NOLINK|
  REMOTE|NOTSOCK)|
FD?_(SET|GET|CLOSE|EXEC)|
XK_.*
)$/x) {
    return $ccatPORT_SYSMACRO;
  }

  #give MI_PREVENTION a rough go, see also below
  if ($mname =~ /_H_/) {
    return $ccatMI_PREVENTION;
  }

  $mname =~ tr/[A-Z]/[a-z]/;

  if ($mname =~ /^(systype_|M_)?
(hpux[4-9]|.*sun_fpa.*|32bit|386bsd|bsd[34][123456]|solaris2?(_[1234567])?|
 usl|sony|newsos[123456]|m_xenix|(ibm)?aix(v3|4|rt|370|3_2|_13|esa|pc)?|
 alliant(_2800|_1)?|alpha|i(80)?[234567]86|amiga(dos|_ac_5|_sc_6_1)?|
 apollo|atari(st)?|att(386|3b(1_perf)?|6300)|bfly1|bsd(i|4_[1234])?|butterfly|cadmus|
 clipper|convex|luna|utek|cray([12]|[xy]mp|_stack)?|systype_sysv|systype_bsd|orion|
 cx_ux|dgux|dosish|dos_nt|drs6000|gmicro|hp(2648|26|76|gl|300|9000(s[23456789]00)?|
 _?osf1?|pa|ux(_[156789])?)?|i370|i386|i860|i960|ibm(032|esa|r2|rt)?|interdata|
 iri[sx]_?[234567]d?(_[0-9])?(_LIBRARY)?|
 is68k|linux|luna88k|lynx|.*kbcs_target|m68(k|000)?|m88(k|000)|m_unix|
 mac_tcl|macintosh|macos|mach|v3x|maxport|mc[3576]000?|mc680[01234]0|mc68k(32)?|
 minix|mips(2|_sysv|eb|el|_bsd)?|motorola|ms_?dos|ms_?win(16|32|95|nt|3|3_?1)?|
 dos386|(dosx|(m_)?i|iapx)286|microport|multimax|netbsd|bsd386|newsos5|next|
 os2|osf(1|_alpha|_os)|pa_risc1_1|concurrent|ardent|titan|eunice|ps2|dmert|gcos|gcx|gould|
 hbullx20|hcx|paragon|pdp11|celerity|powerpc|pyr|qnx|risc6000|ksr1|n16|scs|sequent|sgi|
 sparc(v9)?|sun([234]|os(_ext)?)?|u3b([25]|20d|15)|sun386i?|sunos_?[45]|svr4(_[123])?|sysv3|
 sysv((3?86|68|88)|_ext)?|tandem|tek(4132|4300)|tops20|tower32|u370|
 ultrix([1-6][1-9])?|umaxv|unix(pc)?|usg?r?([345](_[234])?)?|vax(_vms)?|vms([1-9](_[1-9])?)?|
 vms_posix|(ms_?)?win(dows(nt|95)?|32|16)?|xenix(_2[23]|286)?|z8000|isc386
)(_SOURCE|_ARCH)?$/x) {
    return $ccatPORT_MACHINE;
  }

  if (substr($orig_mname,0,2) eq "__") {
    return $ccatMISC_SYSTEM;
  }

  # also ccatCOMMENTING, ccatMI_PREVENTION, ccatREDEF_SUPPRESION,
  # but these are not strictly based on name

  #give MI_PREVENTION a rough go, see also above
  if ($mname =~ /_h$/ || $orig_mname =~ m/(_H_|_?INCLUDED_?)/) {
    return $ccatMI_PREVENTION;
  }

  if ($mname eq "true" || $mname eq "false" || $mname eq "1" || $mname eq "0"
      || $mname eq "NOT_C_CODE") {
    return $ccatCOMMENTING;
  }

  return $ccatOTHER;
}

# Argument is a simplified line.
# Returns the line that should be the get_fulltoken_line result, usually "\n";
sub getline_handle_preprocessor_line ( $$$$ )
{
  my ($line, $line_noc, $phys_lines, $ncnb_lines) = check_args(4, @_);
  if ($debug_getline)
    { # $line ends with newline
      print "getline_handle_preprocessor_line: $line == $line_noc"; }
  if ($line_noc =~ /^\s*\#\s*$/)
    { # null preprocessor command; do nothing
      return "\n";
    }
  elsif ($line_noc =~ m/^\s*\#\s*($identifier_re)\s*/o)
    { # Found a real preprocessor command
      my $cpp_cmd = $1;
      $line_noc = $POSTMATCH;
      # Don't just look for $MATCH -- it may contain a trailing newline
      if ($line !~ s/^\s*\#\s*$cpp_cmd\s*//) # no /o
	{ mdie("Should have seen '$MATCH' in '$line' -- was at head of '$MATCH $line_noc'\n"); }
      $line = $POSTMATCH;
      $line_noc =~ s/^\s+//;	# remove leading whitespace
      $line_noc =~ s/\s+$//;	# remove trailing whitespace
      return getline_handle_preprocessor_command($cpp_cmd, $line, $line_noc, $phys_lines, $ncnb_lines); }
  elsif ($line =~ m/^\s*\#\s*\d+\s*\".*\"\s*$/)
    { #FIX: should we count these
      evilprint("File might be preprocessor's output--line marker found at $current_file_name:" . current_line_no() . "\n");
      return "\n"; }
  else
    { evilprint("Strange preprocessor line |$line|\n");
      return "\n"; }
}


# This is a catchall for everything that has to be done to a preprocessor line.
# It's a bit gross to do it this way, but it seems most expedient.
# Always do:
#  * set @current_inclusion_dependenton
# Sometimes do:
#  * if $finding_macro_defs, then in first pass:
#      * for each use of the preprocessor, set $cppcmdcount
#      * for each #define, call process_macro_definition
#  * if $finding_macro_uses, then in second pass:
#      * at present, do no extra work
#  * if $merge_cpp_ if_branches, then try to merge #if ... #else ... #endif
#
# Returns the line that should be the get_fulltoken_line result, usually "\n";
sub getline_handle_preprocessor_command ( $$$$$ )
{
  # $cpp_cmd and $cpp_cmd_arg contain no leading or trailing space.
  my ($cpp_cmd, $cpp_cmd_arg, $cpp_cmd_arg_noc, $phys_lines, $ncnb_lines) = check_args(5, @_);

  if ($debug_getline)
    { print "getline_handle_preprocessor_command (", scalar(@current_inclusion_dependenton), "): $cpp_cmd $cpp_cmd_arg == $cpp_cmd_arg_noc\n"; }

  if ($finding_macro_defs) {
    # handle @rg_cpp_cmds and @%rg_cppcmdcounts
    update_cpp_directive_counts($cpp_cmd);
    if (($cpp_cmd eq "ifdef") || ($cpp_cmd eq "ifndef") || ($cpp_cmd eq "undef"))
      { if ($cpp_cmd_arg_noc =~ /^($identifier_re)\s*\([a-zA-Z, \t]*\)$/)
	  { evilprint("Shouldn't supply macro arguments to \#$cpp_cmd $cpp_cmd_arg_noc\n");
	    $cpp_cmd_arg_noc = $1; }
	if ($cpp_cmd_arg_noc =~ /\s/)
	  { evilprint("Shouldn't see whitespace in \#$cpp_cmd $cpp_cmd_arg_noc\n");
	    $cpp_cmd_arg_noc = $PREMATCH; }
	if ($cpp_cmd_arg_noc !~ /^$identifier_re$/o)
	  { evilprint("argument should be a symbol: \#$cpp_cmd $cpp_cmd_arg\n");
	    # This happens in Emacs somewhere for an #undef, I think.
	    if ($cpp_cmd_arg_noc !~ /^($identifier_re)\(/o)
	      { $cpp_cmd_arg_noc = $1; } }
	add_macro_used_by_cpp($cpp_cmd_arg_noc); }
    elsif (($cpp_cmd eq "if") || ($cpp_cmd eq "elif"))
      {
	# Call to cline_simplify is to get rid of character constants
	for my $word (possible_macro_names_in(cline_simplify($cpp_cmd_arg_noc)))
	  { add_macro_used_by_cpp($word); } }
  }


  if (!$finding_macro_defs) { # only on second pass
    if ($cpp_cmd eq "ifdef" || $cpp_cmd eq "ifndef" ||
	$cpp_cmd eq "if" || $cpp_cmd eq "elif" &&
	!cpp_trivially_false_condition($cpp_cmd_arg_noc)) {
      # get the category of this #if using some heuristics & regexps
      my $ccCategory = update_for_cond_comp_directive($cpp_cmd,$cpp_cmd_arg_noc);
    }
  }

  if ($cpp_cmd eq "if")
    { if (cpp_trivially_false_condition($cpp_cmd_arg_noc))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $ncnb_lines; }
	  my $cond = discard_to_endif_or_else();
	  if ($debug_getline)
	    { print "discard_to_endif_or_else returned '$cond'"; }
	  if ($cond)
	    { # What are the right fourth and fifth arguments here?
	      return getline_handle_preprocessor_command("if", $cond, $cond, $phys_lines, $ncnb_lines); } }
      else
	# Not trivially false #if.  (If trivially true, do the usual thing here.)
	{ push(@current_inclusion_dependenton, $cpp_cmd_arg_noc);
	  # print "if ", current_line_no(), " $cpp_cmd_arg; now dependent on @current_inclusion_dependenton\n";
	  if ($merge_cpp_if_branches
	      && !cpp_trivially_true_condition($cpp_cmd_arg_noc))
	    { my $merged = cpp_merged_branches();
	      if (defined($merged))
		{ return $merged; } }
	} }
  elsif ($cpp_cmd eq "ifdef")
    { push(@current_inclusion_dependenton, "defined($cpp_cmd_arg_noc)");
      # print "ifdef ", current_line_no(), " $cpp_cmd_arg; now dependent on @current_inclusion_dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifndef")
    { push(@current_inclusion_dependenton, "!defined($cpp_cmd_arg_noc)");
      # print "ifndef ", current_line_no(), " $cpp_cmd_arg; now dependent on @current_inclusion_dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "endif")
    { if (@current_inclusion_dependenton == 0)
	{ evilprint("extra \#endif\n");
	  return "\n"; }
      # print "endif ", current_line_no(), " $current_inclusion_dependenton[$#current_inclusion_dependenton]; ";
      my $last = pop(@current_inclusion_dependenton);
      if (cpp_trivially_false_condition($last)
	  # I think this test is never necessary.
	  || cpp_trivially_true_condition($last))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $ncnb_lines; } }
      # print "now dependent on @current_inclusion_dependenton.\n";
    }
  elsif ($cpp_cmd eq "else")
    { if (@current_inclusion_dependenton == 0)
	{ evilprint("improperly nested \#else\n");
	  return "\n"; }
      my $last = pop(@current_inclusion_dependenton);
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": #else testing '$last' for triviality: ", cpp_trivially_true_condition($last), "\n"; }
      if (cpp_trivially_true_condition($last))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $ncnb_lines; }
	  discard_to_endif(); }
      else
	# Not trivially true condition
	{ push(@current_inclusion_dependenton, negate_cpp_if_condition($last)); } }
  elsif ($cpp_cmd eq "elif")
    { if (@current_inclusion_dependenton == 0)
	{ evilprint("improperly nested \#elif\n");
	  return "\n"; }
      my $last = pop(@current_inclusion_dependenton);
      if (cpp_trivially_true_condition($last))
	{ discard_to_endif(); }
      else
	# Not trivially true condition
	{ push(@current_inclusion_dependenton,
	       "(" . negate_cpp_if_condition($last) . ") && $cpp_cmd_arg_noc");
	} }
  elsif ($cpp_cmd eq "define")
    { if ($finding_macro_defs)
	{ process_macro_definition($cpp_cmd_arg, $cpp_cmd_arg_noc, $phys_lines, $ncnb_lines); }
    }
  elsif ($cpp_cmd eq "include")
    {
      # Only want to handle #include directives on the pass
      # where we're looking for macro definitions--
      # when we're finding_macro_uses, #include "ctype.h" becomes
      # #include "" in updateinvars, so we can't do it there again, anyway
      if ($finding_macro_defs && !$fIgnoreIncludes) {
	# print "Got include '$cpp_cmd_arg_noc'\n";

	cpp_handle_include($cpp_cmd_arg, $cpp_cmd_arg_noc);
      }
    }
  elsif ($cpp_cmd eq "undef")
    { process_macro_undefinition($cpp_cmd_arg, $cpp_cmd_arg_noc)
    }
  else
    { # Some other cpp command
      # print "unhandled cpp command \#$cpp_cmd $cpp_cmd_arg\n";
    }
  return "\n";
}

sub cpp_handle_include ( $$ )
{
  my ($unsimple_arg, $include_arg) = check_args(2, @_);

  # # For now, hack for gnuchess-4.0.pl77/src/binsort.c
  # if ($include_arg =~ /^(errno|std(io|lib)|time)$/)
  #   { $include_arg = "<$include_arg.h>"; }

  if ($include_arg !~ /^$cpp_include_arg_re$/ &&
      (!defined($macros{$include_arg}) ||
       # index -1 means "last element of array"
       !defined($mdef_body[$macros{$include_arg}[-1]]) ||
       # can't use simplified body, as strings have been simplified away in it
       cline_remove_comments($mdef_body[$macros{$include_arg}[-1]]) !~ /^$cpp_include_arg_re$/)) {
    # Didn't match "foo.h" or <bar.h>, or a macro whose last definition
    # expands to something in quotes or brockets
    parse_error("Bad argument to #include: $unsimple_arg\n");
      # Just fall through if one of the OK-to-ignore includes
    } else {
      my $angled_include;
      my $include_file;
      if (defined($1)) {
	$angled_include = $true;
	$include_file = $1;
      } else {
	$angled_include = $false;
	$include_file = $2;
      }
      my ($fLocallyIncluded,$complete_include_filename) =
	complete_include_pathname($include_file, $angled_include, $current_file_name);
      if (!defined($complete_include_filename))
	{ # FIX:  make complete_include_pathname work when $angled_include
	  # is false, and then restore this (and eliminate the "else"...)
	  parse_error("Can't resolve include file $include_file");
	} else {

	  { my $curr_incl_dep = [ @current_inclusion_dependenton ];
	    if (defined($macros{$include_arg}))
	      { push(@{$curr_incl_dep}, $include_arg); }
	    push(@{$file_direct_inclusion_dependentons{$complete_include_filename}},
		 simplify_dependenton($curr_incl_dep)); }
	  push(@{$file_included_by{$complete_include_filename}}, $current_file_name);

	  # Check to see if we're already reading this file anyway
	  # if we resolved the filename to a real file,
	  # and we've not already added the file to our list we need to parse
	  if ($fLocallyIncluded == $false &&
	      # scalar(grep($_ eq $complete_include_filename, @files_included)) == 0)
	      !exists($file_numbers{$complete_include_filename})) {
	    # FIX: may want to insert this where we are
	    # or do some sort of recursive reading of *all* included files
	    # WEIRD: Why does this cause a problem in parsing a macro argument
	    #      when I use @files instead of @files_included
	    push @files_included, $complete_include_filename;
	    add_file($complete_include_filename,
		     "FromInclude" . ($angled_include ? "<>" : '""'));
	    #DBG print STDERR "Adding \"$complete_include_filename\" as $file_inclusion_method[$#files]\n";
	  }
	}
    }
}

sub add_macro_used_by_cpp ( $ )
{
  my ($word) = check_args(1, @_);
  if (($word ne "defined") && ($word !~ /^[0-9]+$/))
    { # First, two debugging tests
      if (!$word)
	{ croak "Empty word"; }
      if ($word !~ /^$identifier_re$/o)
	{ if ($word =~ /^$number_literal_re$/o)
	    { return }  # for stuff like #if BYTEORDER > 0x4321
	  warn "non-identifier word $word"; # FIXMERNST
	  # stuff like "#undef ADDR_CORRECT(x) in emacs-19.34/src/m/gec63.h"
	  $word =~ s/\(.*//; # remove suffix of argument list with parens
	  # this should be a macro lint, since it's improper use of #undef
	}
      if ($debug_dependences && !defined($macros_used_by_cpp{$word}))
	{ # No newline; $cpp_cmd_arg already has one
	  print "Adding macro $word due to $current_file_name:", current_line_no(), "\n"; }
      # More efficient to set to $true, but this can be helpful for debugging.
      $macros_used_by_cpp{$word} = $current_file_number . ":" . current_line_no(); }
}


# Read and discard lines until we find the matching #endif
# No return value.
sub discard_to_endif ( )
{
  check_args(0, @_);
  my $if0depth = 1;
  my $line;
  while ($if0depth > 0)
    # Don't use get_spliced_cline(); the getline lookahead cache might not be empty.
    { my ($raw_line, $simple_line, $phys, $ncnb, $warnings)
	= get_spliced_cline_maybe_ungot(\*INPUT, $true);
      for my $warning (@{$warnings})
	{ evilprint($warning); }
      if (not $raw_line)
	{ evilprint("File ends in \#if 0\n");
	  return; }
      cline_resetinvars();		# Abandon changes by get_spliced_cline
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": discarding (to endif @current_inclusion_dependenton) $raw_line"; }
      # I'll trust that no comment or string contains anything that looks
      # like a preprocessor command.  Strictly speaking, I should use
      # get_fulltoken_line and/or updateinvars, because anything in an
      # #if is supposed to be a sequence of valid tokens, but #if 0
      # often contains non-syntactic constructs.  (Maybe eventually use
      # get_fulltoken_line/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($simple_line =~ m/^\s*\#\s*if(n?def)?\b/o)
	{ $if0depth++; }
      elsif ($simple_line =~ m/^\s*\#\s*endif\b/o)
	{ $if0depth--; } }
  return;
}

# If #endif, return $false.
# If #else or #elseif, return a fake #if condition for re-processing.
sub discard_to_endif_or_else ( )
{
  check_args(0, @_);
  my $if0depth = 1;
  while ($if0depth > 0)
    # Don't use get_spliced_cline(); the getline lookahead cache might not be empty.
    { my ($raw_line, $simple_line, $phys, $ncnb, $warnings)
	= get_spliced_cline_maybe_ungot(\*INPUT, $true);
      for my $warning (@{$warnings})
	{ evilprint($warning); }
      if (not $raw_line)
	{ evilprint("File ends in \#if 0\n");
	  return $false; }
      cline_resetinvars();		# Abandon changes by get_spliced_cline
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": discarding (to endif or else; inclusion_dependenton @current_inclusion_dependenton) $raw_line"; }
      # I'll trust that no comment or string contains anything that looks
      # like a preprocessor command.  Strictly speaking, I should use
      # get_fulltoken_line and/or updateinvars, because anything in an
      # #if is supposed to be a sequence of valid tokens, but #if 0
      # often contains non-syntactic constructs.  (Maybe eventually use
      # get_fulltoken_line/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($simple_line =~ m/^\s*\#\s*if(n?def)?\b/o)
	{ $if0depth++; }
      elsif (($if0depth == 1) && ($simple_line =~ m/^\s*\#\s*else\b/))
	{ if ($debug_cpp_if_comments)
	    { print input_file_and_line(), ": returning !0 from discard_to_endif_or_else (inclusion_dependenton @current_inclusion_dependenton)\n"; }
	  return "!0"; }
      elsif (($if0depth == 1) && ($simple_line =~ m/^\s*\#\s*elif\s+/))
	{ my $cond = $POSTMATCH;
	  $cond =~ s/\s+$//;
	  if ($debug_cpp_if_comments)
	    { print input_file_and_line(), ": returning $cond from discard_to_endif_or_else (inclusion_dependenton @current_inclusion_dependenton)\n"; }
	  return $cond; }
      elsif ($simple_line =~ m/^\s*\#\s*endif\b/o)
	{ $if0depth--; } }
  return $false;
}

# This handles
#     #if...
#     #elsif ...
#     #else
#     #if...
#     #endif
#     #endif
# and returns, instead, a single merged string when possible.
# It does not handle other types of nesting, such as
#     #if...
#     #if...
#     #else
#     #endif
#     #if
#     #else
#     #endif
#     #endif
# should it be able to do the latter?


# Returns the sum of all the previous sizes (including the final #endif)
# and a list of the parts.
# First return value is undefined if failure (?).
sub cpp_merge_candidates ( $ )
{
  # sum of all previous sizes; 0 on initial call.
  my ($prev_sizes) = check_args(1, @_);
  if ($debug_merge_branches) { print "cpp_merge_candidates @current_inclusion_dependenton\n"; }

  my @parts = ();

  my $size_limit = 10;
  my $num_endifs = 0;		# number of extra #endif commands
  my $next_line;

  # This should be a loop rather than a goto.
THENPART:
  # At this point we are already past the initial #if
  $next_line = peek_fulltoken_line($prev_sizes+1);
  if (!defined($next_line)) {
    return;
  }
  if ($debug_peek)
    { my $peeked_at = $prev_sizes+1;
      print "Just peeked at $peeked_at (ungot " . cline_ungot_size() . "): $next_line";
      print cline_ungot_string();
    }
  if ($next_line =~ /^\s*\#\s*if(n?def)?\b/)
    { if ($debug_merge_branches)
	{ print "cpp_merge_candidates making recursive call from then\n"; }
      my @sub_parts;
      ($prev_sizes, @sub_parts) = cpp_merge_candidates($prev_sizes+1);
      if ($debug_merge_branches)
	{ print "cpp_merge_candidates recursive call from then "
	    . (defined($prev_sizes) ? "succeeded:  " : "failed\n");
	  if (defined($prev_sizes))
	    { print join(" >>", @sub_parts); } }
      if (!defined($prev_sizes))
	{ return; }
      $next_line = peek_fulltoken_line($prev_sizes+1);
      if (!defined($next_line)) {
	return;
      }
      if ($next_line !~ /^\s*\#\s*els(e|if)\b/)
	{ return; }
      $prev_sizes++;
      # Would push have worked equally well here?
      @parts = (@parts, @sub_parts);
    }
  else
    { my $then_clause;
      if ($debug_peek)
	{ print "not if at head of then clause; peek $prev_sizes, ungot " . cline_ungot_size() . "\n";
	  print cline_ungot_string(); }
      ($then_clause, $prev_sizes) = peek_to_cpp_command('els(e|if)', $prev_sizes, $size_limit);
      if (!defined($then_clause))
	{ return; }
      push(@parts, $then_clause);
      $next_line = peek_fulltoken_line($prev_sizes); # not $prev_sizes+1
      if (!defined($next_line)) {
	return;
      }
    }

  if ($debug_merge_branches) { print "cpp_merge_branches: thenpart $parts[$#parts]"; }
  if ($next_line =~ /^\s*\#\s*elsif/)
    { goto THENPART; }
  if ($next_line !~ /^\s*\#\s*else/)
    { $next_line =~ s/\n$//;	# remove newline so we get better die output
      # Unconditional print, because we are about to die.
      print cline_ungot_string();
      mdie("Just saw else or elsif (peekahead $prev_sizes): $next_line"); }

ELSEPART:
  $next_line = peek_fulltoken_line($prev_sizes+1);
  if (!defined($next_line)) {
    return;
  }
  if ($next_line =~ /^\s*\#\s*if(n?def)?\b/)
    # This was else ... if; treat it like elsif and go back to then part
    { if ($debug_merge_branches)
	{ print "cpp_merge_candidates making recursive call from else\n"; }
      my ($sub_prev_sizes, @sub_parts) = cpp_merge_candidates($prev_sizes+1);
      if ($debug_merge_branches)
	{ print "cpp_merge_candidates recursive call from else "
	    . (defined($sub_prev_sizes) ? "succeeded\n" : "failed\n"); }
      if (!defined($sub_prev_sizes))
	{ return; }
      $next_line = peek_fulltoken_line($sub_prev_sizes+1);
      if (!defined($next_line)) {
	return;
      }
      if ($next_line !~ /^\s*\#\s*endif\b/)
	{ return; }
      $prev_sizes = $sub_prev_sizes+1;
      # Would push have worked equally well here?
      @parts = (@parts, @sub_parts);
    }
  else
    { my $else_clause;
      ($else_clause, $prev_sizes) = peek_to_cpp_command('endif', $prev_sizes, $size_limit);
      if (!defined($else_clause))
	{ return; }
      push(@parts, $else_clause);
      $next_line = peek_fulltoken_line($prev_sizes); # not prev_sizes+1
      if (!defined($next_line)) {
	return;
      }
    }
  if ($debug_merge_branches) { print "cpp_merge_branches: elsepart $parts[$#parts]"; }
  if ($next_line !~ /^\s*\#\s*endif/)
    { mdie("Just saw endif: $next_line"); }

  # @parts holds the desired values; maybe merge them.
  return ($prev_sizes, @parts);
}

# If the next cpp command after $peekahead lines from here matches
# $cpp_cmd_re and is within $size_limit lines of here, then return the
# the peekahead of the matching command, plus all the text between.
# Otherwise return the undefined value.
sub peek_to_cpp_command ( $$$ )
{ my ($cpp_cmd_re, $peekahead, $size_limit) = check_args(3, @_);
  if ($debug_peek)
    { print "entering peek_to_cpp_command(peekahead = $peekahead; ungot " . cline_ungot_size() . "): $cpp_cmd_re\n";
      print cline_ungot_string(); }
  my $this_result = "";
  my $this_size = 0;
  my $next_line = peek_fulltoken_line($peekahead+1);
  while (defined($next_line) && ($next_line !~ /^\s*\#\s*$cpp_cmd_re\b/)) # no /o
    { if ($debug_peek)
	{ print "didn't find $cpp_cmd_re, offset $this_size: $next_line"; }
      if (($this_size > $size_limit) || ($next_line =~ /^\s*\#/))
	{ return; }
      # was $this_result .= $next_line;
      $this_result = append_lines($this_result, $next_line);
      $this_size++;
      $next_line = peek_fulltoken_line($peekahead+$this_size+1); }
  $peekahead += $this_size+1;
  if ($debug_peek)
    { print "peek_to_cpp_command returning (peek = $peekahead; " . cline_ungot_size() . " ungot lines) <<$this_result>>\n";
      print cline_ungot_string(); }
  return ($this_result, $peekahead);
}



# Returns a merged string.
# Returns the undefined value if
#  * cpp commands are too far separated
#  * series of cpp commands not one of those handled
#  * parts are different, not brace-unbalanced, or differently brace-unbalanced
# We have already read a #if line, which is reflected in @current_inclusion_dependenton.
# @current_inclusion_dependenton will be magically updated by a series of calls to
# get_fulltoken_line, if this function is successful.


sub cpp_merged_branches ( )
{
  check_args(0, @_);
  if ($debug_merge_branches) { print "cpp_merged_branches @current_inclusion_dependenton\n"; }

  # $parts_size = sum of sizes of all parts (and preprocessor glue like "#else")
  my ($parts_size, @parts) = cpp_merge_candidates(0);
  #   if (peek_fulltoken_line($parts_size+1) !~ /^\s*\#\s*endif/)
  #     { mdie("Should have seen an endif: ",  peek_fulltoken_line($parts_size+1)); }
  #   $parts_size++;		# account for the final #endif

  if ((!defined($parts_size)) || ($parts_size < 2))
    { return; }

  # Variable @parts holds the desired values; merge them if possible.

  # Check whether all the parts are the same (modulo whitespace, maybe)
  # This can happen because of string simplification.
  { my $first_part = $parts[0];
    if ($cline_simplify_strings) { $first_part =~ s/\s+/ /; }
    my $all_same = $true;
    my $index = 1;
    while ($all_same && ($index <= $#parts))
      { my $other_part = $parts[$index];
	if ($cline_simplify_strings) { $other_part =~ s/\s+/ /; }
	$all_same = ($first_part eq $other_part);
	$index++; }
    if ($all_same)
      { # [I'm now a bit confused by this.  I think it's the right thing,
	#  but why doesn't it try to reprocess all the preprocessor cmds?
	#  I guess it does but there's no possibility of merging, or
	#  something.  Think about and document this.  Should I unset
	#  $merge_cpp_if_branches?  Try it and see what happens...
	local $merge_cpp_if_branches = $false;
	for my $i (1..$parts_size)
	  { # put it in a variable for the convenience of the print below
	    my $discarded = get_fulltoken_line();
	    # print "discarding $discarded";
	  }
	if ($debug_merge_branches) { print "returning one of ", scalar(@parts), " identical parts: <<$first_part>>"; }
	if (not($first_part))
	  { return "\n"; }
	else
	  { return $first_part; } } }

  # Check whether the parts are all equally brace_unbalanced.
  # (If none are brace_unbalanced, no need to merge.)
  { my $firstbrace_change = brace_change($parts[0]);
    if ($firstbrace_change ne "")
      { my $all_same = $true;
	{ my $index = 1;
	  while ($all_same && ($index <= $#parts))
	    { $all_same = ($firstbrace_change eq brace_change($parts[$index]));
	      $index++; } }
	if ($all_same)
	  { for my $i (1..$parts_size)
	      { # put it in a variable for the convenience of the print below
		my $discarded = get_fulltoken_line();
		# print "discarding $discarded";
	      }
	    if ($debug_merge_branches) { print "merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n"; }
	    return merge_brace_unbalanced_lines($firstbrace_change, @parts); } } }

  # None of them are brace-unbalanced.  Check another special case:  multiple
  # declarations at the front of a function body.

  { # print "peeking for function body at ", peek_fulltoken_line($parts_size+1), "\n";
    my $ln = peek_fulltoken_line($parts_size+1);
    if (!defined($ln)) {
      return;
    }
    if ($ln =~ /^\s*\{/)
      { # print "found an open brace\n";
	if ($parts[0] =~ /^\s*$type_declarator_re\s*\(/o)
	  { my $rettype = $1;
	    my $fname = $2;	# actually a declarator
	    # print "found a function declarator '$rettype' '$fname'(\n";
	    if ($fname =~ /^$identifier_re$/o)
	      { my $index = 1;
		while ($fname && ($index <= $#parts))
		  # This test is a hack.
		  # Ought not insist that return type be identical, maybe?
		  # Ought not insist on identical spacing in rettype.
		  { if ($parts[$index] !~ /^\s*$rettype\s*$fname\s*\(/)	# no /o
		      { # print "part $index didn't match: $parts[$index]\n";
			$fname = $false; }
		    $index++; }
		if ($fname)
		  # FIX: This is a hack, done for expediency.
		  { # print "Arbitrarily returning first of ", scalar(@parts), " function definition headers for $fname\n";
		    # print " >>", join(" >>", @parts);
		    for my $i (1..$parts_size)
		      { # put it in a variable for the convenience of the print below
			my $discarded = get_fulltoken_line();
			# print "discarding $discarded";
		      }
		    my $next_line = peek_fulltoken_line(1);
		    if ((!defined($next_line)) || ($next_line !~ /^\s*\{/))
		      { mdie("Must have seen an open brace following brances: ", peek_fulltoken_line(1)); }
		    return($parts[0]); } } } } }

  if ($debug_merge_branches) { print "cpp_merged_branches: no sense merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n"; }

  return;
 }


# All of the lines are identically brace-unbalanced
sub merge_brace_unbalanced_lines ( $@ )
{ my ($braces, @lines) = check_args_at_least(3, @_);

  my $pieces = length($braces)+1;

  my @split_lines = ();
  for my $i (0..$#lines)
    { my @this_pieces = split(/[\{\}]/, $lines[$i]);
      if ($pieces != @this_pieces)
	{ mdie("should have $pieces, not ", scalar(@this_pieces), ", pieces: $lines[$i]"); }

      @{$split_lines[$i]} = @this_pieces;
      # # Does this work?  Don't risk it...
      # # $split_lines[$i] = @this_pieces;
      ## Old version, replaced by the above
      # for my $piece (0..$#this_pieces)
      #   { $split_lines[$i][$piece] = $this_pieces[$piece]; }
    }

  my $result = "";
  for my $piece (0..$pieces-1)
    { for my $i (0..$#lines)
	{ if (!defined($split_lines[$i][$piece]))
	    { for my $p (0..$pieces)
		{ for my $i (0..$#lines)
		    { print "$p $i <<$split_lines[$i][$p]>>\n"; } }
	      mdie("piece $piece, index $i not defined"); }
	  $result = append_lines($result, $split_lines[$i][$piece]); }
      if ($piece != $pieces)
	{ $result .= substr($braces, $piece, $piece+1); } }
  $result;
}



sub is_cpp_command ( $ )
{ my ($line) = check_args(1, @_);
  return ($line =~ /^\s*\#/);
}

## According to the Perl FAQ, this is fastest for small strings, but for
## big ones or worst cases, it's quite slow.
## In any event, it isn't used right now.
# # Watch out: this removes the trailing newline.
# sub trim_whitespace ($)
# {
#   my ($result) = check_args(1, @_);
#   $result =~ s/^\s+//;
#   $result =~ s/\s+$//;
#   # if ($result =~ /^\s+(.*)$/) { $result = $1; }
#   # # (.*)\s+ only gets rid of last space
#   # if ($result =~ /^(.*[^\s])\s+$/) { $result = $1; }
#   return $result;
# }

# This pretties things up but changes contents of line-spanning strings,
# so don't call it if ARG1 ends inside a string.
# NOTE: this sub is also in cline.pm
sub append_lines ( $$ )
{
  my ($arg1, $arg2) = check_args(2, @_);
  $arg1 =~ s/[ \t\n]+$//;
  $arg2 =~ s/^[ \t\n]+//;
  # insert a space so that the two lines don't just run together
  # (above regexps are a lot faster (3x) than using [ \t\n]*)
  return ($arg1 . "  " . $arg2);
}

# Return an array of three elements: name, args, def.
# None have leading or trailing whitespace
sub macrosplit ( $ )
{ my ($line) = check_args(1, @_);
  # print "macrosplit $line\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($line =~ m/^($identifier_re)(\([^\)]*\))?\s*(.*?)\s*$/o);
  if (scalar(@result) != 3)
    { mdie("Problem parsing macro `$line'"); }
  @result;
}


###########################################################################
### Parse expressions
###

# This is currently called when categorizing macro bodies; will also be
# used to parse function calls and macro arguments, to determine what is
# passed to the macro and what context the macro is being called in.

# I'm not completely clear on when types should be ignored and when not.
# Quite possibly that should be a global rather than passed around everywhere.

# This should also return an actual value, when that is known, or some
# information about the value.  When failure is returned, that return value
# indicates the reason for failure.

# Lists of all the variables, functions, types encountered during the parse.
my %parsevars = ();
my %parsefuns = ();
my %parsetypes = ();
my $parse_exp_saw_equals = $false;

# Should check @parsexxxs for reserved words; if we find any, I misparsed.
sub reset_parse_vars ( )
{
  # Could use undef instead...
  %parsevars = ();
  %parsefuns = ();
  %parsetypes = ();
  $parse_exp_saw_equals = $false;
}

# Returns a type and the remaining string.
# Side-effects: %parsevars, %parsefuns, %parsetypes.  (It would be way too
# much trouble to pass these around and return them everywhere.)
sub parse_expression ( $ )
{
  my ($exp) = check_args(1, @_);
  reset_parse_vars();
  if ($debug_parse_expression) { print "parse_expression <= $exp\n"; }
  # Should be no comments when this is called, so no need to do this.
  # my ($type, $remaining) = parse_exp(remove_comments($exp));
  return parse_exp($exp);
}


sub parse_exp_nocommaop ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $false;
  return parse_exp($exp, $ignoretypes);
}

sub parse_exp_commaop ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $true;
  return parse_exp($exp, $ignoretypes);
}


# Like parse_expression, but doesn't reset @parsexxxs.
# Returns two values:  the expression's type and the remaining string.
# Every call should be followed by   "if (!$type) { return($typeFAIL,$exp); }"
# See H&S p. 181.
sub parse_exp ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  if ($debug_parse_expression)
    { print "parse_exp", ($ignoretypes ? " (ignore types)" : ""), " <= '$exp'\n"; }
  # If ignoretypes is set, then we don't try to infer types, look up types
  # of unknown functions, or set symbol tables.  We do still compute types
  # for literals and return a type, I think.

  # Perhaps remember length of @parsexxxs, so we can restore them if failure.
  # But right now we never fail unless everything fails, so never mind...

  $exp =~ s/^\s+//;		# remove leading space

  # First, cope with open parens

  # Cast
  if ($exp =~ /^\(\s*($builtin_type_re)\s*\)/o)
    { # print "Found cast $1\n";
      my $casttype = parse_type($1);
      my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      my $casttypenum = type_to_num($casttype);
      # print "built-in cast type num = $casttypenum for cast type = $casttype\n";
      if (!is_number($casttypenum))
	{ $parsetypes{$casttypenum} = $true; }
      return parse_exp_follower($casttypenum, $remaining); }
  # Type in parens followed by (what looks like) paren, number, identifier, or
  # unary operator (without a binary counterpart: no +-!&*)
  elsif (($exp =~ /^\(\s*($type_re)\s*\)\s*([0-9a-zA-Z_\(~])/o)
      || ($exp =~ /^\(\s*($type_re\s*$type_suffix_re+)\s*\)\s*(.)/o) # ends with *: pointer
      # identifier ending with _t: type
      || ($exp =~ /^\(\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*\)\s*(.)/)
      # identifier which expands to reserved word: type
      || (($exp =~ /^\(\s*($identifier_re)\s*\)\s*(.)/o)
	  && defined($mncategory{$1})
	  && (($mncategory{$1} eq $catTYPE)
	      # Is this latter really necessary?
	      || ($mncategory{$1} eq $catRESERVED_WORD)))
      )
    { my $casttype = parse_type($1);
      my $nextchar = $LAST_PAREN_MATCH;
      # print "non-built-in cast type $casttype (follower $nextchar)\n";
      $parsetypes{$casttype} = $true;
      my ($type, $remaining) = parse_exp($nextchar . $POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($casttype,$remaining); }
  # print "not a cast: $exp\n";

  # Parens around statement (GNU C: use statement as expression)
  elsif ($exp =~ m/^\(\s*\{/)
    { my ($cat, $remaining) = parse_statement("\{$POSTMATCH");
      if (($cat == $catSTATEMENT) && ($remaining =~ /^\s*\)/))
	{ return parse_exp_follower($typeUNKNOWN, $POSTMATCH); }
      else
	{ return($typeFAIL,$exp); } }

  # Parens as grouping
  elsif ($exp =~ m/^\(/)
    { my ($type, $remaining) = parse_exp_commaop($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      if ($remaining =~ m/^\s*\)/)
	{ return parse_exp_follower($type, $POSTMATCH); }
      else
	{ return($typeFAIL,$exp); } }

  # Unary prefix operators
  elsif ($exp =~ /^(\+\+|--|[-~!+&*])/)
    { my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      # This isn't right -- eg, & result type differs from argument type
      return parse_exp_follower($type,$remaining); }
  # [^\)] was [ \ta-zA-Z0-9*]
  elsif ($exp =~ /^sizeof\s*/)
    { # Two possibilities:  sizeof(TYPE) or sizeof EXP.
      # If no parens, we know it's an expression.
      # If parens, it might be an expression or a type; have to guess.
      my $sizeof_follower = $POSTMATCH;
      my $sizeof_arg_type;
      my $remaining;
      if (($sizeof_follower =~ /\(\s*([^\)]+?)\s*\)/)
	  && (($remaining = $POSTMATCH) || $true) # execute for side effect
	  && (($sizeof_arg_type = $1) =~ /^$type_re$/o))
	{ # $remaining is already set
	  # fix: add this type to the list of those seen.
	  # (It might be an expression that looks like a type; what to do?
	  # Can check $reserved_type_word_re...
	}
      else
	{ ($sizeof_arg_type, $remaining) = parse_exp($sizeof_follower, $ignoretypes);
	  if (!$sizeof_arg_type)
	    { return($typeFAIL,$exp); }
	}
      # actually "size_t", but "int" is understood and that isn't yet.
      return parse_exp_follower($typeINT, $remaining); }
  elsif ($exp =~ /^(true|false)\b/)
    { return ($typeBOOL, $POSTMATCH); }
  elsif ($exp =~ /^$reserved_nontype_word_re/o)
    # reserved word except sizeof, true, false
    { return ($typeFAIL, $exp); }
  elsif ($exp =~ /^__extension__\b/)
    { return parse_exp($POSTMATCH, $ignoretypes); }

  # Literals

  # Literal string
  # This regular expression is perhaps expensive; split into two tests?
  # By this point, the literal value might be "" due to simplification.
  elsif (($exp =~ /^$string_literal_re/o) # literal
	 || ($exp =~ /^\#\s*$identifier_re/)) # stringization
    # String contains no non-escaped double-quote
    { # Avoid deep recursion when hundreds of string literals follow one another.
      my $remaining = $POSTMATCH;
      while ($remaining =~ /^\s*$string_literal_re/o)
	{ $remaining = $POSTMATCH; }
      # parse_exp_follower looks for a following string, to concatenate the two.
      return parse_exp_follower($typeSTRING, $remaining); }

  # Literal character
  elsif ($exp =~ /^$char_literal_re/o)
    { return parse_exp_follower($typeCHAR, $POSTMATCH); }

  # Literal floating-point
  # This precedes integer because an integer matches the first part of a float
  elsif (($exp =~ /^$float_literal_whole_re/o)
      || ($exp =~ /^$float_literal_frac_re/o)
      || ($exp =~ /^$float_literal_exp_re/o)
      || ($exp =~ /^$float_literal_noexp_re/o))
    { my $type = $typeDOUBLE;
      if (($2 eq "f") || ($2 eq "F"))
	{ $type = $typeFLOAT; }
      elsif (($2 eq "l") || ($2 eq "L"))
	{ $type = $typeLDOUBLE; }
      return parse_exp_follower($type,$POSTMATCH); }

  # Literal integer (octal)
  # Don't need leading [-+]? because they are always unary operators, never
  # part of the literal itself.
  elsif (($exp =~ /^$hex_literal_re/o)  # hex
      # hex precedes octal/decimal because the "0" looks like a leading integer.
      # (Actually, that's irrelevant here since infer_int_type does the work.
      || ($exp =~ /^$dec_oct_literal_re/o)) # octal or decimal
    { my $int_literal = $1;
      my $int_modifiers = $2;
      my $remaining = $POSTMATCH;
      if ($debug_parse_expression)
	{ print "Found integer $int_literal ",
	      ($int_modifiers ? "(modifiers $int_modifiers)\n" : "(no modifiers)\n"); }
      my $type = infer_int_type($int_literal);
      if ($debug_parse_expression) { print "inferred type ", type_name($type), "\n"; }
      if ($int_modifiers =~ /[uU]/)
	{ $type = type_unsignify($type); }
      if ($int_modifiers =~ /[lL]/)
	{ $type = type_longify($type);
	  if ($int_modifiers =~ /[lL][lL]/)
	    { $type = type_longify($type); } }
      # return parse_exp_follower($type,$remaining);
      my @result = parse_exp_follower($type,$remaining);
      if ($debug_parse_expression)
	{ print "parse_exp_follower(", type_name($type), ",$remaining) => ", join("||", @result), "\n"; }
      return @result;
    }

  # Array initializer
  elsif ($exp =~ /^\{/)
    { my ($array_init_type, $post_array_init) = parse_array_initializer($POSTMATCH);
      if (!$array_init_type)
	{ return($typeFAIL, $exp); }
      return ($array_init_type, $post_array_init);
    }

  # Type; we don't call parse_exp from top level on a type, so
  # this is a recursive call and it's reasonable to do this.
  # $commaop == $false and the trailing comma or close paren
  # ensures we are parsing a function argument.
  elsif (($commaop == $false) &&
	 ( # like $type_re, but unconditional suffix
	  ($exp =~ /^$type_specifier_re\s*\[\s*\]\s*$type_suffix_re*([,\)])/o)
	  # precedes the below because struct, union are reserved type words
	  || ($exp =~ /^(struct|union)\s*$identifier_re([,\)])/o)
	  || ($exp =~ /^($reserved_type_word_re\b[ \t\*\[\]]*)+([,\)])/o)))
    { if ($debug_parse_expression)
	{ print "parse_exp found type $MATCH\n"; }
      return ("category: $catTYPE", $LAST_PAREN_MATCH . $POSTMATCH); }

  # Variable
  elsif (($exp =~ /^$identifier_re/o)
	 # Hack for identifiers with leading $
	 || ($exp =~ /^\$+$identifier_re/o))
    { my $var = $MATCH;
      my $remaining = $POSTMATCH;
      # Fix: don't do this if the identifier is a macro argument.
      # Otherwise the definition of A in /sysdeps/mach/hurd/i386/__sigret.c
      # fouls up glibc:/malloc/realloc.c:96:  min(A, B) ((A) < (B) ? (A) : (B))
      # See if this is a macro, and if so try to categorize it now.
      # (This assumes that parse_exp isn't called until all macros bodies
      # have been discovered; I think this is reasonable, as the first pass
      # does no parsing.)
      if ($debug_parse_expression)
	{ print "categorizing potential macro $var; remaining $remaining\n"; }
      categorize_macro_name($var);
      my $vartype = $mntype{$var};
      my $is_macro = defined($vartype);
      if ($debug_parse_expression)
	{ if ($is_macro)
	    { print "parse_exp: $var is a macro\n"; }
	  else
	    { print "parse_exp: $var is not a macro\n"; } }
      if ($is_macro)
	{ # This is kind of a hack; is it the right thing to do?
	  # FIX:  figure out whether it is the right thing.
	  if ((!$vartype) && defined($mncategory{$var}) && $mncategory{$var})
	    { $vartype = "category: $mncategory{$var}"; }
	  if ($debug_parse_expression)
	    { print "macro $var as variable of type '", type_name($vartype), "'\n"; } }
      else
	# This isn't a macro.
	# Need to do a MUCH better job here; in particular, infer a type.
	# Perhaps return a negative number, an index into a list of things
	# whose types need to be inferred.
	# Also try looking up in global symbol table.
	{ $vartype = $typeUNKNOWN; }

      # Perhaps do something different if the categorization was successful.
      # Not sure what this means: "Perhaps get info back here, so we can stash
      # it in calls to macros.  Make sure that agrees with Greg's data structures."
      if ($remaining =~ /^\s*\(/)
	{ if (!$is_macro) { $parsefuns{$var} = $true; }
	  return parse_arglist($vartype, $POSTMATCH);
	}
      else
	{ if (!$is_macro) { $parsevars{$var} = $true; }
	  return parse_exp_follower($vartype, $remaining); }
    }

  else
    { if ($debug_parse_expression) { print "Couldn't match $exp\n"; }
      return ($typeFAIL, $exp); }
}


# $ftype should be a function type; this will return only the return type.
# The second $arglist already has leading paren stripped and is the whole of
# the remaining expression, not just the args.
sub parse_arglist ( $$ )
{
  my ($return_type, $arglist_orig) = check_args(2, @_);
  if ($debug_parse_expression) { print "parse_arglist: '$return_type' '$arglist_orig'\n"; }
  my $arglist = $arglist_orig;
  my @argtypes = ();

  # Need a notation for function types; maybe just -> in front.
  while ($arglist !~ /^\s*\)/)
    { my ($thisargtype, $comma) = parse_exp_nocommaop($arglist);
      if ($debug_parse_expression) { print "parse_arglist: found $thisargtype before $comma\n"; }
      if (!$thisargtype) { return($typeFAIL, $arglist); }
      push(@argtypes, $thisargtype);
      if ($comma =~ /^\s*,/)
	{ $arglist = $POSTMATCH; }
      elsif ($comma =~ /^\s*\)/)
	{ $arglist = $comma; }
      else
	{ my ($file, $line, $sub) = (caller(0))[1,2,3];
	  parse_error("parse_arglist called from $sub: no comma or close paren after well-formed arg '$arglist_orig', remaining = '$arglist'\n");
	  return($typeFAIL, $arglist); } }
  if ($arglist !~ /^\s*\)/)
    { mdie("Impossible; just saw a close paren"); }
  return parse_exp_follower(construct_function_type($return_type, @argtypes), $POSTMATCH);
}

# $initializer already has leading brace stripped
sub parse_array_initializer ( $ )
{
  my ($initlist) = check_args(1, @_);

  if ($debug_parse_array_init)
    { print "parse_array_initializer $initlist\n"; } # $initlist ends in newline -- not necessarily!

  # C allows an extra comma at the end of the initializer list.
  if ($initlist =~ /^\s*(,\s*)?\}/)
    { return (construct_array_type($typeUNKNOWN, 0), $POSTMATCH); }

  if (($initlist =~ /^\s*$reserved_word_re/o)
      || (($initlist =~ /\}/)
	  && ($PREMATCH =~ /;\s*/)))
    { # This is a statement, not an array initializer
      return($typeFAIL, $initlist); }

  my $elttype;
  while ($true)
    { my ($thisinittype, $comma);
      if ($debug_parse_array_init)
	{ print "current initlist = $initlist"; } # $initlist ends in newline
      if ($initlist =~ /^\s*\{/)
	{ if ($debug_parse_array_init)
	    { print "recursive call to parse_array_initializer\n"; }
	  ($thisinittype, $comma) = parse_array_initializer($POSTMATCH);
	  # transform subinittype from array to scalar type
	  if ($debug_parse_array_init)
	    { print "after recursive call to parse_array_initializer: $comma\n"; }
	}
      else
	{ ($thisinittype, $comma) = parse_exp_nocommaop($initlist);
	  if ($debug_parse_array_init)
	    { print "parse_exp_nocommaop returned (", type_name($thisinittype), ") $comma\n"; }
	}
      if (!$thisinittype) { return($typeFAIL, $initlist); }
      if (!defined($elttype))
	{ $elttype = $thisinittype; }
      else
	{ # FIX: do this
	  # $elttype = merge_somehow($elttype, $thisinittype);
	}

      # push $thisinittype somewhere
      if ($comma =~ /^\s*(,\s*)?\}/)
	# FIX: should remember length and return it, too.
	{ return (construct_array_type($elttype), $POSTMATCH); }
      elsif ($comma =~ /^\s*,/)
	{ $initlist = $POSTMATCH; }
      else
	{ parse_error("Neither comma nor close brace followed well-formed init $initlist\n");
	  return($typeFAIL, $initlist); } }
  mdie("Can't get to here.");
}

# Returns a success boolean, the post-closeparen string, and the declarations.
# These might be:
#   * identifiers or type decls (if in definition)
#   * types or type decls (if in declaration)
# so don't try to distinguish; just return them literally.
sub parse_function_decl_args ( $ )
{
  my ($text) = check_args(1, @_);
  if ($debug_parse_declaration)
    { print "parse_function_decl_args <= $text\n"; }

  my @arg_decls = ();

  if (($text =~ /^\s*\)/) || ($text =~ /^\s*void\s*\)/)
      || (($text =~ /^\s*($identifier_re)\s*\)/o)
	  && exists($macros{$1}) && exists($void_macros{$1})))
    # No arguments
    { return ($true, $POSTMATCH, @arg_decls); }

  # I have no way of preferring to parse as a typedecl vs. as
  # a type vs as a bare identifier (won't know until reading ";" or "{" after
  # the arglist whether this is a function definition or declaration).
  # Disambiguate later.
  # print "looking for type or type declarator in $text\n";
  while (
	 # Gross special case.  I'm sorry.
	 ($text =~ /^\s*($type_re_special)\s*([,\(\)])/o)
	 || ($text =~ /^\s*(($type_declarator_re)|($type_re))\s*([,\(\)])/o)
	 || ($text =~ /^\s*(\.\.\.)\s*(\))/o))
    { my $arg_decl = $1;
      my $nextchar = $LAST_PAREN_MATCH;
      $text = $POSTMATCH;
      if ($nextchar eq "\(")
	{ # This function argument declarator declares a function.
	  my ($success, $remaining, @sub_arg_decls) = parse_function_decl_args($text);
	  if ((!$success) || ($remaining !~ m/^\s*([,\)])/))
	    { parse_error("Couldn't parse sub-function arg declaration $text");
	      return ($false, $text, ()); }
	  $nextchar = $1;
	  $text = $POSTMATCH;
	  # For now, put it back together and make someone else re-parse it.
	  $arg_decl .= "(" . join(", ", @sub_arg_decls) . ")";
	}
      push(@arg_decls, $arg_decl);
      if ($nextchar eq "\)")
	{ if ($debug_parse_declaration)
	    { print "parse_function_decl_args <= ", join(', ', @arg_decls), "\n"; }
	  return ($true, $text, @arg_decls); }
      if ($nextchar ne ",")
	{ mdie("Must be at comma: '$nextchar' '$text' '@arg_decls'"); }
      # print "new text $text\n";
    }
  parse_error("Couldn't parse function arg declaration $text");
  return ($false, $text, ());
}

# Return the remaining string, reference to a list of warnings, and an
# associative array of names to types.
# (Return values in that order because the multiple-value thing must be last.)
# If there are warnings, then the parse failed; otherwise, it succeeded.
# Don't bother sharing code with argument declarator parsing; too much work.
sub parse_declarations ( $ )
{
  my ($decls) = check_args(1, @_);
  my %nametype = ();
  my $warnings = [];
  # if ($debug_parse_declaration)
  #   { print "type_declarator_re = '$type_declarator_re'\n"; }
  if ($debug_parse_declaration)
    { print "parse_declararions $decls\n"; }
  while ($decls =~ /^\s*$type_declarator_re\s*([,;\(=])/o)
    { my $typespec = $1;
      my $declarator = $2;
      my $nextchar = $LAST_PAREN_MATCH;
      $decls = $POSTMATCH;
      my ($type, $identifier) = parse_declarator($typespec, $declarator);
      if ($debug_parse_declaration)
	{ print "parsed decl '$typespec' '$declarator'; remaining '$nextchar' '$decls'\n"; }
      if ($nextchar eq "=")
	{ my $postexp = skip_expression_nocommaop($decls);
	  if ($postexp =~ /^\s*([,;])/)
	    { $decls = $POSTMATCH;
	      $nextchar = $1; }
	  else
	    { push(@$warnings, "No comma or semicolon after skipping initializer expression in $decls");
	      return ($postexp, $warnings, %nametype); } }
      if ($nextchar eq "\(")
	{ # This function argument declarator declares a function.
	  my ($success, $remaining, @sub_arg_decls) = parse_function_decl_args($decls);
	  if ($success && ($remaining =~ m/^\s*([,;])/))
	    { $nextchar = $1;
	      $decls = $POSTMATCH;
	      # For now, put it back together and make someone else re-parse it.
	      $type .= "(" . join(", ", @sub_arg_decls) . ")"; }
	  else
	    { push(@$warnings, "Couldn't parse sub-function arg declaration $decls");
	      return ($decls, $warnings, %nametype); }
	}
      $nametype{$identifier} = $type;
      while ($nextchar eq ",")
	{ if ($decls =~ /^\s*$declarator_re\s*([,;])/o)
	    { $declarator = $1;
	      $nextchar = $LAST_PAREN_MATCH;
	      $decls = $POSTMATCH;
	      ($type, $identifier) = parse_declarator($typespec, $declarator);
	      $nametype{$identifier} = $type; }
	  else
	    { push(@$warnings, "Couldn't parse declarator following comma after '$typespec $declarator $nextchar': $decls\n");
	      return ($decls, $warnings, %nametype); } } }
  return ($decls, $warnings, %nametype);
}

## I think this can be discarded in favor of a check for open brace plus a call
## to parse_declarations.
# Return the remaining string (after the open brace), and an associative array
# of names to types.
# Don't bother sharing code with argument declarator parsing; too much work.
sub parse_KandR_function_arg_decls ( $ )
{
  my ($argdecls) = check_args(1, @_);
  my ($remaining, $warnings, %nametype) = parse_declarations($argdecls);
  map {parse_error($_)} @$warnings;
  if ($remaining =~ /^\s*\{/)
    { $remaining = $POSTMATCH; }
  elsif ($remaining =~ /\{/)
    { parse_error("Couldn't parse K&R-style type declarator $remaining");
      $remaining = $POSTMATCH; }
  else
    { parse_error("parse_KandR_function_arg_decls: no open brace in '$argdecls'\n"); }
  return ($remaining, %nametype);
}


# This needs to take a value as an argument, too, so it can return that.

# Parse what follows an expression, such as "+3" or "->foo".
sub parse_exp_follower ( $$ )
{
  my ($type, $follow) = check_args(2, @_);

  if ($debug_parse_expression)
    { print "parse_exp_follower: '", type_name($type), "' '$follow'\n"; }

  ## What "other bug?"
  ## Enable when the other bug is squashed.
  #  if ($follow =~ /^\s*$/)
  #    { return ($type, $follow); }

  # Perhaps this can happen because it's easier to hand off to
  # parse_exp_follower unconditionally than to perform a check.
  if ($type eq $typeFAIL)
    # This isn't quite right since the failure occurred earlier.
    { return($type, $follow); }

  $follow =~ s/^\s+//;		# remove leading space

  # Array subscript
  if ($follow =~ /^\[/)
    { my $subscript = $POSTMATCH;
      my ($subscrtype, $closebracket) = parse_exp($subscript);
      if (!$subscrtype) { return($typeFAIL,$subscript); }
      if (!(type_integral_p($subscrtype) || ($subscrtype eq $typeUNKNOWN)))
	{ parse_error("parse_exp_follower: non-integral type ", type_name($subscrtype), " in subscript in '$follow'\n");
	  return ($typeFAIL, $follow); }
      if ($closebracket =~ /\s*\]/)
	{ my $remaining = $POSTMATCH;
	  return parse_exp_follower(type_dereference($type), $remaining); }
      else
	{ return ($typeFAIL, $follow); } }

  # Function call (might this be some other use of parens??)
  if ($follow =~ /^\(/)
    { return parse_arglist($type, $POSTMATCH); }

  # Unary postfix operators
  if ($follow =~ /^(\+\+|--)/)
    { return parse_exp_follower($type, $POSTMATCH); }
  # Structure selectors
  if ($follow =~ /^\s*(\.|->)\s*$identifier_re/o)
    # Shouldn't give up so easily here; should have record types and try to
    # do the selection.
    { return parse_exp_follower($typeUNKNOWN, $POSTMATCH); }

  # Binary operators:  multi-char operators must precede single-char ones
  if (($follow =~ /^($binop_regexp)/o)
      || ($commaop && ($follow =~ /^(,)/)))
    { my $op = $1;
      my $arg2 = $POSTMATCH;
      if ($debug_parse_expression)
	{ print "parse_exp_follower found binary operator '$op' '$arg2'\n"; }
      if ($op eq ",")
	{ # print "found a comma operator, commaop = $commaop\n";
	}
      if (($op eq "=") || ($op =~ /^[<>][<>]=$/) || ($op =~ /^[^<>=]=$/))
	{ $parse_exp_saw_equals = $true; }
      my ($type2, $post_arg2) = parse_exp($arg2);
      if (!$type2) { return ($typeFAIL, $arg2); }
      # parse_exp_follower is certain to do nothing here, because parse_exp
      # has already gobbled all it can.  Right?  (Unless commaop has changed,
      # or I start to use precedence.)
      if (is_bool_binop($op))
	{ return parse_exp_follower($typeBOOL, $post_arg2); }
      elsif (($op eq ",") || ($op eq "="))
	{ return parse_exp_follower($type2, $post_arg2); }
      else
	{ my $result_type = type_lub($type, $type2);
	  if (($type eq $typeUNKNOWN) && (is_numeric_binop($op)))
	    { $type = $typeNUMBER; }
	  return parse_exp_follower($result_type, $post_arg2); } }

  # Ternary operator ?:
  if ($follow =~ /^\?/)
    { my $then = $POSTMATCH;
      my ($thentype, $colon) = parse_exp($then);
      if (!$thentype) { return ($typeFAIL, $then); }
      if ($colon !~ /^\s*:/) { return ($typeFAIL, $colon); }
      my ($elsetype, $remaining) = parse_exp($POSTMATCH);
      if (!$elsetype) { return ($typeFAIL, $colon); }
      # print "ternary operator: lub($thentype, $elsetype) = ", type_lub($thentype, $elsetype), "\n";
      return (type_lub($thentype, $elsetype), $remaining); }

  # print "Checking for contatenated strings: ", type_name($type), ": $follow\n";
  if (($type eq $typeSTRING)
      && (($follow =~ /^\"/)
	  || (($follow =~ /^$identifier_re/o)
	      # Call categorize_macro_name here for side effect.
	      && (categorize_macro_name($MATCH) || $true)
	      && defined($mntype{$MATCH})
	      && ($mntype{$MATCH} eq $typeSTRING))))
    { my ($followtype, $followfollow) = parse_exp($follow);
      if ((!$followtype) || ($followtype ne $typeSTRING))
	{ return ($typeFAIL, $follow); }
      else
	{ return ($typeSTRING, $followfollow); } }

  if ($debug_parse_expression)
    { print "parse_exp_follower returning ", type_name($type), "; found no follower in '$follow'\n"; }
  return ($type, $follow);
}

sub is_bool_binop ( $ )
{
  my ($op) = check_args(1, @_);
  return ($op =~ /^($bool_binop_regexp)$/o);
}

sub is_numeric_binop ( $ )
{
  my ($op) = check_args(1, @_);
  return ($op =~ /^($numeric_binop_regexp)$/o);
}

# Controls whether "while" is treated as start of a new statement.
use vars qw($parsing_do_statement);


# Returns a category (probably $catSTATEMENT, $catSTATEMENT_SANS_SEMI,
# $catPARTIAL_STATEMENT, or $catFAILURE), plus the remaining string.
sub parse_statement ( $ )
{
  my ($body) = check_args(1, @_);
  $body =~ s/^\s+//;
  if ($debug_parse_statement) { print add_newline("parse_statement <= $body"); }

  if ($body eq "")
    { return ($catFAILURE, ""); }
  elsif ($body =~ /^;/)
    { return ($catSTATEMENT, $POSTMATCH); }
  elsif ($body =~ /^(break|continue)\b/)
    { return statement_or_sans_semi($POSTMATCH); }
  elsif ($body =~ /^return\b\s*/)
    { my ($type, $remaining) = parse_expression($POSTMATCH);
      # return is allowed not to take an argument, so ignore return type
      return statement_or_sans_semi($remaining); }
  elsif ($body =~ /^goto\s*$identifier_re/o)
    { return statement_or_sans_semi($POSTMATCH); }
  elsif ($body =~ /^(if|while|switch)\s*\(/)
    { # Don't try to parse the open paren, as it might look like a cast.
      my ($type, $remaining) = parse_expression($POSTMATCH);
      if ($debug_parse_statement)
	{ print "test type = $type; remaining = $remaining\n"; }
      if ((!$type) || ($remaining !~ /^\s*\)/))
	{ return ($catPARTIAL_STATEMENT, $remaining); }
      else
	{ $remaining =~ /^\s*\)/;
	  $remaining = $POSTMATCH;
	  my ($subcat, $subremaining) = parse_statement($remaining);
	  if ($subcat == $catFAILURE)
	    { return ($catPARTIAL_STATEMENT, $remaining); }
	  elsif (($subcat == $catSTATEMENT) && ($subremaining =~ /^\s*else\b/))
	    { my ($subsubcat, $subsubremaining) = parse_statement($POSTMATCH);
	      if ($subsubcat == $catFAILURE)
		{ return ($catPARTIAL_STATEMENT, $subsubremaining); }
	      else
		{ return ($subsubcat, $subsubremaining); } }
	  else
	    { return ($subcat, $subremaining); } } }
  elsif ($body =~ /^do\b/)
    { my ($cat, $remaining) = parse_statement($POSTMATCH);
      if (($cat == $catFAILURE) || ($remaining !~ /^\s*while\b/))
	{ return ($catPARTIAL_STATEMENT, $remaining); }
      else
	{ $remaining =~ s/^\s*while\b\s*//;
	  if ($debug_parse_statement) { print "stripped while from $remaining\n"; }
	  my ($exp_type, $exp_remaining) = parse_expression($remaining);
	  if (!$exp_type)
	    { return ($catPARTIAL_STATEMENT, $remaining); }
	  else
	    { return statement_or_sans_semi($exp_remaining); } } }
  elsif ($body =~ /^for\s*\(/)
    { # It doesn't matter whether the calls to parse_expression succeed or not,
      # as parts the for init, test, or step may be omitted.
      my ($t1, $rem1) = parse_expression($POSTMATCH);
      if ($rem1 =~ /^\s*;/)
	{ my ($t2, $rem2) = parse_expression($POSTMATCH);
	  if ($rem2 =~ /^\s*;/)
	    { my ($t3, $rem3) = parse_expression($POSTMATCH);
	      if ($rem3 =~ /^\s*\)/)
		{ my ($cat, $remaining) = parse_statement($POSTMATCH);
		  if ($cat == $catFAILURE)
		    { return ($catPARTIAL_STATEMENT, $remaining); }
		  else
		    { return ($cat, $remaining); } }
	      else
		{ return ($catPARTIAL_STATEMENT, $rem3); } }
	  else
	    { return ($catPARTIAL_STATEMENT, $rem2); } }
      else
	{ return ($catPARTIAL_STATEMENT, $rem1); } }

  elsif ($body =~ /^\{/)
    { # quite weak test, but good enough for me.
      my $close_pos = find_close_delimiter('{', $body, 1);
      if ($debug_parse_statement)
	{ print "close_pos = $close_pos in $body\n"; }
      if (!$close_pos)
	{ return ($catPARTIAL_STATEMENT, $body); }
      else
	{ return ($catSTATEMENT, substr($body, $close_pos+1)); } }
  else
    { # Try parsing it as an expression (which, with semicolon, is a statement).
      my ($exptype, $expremaining) = parse_expression($body);
      if ($debug_parse_statement)
	{ print "parsed as expression $exptype, leaving '$expremaining' from '$body'\n"; }
      if (!$exptype)
	{ return ($catFAILURE, $body); }
      else
	{ return statement_or_sans_semi($expremaining); } }
}

sub statement_or_sans_semi ( $ )
{ my ($arg) = check_args(1, @_);
  if ($arg =~ /^\s*;/)
    { return ($catSTATEMENT, $POSTMATCH); }
  else
    { return ($catSTATEMENT_SANS_SEMI, $arg); } }

# Return category and string following the statements.
# This shouldn't return $catSTATEMENT except via a call to
# parse_statement_follower.
sub parse_statements ( $ )
{
  my ($body) = check_args(1, @_);

  my ($cat, $remaining) = parse_statement($body);
  if ($debug_parse_statement)
    { print "parse_statements: first statement category $cat, remaining '$remaining'\n"; }
  if ($cat == $catSTATEMENT)
    { return parse_statement_follower($remaining); }
  else
    { return ($cat, $remaining); }
}


sub parse_statement_follower ( $ )
{ my ($body) = check_args(1, @_);

  if ($debug_parse_statement)
    { print add_newline("parse_statement_follower <= $body"); }
  if ($body =~ /^\s*$/)
    { return ($catSTATEMENT, ""); }

  my ($cat, $remaining) = parse_statement($body);
  if ($cat == $catFAILURE)
    { return ($catSTATEMENT, $body); }
  while (($cat == $catSTATEMENT) || ($cat == $catSTATEMENTS))
    { $body = $remaining;
      ($cat, $remaining) = parse_statement($remaining); }
  if ($cat == $catFAILURE)
    { return ($catSTATEMENTS, $remaining); }
  elsif (($cat == $catSTATEMENT_SANS_SEMI)
	 || ($cat == $catSTATEMENTS_SANS_SEMI))
    { return ($catSTATEMENTS_SANS_SEMI, $remaining); }
  elsif (($cat == $catPARTIAL_STATEMENT)
	 || ($cat == $catPARTIAL_STATEMENTS))
    { return ($catPARTIAL_STATEMENTS, $remaining); }
  else
    { mdie("What category? $cat '$remaining' '$body'"); } }


###########################################################################
### Process macro calls
###

### Get types for macro calls

# This is a bit disappointing because it's so heuristic; my inclination is
# really to get it right rather than approximate.

# Find all uses of a macro, to determine types of its arguments.
# (If it isn't used, it can be eliminated -- this will be true of many in
# standard header files, perhaps.)
# Do a rough parse of each file:
#  recognize binding forms:
#     variable declarations, function definitions, function declarations
#     Can use etags to find function defintiions, but it doesn't find
#	global variables.
#  recognize function calls, check whether they are macros
# Cope with macro definitions like "#define local static" and with
#    typedefs like "typedef unsigned long  ulg;" (the latter not to use
#    the raw type, but to permit type_lub to do a better job, maybe).

# Dies if some condition that shouldn't happen at a file boundary is true.
sub check_file_boundary ( )
{
  check_args(0, @_);
  my ($package, $filename, $line) = caller;
  if (@current_inclusion_dependenton > 0)
    { parse_error("$filename:$line: in \#if at beginning or end of file: @current_inclusion_dependenton");
      @current_inclusion_dependenton = (); }
  if (cline_ungot_size() > 0)
    { mdie("$filename:$line: ungot lines at file boundary:\n", cline_ungot_string()); }
  if ($symtab_scopes != 0)
    { parse_error("$filename:$line: bad brace depth $symtab_scopes at file boundary.\n");
      while ($symtab_scopes > 0)
	{ exit_scope(); } }
}


sub process_macro_calls ( )
{
  check_args(0, @_);
  local $finding_macro_uses = $true;
  local $merge_cpp_if_branches = $true;
  # Apparently local does not work for imported variables like $cline_simplify_strings
  my $old_cline_simplify_strings = $cline_simplify_strings;
  $cline_simplify_strings = $true;
  # Not "foreach @files" because @files can change, I think.
  # skip index 0, which is built_in_fake_filename
  for (my $ifiles = 1; $ifiles <= $#files; $ifiles++)
    { $current_file_number = $ifiles;
      $current_file_name = $files[$current_file_number];
      # shouldn't have already set this value
      if (defined($files_function_lines[$current_file_number]))
	{ mdie("Reprocessing file $current_file_name?"); }
      @{$files_function_lines[$current_file_number]} = ();
      $current_ftype_index = compute_ftype_index($current_file_number);
      if ($opt_v) {
	print STDERR "file: \"$current_file_name\" ($file_inclusion_method[$current_file_number])";
      }
      # do not do the second pass on included files
      if (file_was_included($current_file_number) && !$opt_A) {
	print STDERR " -- skipping (use -A option to not skip)\n" if $opt_v;
	find_function_declarations($current_file_name);
	next;
      } elsif (!open(INPUT,$current_file_name)) {
	# fix: Shouldn't we print to STDERR unconditionally?
	# fix: Add quiet option; then this will occur unless that is set.
	print STDERR " -- open failed\n" if $opt_v;
	next;
      } else {
	print STDERR "\n" if $opt_v;
      }

      check_file_boundary();
      # Perhaps I should use a variant of get_fulltoken_line that insists
      # that parens are balanced, too; that might let me more reasonably
      # cope with breaks across lines.
      # Perhaps make global so check_file_boundary can check it.
      my $in_extern_C = 0;
      my $line;
      while ($line = get_fulltoken_line())
	{
	  if ($debug_getline)
	    { print "GOTLINE <<$line>>\n"; }
	  # The line number $. isn't quite right, as we may have peeked ahead
	  # print "line ", current_line_no(), ": $line"; # no newline, since $line contains one
	  if ($line =~ /^\s*$/)
	    { # empty line; possibly was originally a preprocessor command
	    }
	  elsif ($line =~ m/^\s*\#/o)
	    { mdie("get_fulltoken_line shouldn't return preprocessor lines: $line"); }
	  else
	    { # not empty or a preprocessor line
	      # print "not empty or a preprocessor line $line"; # $line has newline
	      # Are we guaranteed there will be a trailing newline?
	      chop($line);	# remove trailing newline
	      # In a scope, must be indented or: close brace, comment, label

	      # Alternative to variable $indented is making sure that loops
	      #   back to PROCESSLINE append a space to the front of lines
	      #   that were oringally indented, but a portion of which must
	      #   be reprocessed.  (Actually, that wouldn't even be enough,
	      #   since we want to treat bar as unindented in unindented
	      #   "foo; bar;".)
	      my $indented = ($line =~ /^[ \t]/);

	      # Exceptions to indentation checking; a bit hackish.
	      # Perhaps should strip labels here rather than just overlook them.
	      if ((!$indented)
		  && (($line =~ m/^($identifier_re\s*:)/o)
		      || (($symtab_scopes == 1)
			  && ($line =~ m/^(\}|\"|0\};)/))))
		{ # print "setting line to indented: $line\n";
		  $indented = $true; }
	      # Checks for any improperly unindented line.  Later, we
	      # make sure that every properly unindented line was processed.
	      if ((!$indented) && ($symtab_scopes != 0))
		{ # Don't complain if case label or in specific files; but also
		  # don't monkey with the value of $indented.
		  if (!(($current_file_name =~ /\by\.tab\.c$/)
			|| ($current_file_name =~ /initscan-mvs\.c$/)
			|| ($line =~ /^case (([0-9]+)|([a-zA-Z_]+(\([a-zA-Z_]+\))?)):$/)))
		    { parse_error("process_macro_calls: bracedepth $symtab_scopes non-indented line $line "); } }

	      # Check for improper indentation later, complaining only
	      # about lines containing definitions/declarations.  (Maybe
	      # should do more checking?)

	      # Look for:
	      #   typedef,
	      #   function definition/declaration (only at symtab_scopes == 0),
	      #   variable definition/declaration,
	      #   function call (of a macro),
	      #   brackets (to keep track of scopes),
	      #   not string/char literals (already simplified).
	      # These can span multiple lines, especially function definitions.

PROCESSLINE:
	      if (!defined($line))
		{ mdie("PROCESSLINE: line undefined."); }
	      # print "PROCESSLINE $line\n";
	      my $line_orig = $line;
	      { my $unsimp_line;
		my $repeat = $true;
		while ($repeat)
		  { $unsimp_line = $line;
		    $line = simple_macro_substitute($line);
		    $line = simple_macro_substitute_2($line);
		    $repeat = ($unsimp_line ne $line); } }
	      # print "Substituted: $line\n";
	      if ($line =~ /^\s*$/)
		{ # do nothing; maybe this was a preprocessor directive
		  # print "empty line ", current_line_no(), ":\n";
		}
	      elsif ($line =~ /^\s*typedef\s+/)
		{ # process typedefs
		  # print "typedef line ", current_line_no(), ": $line\n";
		  if ($line !~ /;/)
		    { my $success;
		      # print "No semicolon in typedef line, so looking at subsequent lines.\n";
		      ($success, $line) = get_fulltoken_lines_to(';', $line, 5);
		      # print "Looked for semicolon ($success): $line\n";
		    }
		  while ($line =~ /[\{;]/)
		    { $line = $POSTMATCH;
		      # print "found '$MATCH'; set line to $line = $POSTMATCH\n";
		      if ($MATCH eq ";")
			{ if ($PREMATCH =~ /$identifier_re$/)
			    { # print "found typedef name $MATCH\n";
			      $typedefs{$MATCH} = input_file_and_line();
			    }
			  else
			    { parse_error("No identifier found before typedef semicolon: $line"); } }
		      elsif ($MATCH eq "\{")
			{ my ($close_brace_pos,$extended_line) = find_close_brace_read($line);
			  $line = substr($extended_line, $close_brace_pos+1);
			  if ($line !~ /;/)
			    { my ($success, $lines) = get_fulltoken_lines_to(';', $line, 5);
			      $line .= $lines; } }
		      else
			{ die "What match? '$MATCH' $line"; } }

		  # Should store all the typedefs somewhere so we don't
		  # consider them free variables.

		  # What was the point of this line?  It looks wrong to me.
		  # $line = $POSTMATCH;
# This is wrong because typedefs can have semicolons inside braces.
#		  my $semi_pos;
# 		  # use index(), because ($line =~ /;/) gave trouble here
# 		  while (-1 == ($semi_pos = index($line, ";")))
# 		    { # print "no semicolon, so appending a line to $remaining\n";
# 		      $line = append_lines($line, get_fulltoken_line($true)); }
# 		  my $typedef = substr($line, 0, $semi_pos-1); # omits "typedef", ";"
# 		  # process_typedef($typedef);
# 		  $line = substr($line, $semi_pos+1);
# 		  print "after typedef `$PREMATCH', set line to $line\n";
		  goto PROCESSLINE;
		}
	      # not $type_specifier_re, because want to catch trailing *
	      elsif (($line =~ /^$type_re\s*$/o)
		     # Dispense with this test, and instead check indentedness.
		     # If unindented, matches type, and next line nonblank,
		     # what else could it be?
# 		     && (($line =~ /$reserved_type_word_re/o) # no anchoring
# 			 ||
#                        # Note peek_fulltoken_line doesn't update @current_inclusion_dependenton
#                        # or do branch merging, so this isn't perfect in many
#                        # cases, such as
#                        #  int \n #if (X) \n const \n #endif foo(...)
# 			 # This fails if the second line is "fname MACRO((...))"
# 			 (peek_fulltoken_line(1) =~ /^$declarator_re\s*\(/o))
		     # && ((print "found lone typespec, indented=$indented, line=$line\n") ? $true : $true)
		     && ((!$indented)
			 && (defined(peek_fulltoken_line(1)))
			 && ((peek_fulltoken_line(1)) !~ /^\s*$/))
		     )
		{ # Definition or declaration (probably of a function)
		  # split over multiple lines
		  # print "combining function definition split over multiple lines\n";
		  $current_function_start_line = current_line_no();
		  my $nextline = get_fulltoken_line($true);
		  if (defined($nextline))
		    { $line = append_lines($line, $nextline);
		      # Don't jump forward, which confuses the loop; start over.
		      goto PROCESSLINE; }
		  else
		    { parse_error("Couldn't combine function def split over lines: $line");
		      # Fall through.
		    } }
	      # The negative lookahead assertion is to avoid matching
	      # "JOBSTATE (previous_job) == JSTOPPED", bash-1.14.7/jobs.c:1697.
	      elsif (($line =~ /^\s*($type_declarator_re)\s*([,=;\(])(?!=)/o)
		     # must check this second, to get "int (*foo) (arg1, arg2)"
		     || ($line =~ /^($identifier_re)\s*(\()/o))
		{
		  # We don't know whether we matched $type_declarator_re or
		  # $identifier_re, so rematch, which is wasteful.
		  my $nextchar = $LAST_PAREN_MATCH;
		  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";") || ($nextchar eq "\(")))
		    { mdie("what nextchar? '$nextchar'"); }
		  my $remaining = $POSTMATCH;
		  if (!defined($remaining))
		    { mdie("Undefined remaining after `$nextchar'"); }
		  my $typespec;
		  my $declarator;
		  { my $identifier_or_typedecl = $1;
		    # Do the easy case first here; order doesn't matter.
		    if ($identifier_or_typedecl =~ /^$identifier_re$/o)
		      { # fix: should warn about implicit return type for function.
			$typespec = "((int))";
			$declarator = $identifier_or_typedecl; }
		    elsif ($identifier_or_typedecl =~ /^$type_declarator_re$/o)
		      { $typespec = $1;
			$declarator = $2; }
		    else
		      { mdie("must be identifier or type declarator: $identifier_or_typedecl"); } }
		  if ($debug_type_match)
		    { print "matched type declarator <$typespec><$declarator><$nextchar>\n";
		      print "  remaining: $remaining\n";
		    }

		  # Fallthroughs below depend on the fact that this is the last
		  # clause in the elsif chain: there's nothing else we would
		  # try to do here if we didn't see a type declarator.

		  if (($typespec eq "Call") && ($declarator eq "UPDATE_HASH"))
		    { # In a #if comment in gzip-1.2.4/deflate.c line 633.
		      # (I don't want to give up on complete parsing yet, but
		      # don't want to mdie here).
		      # print "rejected special case";
		    }
		  # I think this may be intentionally unanchored (no ^...$)
		  elsif ($typespec =~ /$reserved_nontype_word_re/o)
		    { # "else if (...)", "return foo;", "sizeof(buf)", etc.
		      # print "rejected typespec $typespec\n";
		    }
		  # I think this may be intentionally unanchored (no ^...$)
		  elsif ($declarator =~ /$reserved_nontype_word_re/o)
		    {
		      # print "rejected declarator $declarator\n";
		    }
		  elsif (($nextchar eq "(")
			 # Implied by "defined($macros{$declarator}))"
			 # && ($declarator =~ /^$identifier_re$/o)
			 && exists($macros{$declarator})
			 # This test is intended to skip over macros that
			 # can't be active right now.
			 && macro_active($declarator, [ @current_inclusion_dependenton ])
			 # If the macro expands to a single identifier, then
			 # ignore it, even if it is active.
			 # Can't do this test; macros aren't yet categorized
			 # && ($mncategory{$declarator} != $catFUNCTION_NAME)
			 # && ($mncategory{$declarator} != $catSYMBOL_UNKNOWN)
			 && (!((scalar(@{$macros{$declarator}}) == 1)
			       && ($mdef_body_simple[$macros{$declarator}[0]] =~ /^$identifier_re\s*\Q$mdef_formals[$macros{$declarator}[0]]\E/)))
			 )
		    ## FIX: all this belongs in simple_macro_substitute.
		    { # The function being defined is actually a macro.
		      # Try to expand it, else fall through.
		      # print "macro masquerading as declarator $declarator\n";
		      # print scalar(@{$macros{$declarator}}), " <<"
		      #  , $mdef_body_simple[$macros{$declarator}[0]], ">> <<",
		      #  , "$identifier_re\s*\Q$mdef_formals[$macros{$declarator}[0]]\E", ">>\n";

		      my $identifier = $declarator;

		      my $close_paren_pos;
		      # if parens aren't balanced, read enough text to balance them.
		      ($close_paren_pos, $remaining) = find_close_paren_read($remaining);
		      if (!defined($remaining))
			{ mdie("Undefined remaining after close-paren $close_paren_pos"); }

		      # Case 1:
		      # There is only one expansion for the macro.  Expand it.
		      # This isn't quite right if the dependentons aren't
		      # compatible.
		      # Should also select this case if there are multiple
		      # definitions, one of which depends on __STDC__ and
		      # the others depend on !__STDC__.
		      if (scalar(@{$macros{$identifier}}) == 1)
			{ # ... expand macro ...;
			  # goto PROCESSLINE;
			}

		      # Case 2: macro that takes a single arg and either
		      # returns it or returns nothing, which can be used to
		      # construct either a K&R or ANSI function declaration
		      # by passing in a parenthesized list as the argument.
		      # "if (is_fun_decl_arg_macro($identifier))" redoes work.
		      if (exists($fun_decl_arg_macros{$identifier}))
			{
			  mdie("shouldn't find fun_decl_arg_macro $identifier");
			  # ... expand macro ...;
			  # For now, hack it.
			  if ($declarator !~ /^$identifier_re$/o)
			    { mdie("can't have pointer or array declarators"); }
			  # print "expanding empty-paren macro from $line";
			  $line = $typespec . " " . $nextchar
			    . substr($remaining, 0, $close_paren_pos-1)
			      . substr($remaining, $close_paren_pos+1);
			  # print "expanded empty-paren macro to $line";
			  goto PROCESSLINE;
			}

		      # If the macro expands to a symbol plus an open paren
		      # (or uses an open paren in its arg or following it):
		      #  * function declaration, or
		      #  * function definition
		      # If the macro expands to an identifier sans open paren:
		      #  * variable definition or declaration
		      # Let's trust that no one would be so perverse as to
		      # do the latter.

		      # We could fall through and consider this a call or
		      # process arguments, etc.

		      # However, if this was really a function definition,
		      # then that makes us to miss the function name, so we
		      # don't know which function we are in, its argument
		      # types, get errors about entering a scope, etc.

		      # If the type specifier itself parses as a type+declarator
		      # and
		      #  * the macro expands to an open paren, or
		      #  * the macro expands to itself, and the arg start with open paren
		      # then

		      # The relevant variables are $typespec $identifier

		      # print "semi=", defined($semi_fun_decl_arg_macros{$identifier}), ", typespec='$typespec', remaining='$remaining'\n";

		      if (defined($semi_fun_decl_arg_macros{$identifier})
			  && ($remaining =~ /^\s*\(/)
			  && ($typespec =~ /^$type_declarator_re$/o))
			{ # Read up to the open brace and replace it all by
			  # a function declaration with no arguments.
			  # Could do a better job here.
			  # We'd better hope this is really a function
			  # definition and not a function declaration!
			  my $success;
			  ($success, $remaining) = get_fulltoken_lines_to('\{', $remaining, 5);
			  if (!defined($remaining))
			    { mdie("Undefined remaining after fulltoken line to \{: $success"); }

			  if (!$success)
			    { parse_error("Didn't find an open brace in time in $remaining"); }
			  else
			    { $line = $typespec . '(){' . $POSTMATCH;
			      # print "replaced masquerading macro: '$line' for '$remaining'\n";
			      goto PROCESSLINE;
			    }
			}
		      # print "rejected macro masquerading as function $identifier\n";
		    }
		  else
		    { # This actually is a valid type specifier and declarator
		      # print "actual valid type specifier and declarator\n  remaining: $remaining\n";
		      my ($type, $identifier) = parse_declarator($typespec, $declarator);

		      # Check indentation.
		      if ($indented
			  && ($symtab_scopes == 0)
			  # accept indented declaration/definition in #if at top scope
			  # (want to reject function defs but not decls; how to do?)
			  && (@current_inclusion_dependenton == 0))
			{
			  # print "potential indentation problem; nextchar '$nextchar', line $line\n";
			  # If a few improperly indented lines containing no braces
			  # are followed by a property unindented line, don't mdie.
			  my $proper_follows = $false;
			  for my $follow (1..7)
			    { my $next = peek_fulltoken_line($follow);
				# What if this is a preprocessor directive or comment?
			      if (!defined($next))
				{ last; }
			      if ($next =~ /^[^\s]/)
				{ $proper_follows = $true;
				  last; }
			      if ($next =~ /[\{\}]/)
				{ last; } }
			  if (!$proper_follows)
			    { parse_error("Indented line at top level ($symtab_scopes scopes, dependenton (@current_inclusion_dependenton), nextchar '$nextchar'):\n $line"); }
			  # print "Overlooked indented line ", current_line_no(), " at top level ($symtab_scopes scopes, dependenton (@current_inclusion_dependenton), nextchar '$nextchar'):\n $line";
			}	# Done checking indentation.

		      # print "found typespec '$typespec' declarator '$declarator' nextchar '$nextchar' remaining '$remaining' on line ", current_line_no(), "\n";

		      # Get the complete declarator, which might span lines.
		      # $nextchar is in [,=;\(]
		      if ($nextchar eq "(")
			{ # print "no semi or brace, so appending a line to $remaining\n";
			  my $success;
			  ($success, $remaining) = get_fulltoken_lines_to('[;\{=]', $remaining, 5);
			  if (!defined($remaining))
			    { mdie("Undefined remaining after fulltoken line to [;\{=: $success"); }
			  if (!$success)
			    # FIX: I have no idea which loop is being nexted.
			    # But it's better than failing later on...
			    { parse_error("Didn't find '[;\{=]' in $remaining");
			      next; }
			  if ($remaining !~ /[;\{=]/) # MUST succeed
			    { mdie("Just succeeded with get_fulltoken_lines_to '[;\{=]': $remaining"); }
			  if ($MATCH eq "=")
			    { # This declares not a function but a variable
			      # (say, a pointer to a function).
			      $nextchar = $MATCH;
			      $remaining = $POSTMATCH;
			      if (!defined($remaining))
				{ mdie("Undefined remaining after `$nextchar'"); }
			      $type .= '(' . $PREMATCH; # is this right?
			    } }
		      my $initializer_contains_include = $false;
		      if (($nextchar eq ",") || ($nextchar eq "="))
			# Only need to check the new stuff, not the whole thing.
			{ while ($remaining !~ /;/)
			    { # print "no semicolon, so appending a line to `$remaining'\n";
			      # Intentionally not get_fulltoken_lines_to
			      my $nextline = get_fulltoken_line($true);
			      if (!$nextline)
				# This could be really bad: I'm sending
				# control somewhere strange.
				{ parse_error("Didn't find semicolon in $remaining");
				  last; }
			      # print "appending `$remaining' `$nextline'\n";
			      $remaining = append_lines($remaining, $nextline);
			      if (!defined($remaining))
				{ mdie("Undefined remaining after appending `$nextline'"); }

			      # Hack: bc-1.03/global.c line 39 does
			      #   CONST char libmath[] =
			      #   #include "libmath.h"
			      #   ;
			      # DO NOT anchor the regexp with ^, because we are
			      # reading a continuation line, so the whole exp
			      # is in $current_raw_fulltoken_line, not just the
			      # bit we just read.  Not sure whether we can
			      # anchor with \n.  Maybe we ought to be able to.
			      if ($current_raw_fulltoken_line =~ /\#\s*include/)
				{ $initializer_contains_include = $true; } } }
		      # print "found complete declarator in $remaining\n";

		      # print "nextchar `$nextchar', remaining `$remaining'\n";
		      if (($nextchar eq "(")
			  && ($remaining =~ /([;\{=])/) # MUST succeed
			  && ($1 ne "="))
			{ $line = process_function_definition_or_declaration($type, $identifier, $remaining);
			  goto PROCESSLINE;
			}
		      else
			{
PROCESSVARDEF:
			  # variable definition or declaration
			  # print "variable definition or declaration <<$identifier>> $type\n";
			  # $nextchar = "," or "=" or ";"
			  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";")))
			    { die "what nextchar? '$nextchar'"; }

			  # "symtab_add($identifier, $type)" should
			  # logically happen here, but hold off in case we
			  # find that we are actually not in a variable
			  # definitiion or declaration, but accidentally
			  # processing the argument list of a function
			  # definition or delcaration.  Unfortunately, this
			  # lookahead only busy avoid one incorrect entry.
			  # Should perhaps mdie in this case.

			  if ($nextchar eq ";")
			    { symtab_add($identifier, $type);
			      $line = $remaining;
			      goto PROCESSLINE; }
			  elsif ($nextchar eq ",")
			    {
ATCOMMA:
			      # $remaining is everything after $nextchar
			      if ($remaining =~ /^\s*$declarator_re\s*([,=;])/o)
				{ # Following this variable declaration is
				  # another variable definition or declarator.
				  # First, add the previous thing.
				  symtab_add($identifier, $type);
				  # Now cope with this one.
				  $declarator = $1;
				  $nextchar = $LAST_PAREN_MATCH;
				  $remaining = $POSTMATCH;
				  if (!defined($remaining))
				    { mdie("Undefined remaining after `$nextchar'"); }
				  ($type, $identifier) = parse_declarator($typespec, $declarator);
				  goto PROCESSVARDEF; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*\(/o)
				# This is a function declaration following
				# a variable declaration or definition.
				# I think this code works; does it?
				{ $line = process_function_definition_or_declaration($type, $identifier, $remaining);
				  goto PROCESSLINE; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*([,\)])/o)
				{ # We're accidentally in the argument list of
				  # a function declarator.
				  # Skip to next brace or semicolon.
				  # fix: need to double-check this.
				  $remaining = $POSTMATCH;
				  if (!defined($remaining))
				    { mdie("Undefined remaining after type declarator"); }
				  if ($remaining =~ /[\{;]/)
				    { if ($MATCH eq ";")
					{ $remaining = $POSTMATCH; }
				      else
					{ $remaining = $MATCH . $POSTMATCH; } }
				  elsif ($remaining =~ /\)/)
				    { $remaining = $POSTMATCH; }
				  else
				    { mdie("No semicolon or brace after function declarator?  It can't be!"); }
				  if (!defined($remaining))
				    { mdie("Undefined remaining after type declarator (2)"); }
				  $line = $remaining;
				  goto PROCESSLINE; }
			      else
				{ # FIX: ghostview-1.5/Draw.c:69 fails this.
				  parse_error("Found '$typespec $declarator' ($nextchar) but no following var in $remaining\n");
				  # Fall through; do no more processing of this
				  # line.
				} }
			  elsif ($nextchar eq "=")
			    { # Skip over an expression and continue processing from there.
			      # print "skipping expression $remaining\n";
			      if ($initializer_contains_include
				  && ($remaining =~ /^\s*;/))
				# Hack for initializer in #included file.
				# Maybe return something of the appropriate type.
				{ $remaining = "0" . $remaining; }
			      my $postexp = skip_expression_nocommaop($remaining);
			      # print "After skip_expression_nocommaop, postexp $postexp\n";

			      if ($postexp eq "")
				{ # do nothing; done with this line, because
				  # parsing of the expression failed
				  parse_error("Failed to parse initializer ",
					      ($initializer_contains_include
					       ? "(has include )" : ""),
					      "$remaining\n"); }
			      elsif ($postexp =~ /^\s*;/)
				{ $line = $POSTMATCH;
				  goto PROCESSLINE; }
			      elsif ($postexp =~ /^\s*,/)
				{ $nextchar = ","; # gratuitous, I think.
				  $remaining = $POSTMATCH;
				  if (!defined($remaining))
				    { mdie("Undefined remaining after `$nextchar'"); }
				  goto ATCOMMA; }
			      else
				# Don't die.  (Eg, flex-2.5.3/FlexLexer.h:70)
				{ parse_error("No comma or semicolon after initializer: '$postexp'"); } }
			  else
			    { mdie("Bad nextchar $nextchar."); } }
		    } }

	      # Maybe add a test here like the special case above.
	      # print "testing indentation of `$line'\n";
	      if ((!$indented)
		  && ($line !~ /^\s*$/)
		  # Hack.   Should really expand it and try again.
		  ## What is this test?
		  && (!(($line =~ /^($identifier_re)\s*\(/o) && defined($macros{$1}))))
		{ parse_error("properly unindented line was never processed: $line"); }

	      # Beginning of line didn't match $type_declarator_re.
	      # Parse it looking for:
	      #  * open and close braces to keep track of scopes
	      #  * open parens, because maybe they indicate a function call
	      #  * semicolon: try over from that point

	      # See r.7.4; extern linkage specifications must be at
	      # file scope but may nest.
	      if ($line =~ /^\s*extern\s*\"\"\s*\{/)
		{ if ($symtab_scopes != 0)
		    { parse_error("extern \"C\" not at top level"); }
		  if ($in_extern_C != 0)
		    { parse_error("extern \"C\" inside extern \"C\""); }
		  $line = $POSTMATCH;
		  $in_extern_C++;
		}
	      elsif ($line =~ /^\s*extern\s*\"\"\s*$/)
		{
		  # extern "C" split over multiple lines
		  my $nextline = get_fulltoken_line($true);
		  if (defined($nextline))
		    { $line = append_lines($line, $nextline);
		      goto PROCESSLINE; }
		}
	      # elsif ($line =~ /^\s*extern\b/)
	      #  { parse_error("found extern, what's up in $line"); }

	      while ($line =~ m/[\({}\"\';]/) #'HACKCOLOR; no /g; $line used in body
		# Found brace, open paren, quote, comment, or semicolon
		{ # print "Found brace, open paren, quote, comment, or semicolon: $MATCH$POSTMATCH\n";
		  my $match = $MATCH;
		  $line = $POSTMATCH;
		  if ($match eq "{")
		    { enter_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq "}")
		    { if (($symtab_scopes == 0) && $in_extern_C)
			{ $in_extern_C--; }
		      else {
			# Maybe abstract this into a subroutine.
			# If we were in a function, we need to save some info.
			if ($symtab_scopes == 1 && defined($current_function)) {
			  # FIX: Here, I would really prefer the ending physical
			  # line, though elsewhere I want the first one.
			  # Need to supply both functions.
			  my $end_line = current_line_no();
			  # update our per-file list of function locations
			  push(@{$files_function_lines[$current_file_number]},
			       ($current_function_start_line,$current_function,
				$end_line));
			  #print STDERR "FN: $current_function $current_file_name [$current_function_start_line,", current_line_no(), "]\n";
			  # update our per-function list of [file,startline,endline]
			  push(@{$function_to_locs{$current_function}},
			       [$current_file_number, $current_function_start_line,
				current_line_no() ] );
			}
			# This comes after the code above because it
			# undefines $current_function.
			exit_scope();
		      }
		      goto PROCESSLINE; }
		  elsif ($match eq ";")
		    { goto PROCESSLINE; }
		  elsif ($match eq "(")
		    { if ($PREMATCH =~ /($identifier_re)\s*$/o)
			{ if (defined($macros{$1}))
			    { # found something that looks like a macro call
			      # process it
			    }
			  else
			    { # found something that looks like a macro call
			      # process it
			    }
			}
		      else
			{ # This paren doesn't represent a function call;
			  # look for another brace, open paren, quote, comment
			}
		    }
		  elsif ($match eq "\"")
		    { if ($line =~ /$non_escaped_double_quote_re/o)
			{ $line = $POSTMATCH; }
		      else
			{ parse_error("Didn't find end of string literal '$line' after '$PREMATCH' in '$current_raw_fulltoken_line'");
			  $line = ""; # fall through
			} }
		  elsif ($match eq "'")
		    { if ($line =~ /^$char_literal_contents_re\'/o)
			{ $line = $POSTMATCH; }
		      else
			{ parse_error("Didn't find end of character literal $line.\n");
			  $line = ""; # fall through
			} }
		  else
		    { mdie("What match '$match' '$line'?"); } }
	    }
	  # done with this line; get another
	}
      if ($in_extern_C != 0)
	{ parse_error("In extern C at end of file.");
	  $in_extern_C = 0; }

      # done with this file; read another
      check_file_boundary();
      # print "closing file $current_file_name\n";
      close(INPUT);
    }
  $cline_simplify_strings = $old_cline_simplify_strings;
}


# Largely lifted from process_macro_calls
sub find_function_declarations ( $ )
{ my ($file) = check_args(1, @_);

  if (!open(INPUT,$file)) {
    # fix: Shouldn't we print to STDERR unconditionally?
    # fix: Add quiet option; then this will occur unless that is set.
    print STDERR "$file -- open failed\n" if $opt_v;
    return; }

  check_file_boundary();
  while ($line = get_fulltoken_line())
    {
      if ($line =~ m/^\s*\#/o)
	{ mdie("get_fulltoken_line shouldn't return preprocessor lines: $line"); }
      if ($line =~ /^\s/)
	{ # indented or empty line; skip (is that the right thing?)
	  next;
	}

      # not empty or a preprocessor line

      # Look for:
      #   typedef,
      #   function definition/declaration (only at symtab_scopes == 0),
      #   variable definition/declaration,
      #   function call (of a macro),
      #   brackets (to keep track of scopes),
      #   not string/char literals (already simplified).
      # These can span multiple lines, especially function definitions.

      $line = simple_macro_substitute($line);

      $line = simple_macro_substitute_2($line);

      # ** Perhaps at this point reinsert the test for declaration split
      # over multiple lines. **

      if (($line =~ /^($type_declarator_re)\s*\(/o)
	  # must check this second, to get "int (*foo) (arg1, arg2)"
	  || ($line =~ /^($identifier_re)\s*\(/o))
	{
	  # We don't know whether we matched $type_declarator_re or
	  # $identifier_re, so rematch, which is wasteful.
	  my $typespec;
	  my $declarator;
	  my $args = "\($POSTMATCH";
	  { my $identifier_or_typedecl = $1;
	    # Do the easy case first here; order doesn't matter.
	    if ($identifier_or_typedecl =~ /^$identifier_re$/o)
	      { # fix: should warn about implicit return type for function.
		$typespec = "((int))";
		$declarator = $identifier_or_typedecl; }
	    elsif ($identifier_or_typedecl =~ /^$type_declarator_re$/o)
	      { $typespec = $1;
		$declarator = $2; }
	    else
	      { mdie("must be identifier or type declarator: $identifier_or_typedecl"); } }
	  if ($debug_type_match)
	    { print "matched type declarator <$typespec><$declarator><(>\n";
	    }

	  # Fallthroughs below depend on the fact that this is the last
	  # clause in the elsif chain: there's nothing else we would
	  # try to do here if we didn't see a type declarator.

	  if (($typespec =~ /$reserved_nontype_word_re/o)
	      || ($declarator =~ /$reserved_nontype_word_re/o))
	    { # "else if (...)", "return foo;", "sizeof(buf)", etc.
	      # print "rejected typespec $typespec\n";
	      next;
	    }

	  if (exists($macros{$declarator})
	      # Skip macros that can't be active right now.
	      && macro_active($declarator, [ @current_inclusion_dependenton ])
	      && (!((scalar(@{$macros{$declarator}}) == 1)
		    && ($mdef_body_simple[$macros{$declarator}[0]] =~ /^$identifier_re\s*\Q$mdef_formals[$macros{$declarator}[0]]\E/)))
	      )
	    { # The function being defined is actually a macro.
	      # Try to expand it, else fall through.
	      # print "find_function_declarations: macro masquerading as declarator $declarator\n";

## All this is in simple_macro_substitute_2 now.
# 	      if (scalar(@{$macros{$declarator}}) > 1)
# 		{ next; }
# 
# 	      my $mdef_index = $macros{$declarator}[0];
# 
# 	      my @formals;
# 	      { my $formals = $mdef_formals[$mdef_index];
# 		# if macro takes no arguments, skip
# 		if (!$formals)
# 		  { next; }
# 		@formals = formals_array($formals); }
# 
# 	      my $close_pos = find_close_delimiter('(', $args, 1);
# 	      if (!$close_pos)
# 		{ print "couldn't find close paren for macro invocation $declarator $args";
# 		  next; }
# 	      my @actuals = actuals_array(substr($args, $close_pos));
# 
# 	      if (scalar(@formals) != scalar(@actuals))
# 		{ mdie("formals-actuals mismatch: <<" . join(",", @formals)
# 		       . ">> <<" . join(",", @actuals) . ">>"); }
# 	      my $result = $mdef_body_simple[$mdef_index];
# 	      for my $i (0 .. $#formals)
# 		{ $result =~ s/\b$formals[$i]\b/$actuals[$i]/g; }
# 
# 	      print "Expanded $
# 
# 
# 	      die "implement expansion";

	    }

	  # This actually is a valid type specifier and declarator
	  my ($type, $identifier) = parse_declarator($typespec, $declarator);

	  if (defined($functions{$identifier}))
	    { $functions{$identifier} .= ";" . input_fileno_and_line(); }
	  else
	    { $functions{$identifier} = input_fileno_and_line(); }

	}
      # done with this line; get another
    }
  check_file_boundary();
  # print "closing file $current_file_name\n";
  close(INPUT);
}


# This should perhaps do more:  substitute for macros with only one definition,
# or those that expand to either nothing or a keyword like const, etc.
sub simple_macro_substitute ( $ )
{ my ($text) = check_args(1, @_);

  # Using "for" instead of foreach gives me 'Use of "" without parens is ambiguous'!
  for my $fdmacro (keys %fun_decl_arg_macros)
    { if ($text =~ /\b$fdmacro\s*\(/)	# no /o
	{ my $prematch = $PREMATCH;
	  my $postmatch = $POSTMATCH;
	  # print "Found fun_decl_arg_macro $fdmacro in $text\n";
	  my $close_paren_pos;
	  ($close_paren_pos, $postmatch) = find_close_paren_read($postmatch);
	  # print "close paren at $close_paren_pos in $postmatch\n";
	  my $result = $prematch . substr($postmatch, 0, $close_paren_pos)
	    . substr($postmatch, $close_paren_pos+1);
	  # print "simple_macro_substitute $text\n ===> $result\n";
	  return $result; } }
  return $text;
}


# If the first element is a macro call, then expand it.
sub simple_macro_substitute_2 ( $ )
{ my ($text) = check_args(1, @_);

  if ($text !~ /^($identifier_re)\s*\(/)
    { return $text; }

  # print "simple_macro_substitute_2: ", add_newline($text);

  $text =~ /^($identifier_re)\s*\(/; # is this necessary?
  my $name = $1;
  my $args = "\($POSTMATCH";
  if (!(exists($macros{$name})
      # Skip macros that can't be active right now.
      && macro_active($name, [ @current_inclusion_dependenton ])
      && (!((scalar(@{$macros{$name}}) == 1)
	    && ($mdef_body_simple[$macros{$name}[0]] =~ /^$identifier_re\s*\Q$mdef_formals[$macros{$name}[0]]\E/)))
      ))
    { return $text; }

  if (!defined($macros{$name}))
    { mdie("Undefined macros{$name}"); }

  if (scalar(@{$macros{$name}}) == 0)
    { return $text; }
  if (scalar(@{$macros{$name}}) > 1)
    { return $text; }

  my $mdef_index = $macros{$name}[0];

  if ($mdef_index eq "")
    { mdie("Empty index for $name, while processing $text"); }
  if (!defined($mdef_formals[$mdef_index]))
    { mdie("Undefined formals for $name, def \#$mdef_index, while processing $text"); }

  if (!$mdef_formals[$mdef_index])
    # Or, put the body before the actuals.
    { return $text; }

  my @formals = formals_array($mdef_formals[$mdef_index]);

  my $close_pos = find_close_delimiter('(', $args, 1);
  if (!$close_pos)
    { parse_error("couldn't find close paren for macro invocation $name $args\n");
      return $text; }
  my @actuals = actuals_array(substr($args, 0, $close_pos+1));

  if (scalar(@formals) != scalar(@actuals))
    { parse_error("formals-actuals mismatch for $name, def \#$mdef_index, while processing $text\n" . scalar(@formals) . "<<" . join(",", @formals)
	   . ">> " . scalar(@actuals) . "<<" . join(",", @actuals) . ">>\nbody: $mdef_formals[$mdef_index] $mdef_body[$mdef_index]");
      return $text; }

  my $result = $mdef_body_simple[$mdef_index];
  for my $i (0 .. $#formals)
    { $result =~ s/\b$formals[$i]\b/$actuals[$i]/g; }

  # print "Expanded ", add_newline($text), "to ", add_newline($result);

  return $result;
}


# Returns the remaining line to reprocess.  (Is that enough?)
sub process_function_definition_or_declaration ( $$$ )
{
  my ($type, $identifier, $remaining) = check_args(3, @_);
  if ($debug_parse_function)
    { print "process_fun_def_or_decl $type $identifier (", exists($macros{$identifier}), add_newline(") $remaining\n"); }

  # found (start of) function definition or prototype
  # Only need to check the new stuff, not the whole thing.

  my $success;
  # Should this really be find_matching_paren?  Probably...
  # Also stop at brace.
  ($success, $remaining) = get_fulltoken_lines_to('\)', $remaining, 5);
  if (!$success)
    { parse_error("Didn't find close paren in $remaining");
      return ""; }
  # print "found function $identifier; remaining $remaining\n";
  # Process the args:  create the scope, eat the following open brace, etc.
  # $remaining includes everything after the original open paren.
  # Three possibilities:
  #   function declaration (K&R or ANSI)
  #   K&R-style function definition
  #   ANSI-style function definition
  my @arg_decls;
  { ($success, $remaining, @arg_decls) = parse_function_decl_args($remaining);
    # print "parse_function_decl_args => ", join(', ', @arg_decls), "; remaining = $remaining\n";
    if (!defined($remaining))
      { mdie("parse_function_decl_args result 2 undefined ", $#arg_decls+1, "args => @arg_decls"); }
    # Do something here before returning?
    if (!$success)
      # What is getting returned?  The whole original thing?
      { return $remaining; } }
  # $remaining is what follows the close paren
  if ($remaining !~ /[;\{=]/)
    { # print "no semi or brace, so appending a line to $remaining\n";
      parse_error("Shouldn't have to read more lines in process_fun_def_or_decl: $remaining");
      return ""; }

  # @arg_{names,types} will be set from arg_decls when we know whether this
  # was a def or decl.  They're used only to enter information in the
  # symbol table and are not returned.
  my @arg_names;
  my @arg_types;
  # $remaining is nonempty; if first character is
  # semicolon or comma, then this is a declaration, else a definition
  if ($remaining =~ /^\s*[;,]/)
    { # declaration
      # gzip-1.2.4/sample/sub.c line 51 puts a prototype in scope 1.
      if ($symtab_scopes != 0)
	{ # Print to EVIL, maybe.
	  # print "Function definition or prototype $MATCH at bracedepth $symtab_scopes.\n";
	}

      # FIX: enter this in the global symbol table.  (Defer?)
      # set @arg_{names,types}; arg_decls is a list of
      # strings, each a type or a type declarator
      for my $i (0..$#arg_decls)
	{ my $decl = $arg_decls[$i];
	  if ($decl =~ /^$type_re_special$/o)
	    { # Like $type_re, but this must precede $type_declarator_re
	      # and $type_re must follow it.
	      $arg_types[$i] = parse_type($decl);
	      # leave $arg_names[$i] undefined
	    }
	  elsif ($decl =~ /^$type_declarator_re$/o)
	    { my $type_specifier = $1;
	      my $declarator = $2;
	      ($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
	  elsif ($decl =~ /^$type_declarator_re\s*\(/o)
	    { my $type_specifier = $1;
	      my $declarator = $2;
	      my $args = '(' . $POSTMATCH;
	      # FIX: HACK! Need parse_declarator_function, maybe, or just
	      # make parse_declarator able to cope.
	      ($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator);
	      $arg_types[$i] .= '(' . $args; }
	  elsif ($decl =~ /^$type_re$/o)
	    { $arg_types[$i] = parse_type($decl);
	      # leave $arg_names[$i] undefined
	    }
	  elsif ($decl =~ /^\.\.\.$/)
	    { $arg_types[$i] = $decl;
	      $arg_names[$i] = "UNNAMED_REST_ARG"; }
	  else
	    { # We add to @arg_decls only things parsed as one of the above.
	      parse_error("Can't parse as type or type declarator: '$decl'\n  special = $type_re_special");
	      $arg_types[$i] = $typeINT;
	      $arg_names[$i] = "Couldn't parse";
	    } }
      if ($remaining =~ /^\s*;/)
	{ $remaining = $POSTMATCH; }
      elsif ($remaining =~ /^\s*,/)
	{ $remaining = $type . " " . $POSTMATCH; }
      else
	{ mdie("Couldn't find semicolon or comma I just found in $remaining"); }
    }
  # function definition
  elsif (defined($current_function))
    { parse_error("Function definition for $identifier in function $current_function starting at line $current_function_start_line");
      # Now just return $remaining and hope for the best.
    }
  else
    {
      # print "found function definition $identifier; remaining $remaining\n";

      # exit_scope makes these undefined.
      # $current_function_start_line may get set earlier, if we see a split
      # declaration/definition (that's a bit gross).
      # Perhaps check that it is already set.
      $current_function = $identifier;

      # FIX: Why subtract 1 here?  Is this right??
      if (!defined($current_function_start_line))
	{ $current_function_start_line = current_line_no() - 1; }
      if ($symtab_scopes != 0)
	{ parse_error("Function definition at bracedepth $symtab_scopes.\n");
	  # Is this the right thing to do?
	  return $remaining;
	}
      elsif ($remaining =~ /^\s*\{/)
	{ # ANSI-style definition
	  $remaining = $POSTMATCH;

	  # print "ANSI-style function definition for $identifier: ", scalar(@arg_decls), " args", (@arg_decls > 0 ? ": @arg_decls" : ""), "\n";

	  # set @arg_{names,types}; arg_decls is a list of identifiers
	  for my $i (0..$#arg_decls)
	    { my $decl = $arg_decls[$i];
	      if ($decl =~ /^$identifier_re$/o)
		{ $arg_names[$i] = $decl;
		  # Is this at all the right thing to do???
		  # Leave $arg_types[$i] undefined; will be filled in later.
		}
	      elsif ($decl =~ /^$type_declarator_re$/o)
		{ my $type_specifier = $1;
		  my $declarator = $2;
		  ($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
	      # A function, with arguments
	      elsif ($decl =~ /^$type_declarator_arglist_re$/o)
		{ my $type_specifier = $1;
		  my $declarator = $2;
		  my $arglist = $3;
		  my ($type, $name) = parse_declarator($type_specifier, $declarator);
		  $arg_types[$i] = $type . $arglist;
		  $arg_names[$i] = $name;
		}
	      elsif ($decl eq "...")
		{ if ($i != $#arg_decls)
		    { parse_error("Should only find '...' as last declarator");
		      $arg_types[$i] = $typeFAIL;
		      $arg_names[$i] = "early ellipsis"; }
		  # FIX.
		  # Don't do anything; arg_{names,types} will be smaller
		  # than @arg_decls, for we are ignoring the rest argument(s).
		}
	      else
		{ # FIX: BAD BAD BAD!  Need to deal with this!
		  # eg, Python-1.4/Modules/socketmodule.c:307
		  # mdie("Can't parse as identifier or type declarator: '$decl'");
		  parse_error("Can't parse as identifier or type declarator: '$decl'");
		  # Just set the argument name.
		  # Is this at all the right thing to do???
		  $arg_names[$i] = $decl;  } }
	}
      elsif ($remaining =~ /^\s*=/)
	{ # This wasn't a function definition at all!  It was a declaration of
	  # a variable of type pointer to function (or some such).
	  # fix: this isn't the whole remaining.  Save the original argument
	  # in a different variable, so it can be referred to later.
	  parse_error("Parsed pointer to function as function: $type $identifier $remaining");
	  return $remaining;
	}
      else
	{ # K&R-style definition
	  # Must have an argument: zero arguments => parsed as ANSI-style.
	  if (!($remaining =~ /^\s*$type_declarator_re\s*([,;])/o))
	    { if (($remaining =~ /^\s*($identifier_re)/o)
		  && exists($macros{$1}))
		{ parse_error("Skipping macro $1 masquerading as K&R argument declarator");
		  $remaining = $POSTMATCH; }
	      else
		{ parse_error("Didn't find first type+declarator in K&R-style $remaining");
		  # Something went wrong; I have no idea what.
		}
	      # Now fall through; below looks for open brace.
	      # Or maybe find the open brace here...
	    }

	  # set @arg_{names,types}; arg_decls is a list of
	  # strings, each an identifier or a type declarator
	  for my $i (0..$#arg_decls)
	    { my $decl = $arg_decls[$i];
	      if ($decl !~ /^$identifier_re$/o)
		{ parse_error("K&R-style function definition ('$type' '$identifier'), but non-identifier arg declarator $decl");
		  return $remaining; }
	      $arg_names[$i] = $decl;
	      # leave $arg_types[$i] undefined
	    }

	  # Ought to make sure we don't see anything we really shouldn't;
	  # for instance, don't read all the way to some random open brace.
	  # Maybe only read while $remaining is empty....

	  # Only need to check the new stuff, not the whole thing.
	  my $success;
	  ($success, $remaining) = get_fulltoken_lines_to('\{', $remaining, 5);
	  if (!$success)
	    { parse_error("Didn't find open brace: $remaining");
	      return(""); }
	  my %argnametype;
	  ($remaining, %argnametype) = parse_KandR_function_arg_decls($remaining);
	  # Make sure that the argument list matches the declarators

	  if ($debug_parse_function)
	    { print "parse_KandR_function_arg_decls returned\n";
	      my $key;
	      my $value;
	      while (($key, $value) = each %argnametype)
		{ print "  $key=$value\n"; }
	      print " remaining $remaining\n"; }

	  { foreach my $i (0..$#arg_names)
	      { # print "arg names: ", @arg_names, "\narg types: ", @arg_types, "\n";
		my $thistype = $argnametype{$arg_names[$i]};
		if (!defined($thistype))
		  { parse_error("No K&R-style declarator for $arg_names[$i]\n");
		    $thistype = $typeFAIL; }
		$arg_types[$i] = $thistype;
		delete $argnametype{$arg_names[$i]};
	      }
	    # argnametype should be empty now
	    for my $name (keys %argnametype)
	      { parse_error("K&R-style declarator, but no argument, for $name $argnametype{$name}"); }
	  }
	}
      # print "Done parsing function definition to open brace\n";

      # function definition: $remaining is everything after
      # the open brace, and @arg_names and @arg_types are set.
      # Two things to do:
      #  1. add function's type to the global symbol table
      #  2. enter a scope

      # 1. Add function's type to the global symbol table.  Actually, this
      # should be easy since we are at global scope now.  Perhaps have
      # separate tables for guesses and for what we know for sure.  We'll
      # have declarations for everything but macros.  Watch out that it
      # isn't already in the global symbol table (make sure it is
      # compatible if so).

      # FIX: to be done.  (Write a function to do all that, and call it for
      # declarations, too.)

      # 2. enter a scope
      enter_scope();
      for my $i (0..$#arg_names)
	{ my $name = $arg_names[$i];
	  my $type = $arg_types[$i];
	  # FIX: This happens at Python-1.4/Modules/socketmodule.c:228.
	  # Why isn't it getting caught as a macro masquerading as a function?
	  if (!defined($name))
	    { parse_error("Undefined arg $i name in $identifier"); }
	  if (!defined($type))
	    { parse_error("Undefined type for "
			  . (defined($name) ? "$name (arg $i)" : "arg $i")
			  . " in $identifier, using int");
	      $type = $typeINT;
	    }
	  if (defined($name) && defined($type))
	    { symtab_add($name, $type); } }

      # Done with function definition
    }

  if (defined($functions{$identifier}))
    { $functions{$identifier} .= ";" . input_fileno_and_line(); }
  else
    { $functions{$identifier} = input_fileno_and_line(); }

  # We just coped with a function definition or declaration.
  # Process the rest of the line (if def, this is anything
  # after the open brace).
  return $remaining;
}


# Returns the remaining string, or the empty string if failure.
# This is actually for skipping initializers.
sub skip_expression_nocommaop ( $ )
{
  my ($input) = check_args(1, @_);
  my ($type, $remaining);

  # print "skipping expression $input\n";

  if ($input =~ /^\s*\{/)
    { my $post_open_brace = $POSTMATCH;
      ($type, $remaining) = parse_array_initializer($post_open_brace);
      if ($debug_parse_array_init)
	{ print "parse_array_initializer('$post_open_brace') => '" . type_name($type) . "' '$remaining'\n"; }
      if ($type eq $typeFAIL)
	{ parse_error("skip_expression_nocommaop: parse_array_initializer failed, remaining = $remaining\n");
	  # just skip it -- don't use $input, which has an open that
	  # find_close_paren_read doesn't expect.
	  $type = $typeUNKNOWN;
	  my ($close_brace_pos, $expanded_input) = find_close_brace_read($post_open_brace);
	  $remaining = substr($expanded_input, $close_brace_pos+1);
	  if ($debug_parse_array_init)
	    { print "failed to parse array init, found close brace before $remaining\n"; }
	}
      # print "parse_array_initializer returned $type $remaining\n";
    }
  else
    { ($type, $remaining) = parse_exp_nocommaop($input, "ignore types"); }

  if (!$type)
    { parse_error("No type for initializer $remaining");
      return "";
    }
  else
    { # Don't return the empty string; that indicates failure
      if ($remaining eq "")
	{ $remaining = " "; }
      return $remaining; }
}


###########################################################################
### Symbol table
###

# FIX: Improve the representation of the symbol table
# The symbol table is two parallel arrays:
my @symtab_identifiers = ();
my @symtab_types = ();
# $scopemarker in the @identifiers array indicates a scope boundary
my $scopemarker = "scope marker";	# contains space, as no real variable can

# Perhaps have a different structure (an associative array?) for the global
# level and only use this for nested scopes.


sub show_symtab ( $ )
{
  my ($text) = check_args(1, @_);
  if ($#symtab_identifiers != $#symtab_types)
    { mdie("symtab_identifiers and symtab_types arrays have different lengths ($#symtab_identifiers != $#symtab_types)"); }
  print "{SYMBOL TABLE $text at line ", current_line_no(), ":\n";
  # perhaps print out in opposite direction
  for (my $i = $#symtab_identifiers; $i >= 0; $i--)
    { if ($symtab_identifiers[$i] eq $scopemarker)
	{ print " --------\n"; }
      else
	{ print " ", $symtab_identifiers[$i], "\t", type_name($symtab_types[$i]), "\n"; } }
  print "}\n";
}

sub enter_scope ( )
{
  check_args(0, @_);
  push(@symtab_identifiers, $scopemarker);
  push(@symtab_types, 0);
  $symtab_scopes++;
  if ($debug_scopes) { show_symtab("entered scope $symtab_scopes"); }
}

sub exit_scope ( )
{
  check_args(0, @_);
  if ($debug_scopes) { show_symtab("exiting scope $symtab_scopes"); }
  if (@symtab_identifiers == 0)
    { parse_error("exit_scope: not in scope (empty symtab_identifiers array)");
      return; }
  while ($scopemarker ne pop(@symtab_identifiers))
    { pop(@symtab_types);
      if (@symtab_identifiers == 0)
	{ parse_error("exit_scope: not in scope (no scopemarker)");
	  return; } }
  pop(@symtab_types);
  # It's possible that ($#symtab_identifiers == -1), if global scope is empty.
  if ($debug_scopes) { show_symtab("exited scope $symtab_scopes"); }
  $symtab_scopes--;
  if ($symtab_scopes == 0) {
    undef $current_function;
    undef $current_function_start_line;
  }
}

# sub symtab_scopes
# {
#   check_args(0, @_);
#   my $result = 1;
#   for my $id (@symtab_identifiers)
#     { if ($id eq $scopemarker)
# 	{ $result++; } }
#   return $result;
# }

sub symtab_add ( $$ )
{
  my ($identifier, $type) = check_args(2, @_);
  push (@symtab_identifiers, $identifier);
  push (@symtab_types, $type);
}

sub symtab_lookup ( $ )
{
  my ($var) = check_args(1, @_);
  for (my $i = $#symtab_identifiers; $i >= 0; $i--)
    { if ($var eq $symtab_identifiers[$i])
	{ return $symtab_types[$i]; } }
  return $typeFAIL;
}



###########################################################################
### Check and categorize macros
###

# Need a routine that assigns a type to a literal.
# (Useful for turning macros into const variables.)

# Takes macro name as argument; categorizes each of the macro's definitions
sub categorize_macro_name ( $ )
{ my ($name) = check_args(1, @_);
  if (defined($mntype{$name}))
    { return; }
  if (!defined($macros{$name}))
    { # We called this on a non-macro (we try for every name in a macro body).
      # Note that accessing $macros{$name}[0] ends up adding $name to the
      # hash %macros, even though the value is undefined.
      return; }
  my $numdefs = $#{$macros{$name}} + 1;
  # if the assertion below gets tripped, it's likely that
  # somewhere we're mistakenly adding to %macros unintentionally
  mdie("numdefs not defined for $name") if !defined($numdefs);
  # Use this block instead to help debug the above problem
  #if (!defined($numdefs)) {
  #  print STDERR "numdefs not defined for $name\n";
  #  delete $macros{$name};
  #  return;
  #}

  # Fix: should also get value here.

  if ($debug_categorize_macro)
    { print "Categorize macro name $name\n"; }

  # Categorize each definition body.
  for (my $i = 0; $i < $numdefs; $i++)
    { my $mdef_index = $macros{$name}[$i];
      if (!defined($mdef_category[$mdef_index]))
	{ categorize_macro_def($mdef_index); }
      # Type may be undefined; it's ingored for some categories.
      if (!defined($mdef_category[$mdef_index]))
	{ mdie("Undefined category (type $mdef_type[$mdef_index]): $i $mdef_index $mdef_name[$mdef_index] $mdef_formals[$mdef_index] $mdef_body[$mdef_index]"); } }

  if ($debug_categorize_macro)
    { my @cat_and_type = ();
      for (my $i = 0; $i < $numdefs; $i++)
	{ my $mdef_index = $macros{$name}[$i];
	  my $this_type = $mdef_type[$mdef_index];
	  push(@cat_and_type,
	       $mdef_category[$mdef_index]
	       . (defined($this_type) ? "(" . type_name($this_type) . ")" : "")); }
      # No newline yet.
      print "categorize_macro_name $name: (", join("; ", @cat_and_type), ")"; }

  # Collect the categorizations
  # Fix: this isn't quite right; rather than two literal categorizations
  # resulting in another literal categorizations, they should go to "some
  # constant" unless the values are identical.
  my $type;
  my $category;
  if ($numdefs == 0)
    { if ($debug_categorize_macro)
	{ print "No definitions for macro $name\n"; }
      $category = $catNO_DEF;
      $type = $typeNODEF; }
  else
    { $category = $mdef_category[$macros{$name}[0]];
      $type = $mdef_type[$macros{$name}[0]];
      for (my $i = 1; $i < $numdefs; $i++)
	{ my $mdef_index = $macros{$name}[$i];
	  if ($debug_categorize_macro)
	    { print "examining def $i of $name (index $mdef_index) = $mdef_body[$mdef_index]\n"; }
	  $category = category_lub($category, $mdef_category[$mdef_index]);
	  ## Not right if a NO_DEF or NULL_DEFINE category is ingored
	  # Type is allowed to be undefined; it's ignored for some categories.
	  # if ((!defined($type)) || (!defined($mdef_type[$mdef_index])))
	  #   { $type = undef; }
	  if (!defined($type))
	    { $type = $mdef_type[$mdef_index]; }
	  elsif (!defined($mdef_type[$mdef_index]))
	    # leave $type unmodified
	    { }
	  else
	    { $type = type_lub($type, $mdef_type[$mdef_index]); }
	}
    }


  if ($debug_categorize_macro)
    { # This finishes off the line we started printing above
      print " => $category",
            (defined($type) ? "(" . type_name($type) . ")" : ""),
            "\n"; }

  $mncategory{$name} = $category;
  $mntype{$name} = $type;
}


# Takes index into macro arrays as argument
sub categorize_macro_def ( $ )
{ my ($index) = check_args(1, @_);

  if ($debug_categorize_macro)
    { print "Categorizing $index $mdef_name[$index]$mdef_formals[$index] $mdef_body[$index]\n  simple:$mdef_body_simple[$index]\n  from $files[$mdef_fileno[$index]]\n"; }

  if ($mdef_fileno[$index] eq $built_in_fake_fileno)
    { mdie("Trying to categorize built-in."); }

  if (defined($mdef_category[$index]))
    { if ($debug_categorize_macro)
	{ print "Already categorized! $mdef_category[$index] $categoryname[$mdef_category[$index]]\n"; }
      return; }
  # Avoid recursive call even if possible loop in macro definitions.
  $mdef_category[$index] = $catIN_PROCESS;

  my $body = $mdef_body_simple[$index];
  if (!defined($body))
    { mdie("mdef_body_simple[$index] undefined. ($mdef_body[$index])"); }
  if ($body =~ /^\s+/)
    { mdie("leading space in body: $body"); }
  $fDebugCommentRemoval && print STDERR "body = '$mdef_body[$index]'\nbody_simple = '$body'\n";

  # Rename formals which are reserved words; only happens twice in suite.
  for my $arg (formals_array($mdef_formals[$index]))
    { if ($arg =~ /^$reserved_word_re$/o)
	{ # No need for quoting: any reserved word is an identifier.
	  # Bizarre substitution because "${arg}_" looks like close brace to Emacs
	  $body =~ s/\b$arg\b/$arg . "_"/ge; # no /o
	} }

  # Fix: are these special cases better done in parse_expression?
  my $category;
  my $type;
  if ($body eq "")
    # Null define
    { # print "Null define $mdef_name[$index]: '$body'\n";
      $category = $catNULL_DEFINE; }
  elsif ($body =~ /^[\(\);, .\*\?]+$/)
    # Easy test, so it appears early
    { $category = $catPUNCTUATION; }
  elsif ((($body =~ /^\{\s*$reserved_nontype_word_re/o)
	  && ($body =~ /\}\s*$/))
	 || (($body =~ /^\{/)
	     && ($body =~ /;\s*\}\s*$/)))
    # Statement in braces; this is also easy, so test it early.
    # More sophisticated statement tests come later.
    # (open brace plus reserved word; ends with close brace);
    # avoid miscategorizing array initialization.  This isn't really
    # adequate yet.
    { $category = $catSTATEMENT; }
  ### Literals
  elsif ($body =~ /^($string_literal_re\s*)+$/o)
    # String
    { # print "found string";
      $category = $catLITERAL;
      $type = $typeSTRING; }
  elsif (($body =~ /^($float_literal_whole_re|$float_literal_frac_re|float_literal_exp_re|float_literal_noexp_re)$/o)
	 || ($body =~ /^\(($float_literal_whole_re|$float_literal_frac_re|float_literal_exp_re|float_literal_noexp_re)\)$/o))
    { $category = $catLITERAL;
      $type = $typeFLOAT; }
  elsif (($body =~ /^-?($hex_literal_re|$dec_oct_literal_re)$/o)
	 || ($body =~ /^\(-?($hex_literal_re|$dec_oct_literal_re)\)$/o))
    { $category = $catLITERAL;
      $type = infer_int_type($body); }
  elsif ($body =~ /^$char_literal_re$/o)
    { $category = $catLITERAL;
      $type = $typeCHAR; }
  elsif ( # like $type_re, but unconditional suffix
	 ($body =~ /^$type_specifier_re$type_suffix_re+$/o)
	 # precedes the below because struct, union are reserved type words
	 || ($body =~ /^(struct|union)\s*$identifier_re$/o)
	 || ($body =~ /^($reserved_type_word_re[ \t\*\[\]]*)+$/o))
    { $category = $catTYPE; }
  elsif ($body =~ /^$identifier_re$/o)
    # Body is a single identifier
    { if ($body =~ /^$reserved_nontype_word_re$/o)
	{ $category = $catRESERVED_WORD; }
      elsif ($body =~ /^$reserved_type_word_re$/)
	{ $category = $catPARTIAL_TYPE; }
      elsif (exists($functions{$body}))
	{ $category = $catFUNCTION_NAME; }
      elsif (exists($typedefs{$body}))
	{ $category = $catTYPE; }
      elsif (exists($macros{$body}))
	{ categorize_macro_name($body);
	  $category = $mncategory{$body};
	  $type = $mntype{$body}; }
      elsif (grep(/^\Q$body\E$/, $mdef_formals[$index]))
	# Expands to one of its arguments
	{ $category = $catFAILURE; }
      else
	{ $category = $catSYMBOL_UNKNOWN; } }
  # FIX: elements of $body may be ordinary symbols, if they expand to macros
  # with definitions in $catCOMMAND_LINE.
  elsif (($body =~ /^(-\w[a-zA-Z0-9_.,\/]*([= ][a-zA-Z0-9_.,\/]*)?\s*)+$/)
	 || ($body =~ /^(\/$identifier_re)+$/) # pathname (didn't used to have ^$; why?)
	 || ($body =~ /^[-_a-zA-Z0-9]+\.[os]$/)	# .o or .s filename
	 || ($body =~ /\$[\(\{]/) # use of "$()" or "${}"
	 )
    { $category = $catCOMMAND_LINE; }
  elsif (contains_mismatch($body))
    { $category = $catUNBALANCED; }
  # Not caught by previous tests, so an expression, statement, or failure.
  else {
    if ($debug_categorize_macro)
      { print "Falling back on parse_expression\n"; }
    my $remaining;
    reset_parse_vars();
    local $commaop = $true;
    ($type, $remaining) = parse_expression($body);
    if ($debug_categorize_macro)
      { print "parse_expression called by categorize_macro_def returned\n  type = $type; remaining = $remaining\n"; }
    # $type was ($type != $typeFAIL)
    if ($type && ($remaining =~ /^\s*$/))
      # Expression
      # Fix: I'm not sure how correct any of this is.
      { if ($type =~ /^category: /)
	  # Not an expression after all.
	  # This happens when the expression is a macro (or a macro appears
	  # in the argument, though I doublt the "category: ..." type often
	  # bubbles to the outside in that situation.  So probably this is
	  # largely extraneous.
	  { $category = $POSTMATCH; }
	elsif ($body =~ /^$constant_exp_re$/o)
	  # This is wrong; it considers (1 << ((x)-1))
	  # constant because that matches $constant_exp_re.
	  # FIX: instead, check each word against being a literal
	  # (or a macro which is a constant).
	  { $category = $catSOME_CONSTANT; }
	else
	  { $category = $catEXP; }
      }
    elsif ($type && ($remaining =~ /^\s*;\s*$/))
      # Expression plus semicolon = statement
      { $category = $catSTATEMENT; }
    # Not an expression; try statements
    else
      { my $stmt_remaining;
	if ($debug_categorize_macro)
	  { print "Falling back on parse_statements\n"; }
	($category, $stmt_remaining) = parse_statements($body);
	if ($debug_categorize_macro)
	  { print "parse_statements called by categorize_macro_def returned\n  category = $category; remaining = $stmt_remaining\n"; }
	if ($stmt_remaining !~ /^\s*$/)
	  { if ($body =~ /^(__)?asm(__)?/)
	      { $category = $catASSEMBLY_CODE; }
	    elsif ($body =~ /^$identifier_re(\s+$identifier_re)*$/)
	      { if ($body =~ /$reserved_type_word_re/)
		  { $category = $catDECLARATION_SANS_SEMI; }
		else
		  { $category = $catSYMBOLS; } }
	    else
	      # try parsing as declaration
	      {
		if ($debug_categorize_macro)
		  { print "Falling back on parse_declarations\n"; }
		my ($decl_remaining, $warnings, %nametype) = parse_declarations($body);
		if ($debug_parse_declaration)
		  { if (scalar(@$warnings) == 0)
		      { print "parse_declarations: no warnings\n"; }
		    else
		      { print "parse_declarations warnings:\n";
			map {print "  $_\n";} @$warnings; }
		    print "parse_declarations remaining: '$decl_remaining'\n"; }
		if (($decl_remaining =~ /^\s*$/) && (scalar(@$warnings) == 0))
		  { $category = $catDECLARATION; }
		else
		  # add semicolon and try parsing as declaration
		  {
		    if ($debug_categorize_macro)
		      { print "Adding semicolon and falling back on parse_declarations\n"; }
		    my ($decl_remaining, $warnings, %nametype) = parse_declarations("$body;");
		    if ($debug_parse_declaration)
		      { if (scalar(@$warnings) == 0)
			  { print "parse_declarations: no warnings\n"; }
			else
			  { print "parse_declarations warnings:\n";
			    map {print "  $_\n";} @$warnings; }
			print "parse_declarations remaining: '$decl_remaining'\n"; }
		    if (($decl_remaining =~ /^\s*$/) && (scalar(@$warnings) == 0))
		      { $category = $catDECLARATION_SANS_SEMI; }
		    else
		      { $category = $catFAILURE; } } } } }
  }


  { #HACKINDENT
    $mdef_category[$index] = $category;
    $mdef_properties[$index] = get_macro_properties($index);

    $mdef_type[$index] = $type;
    # track our histogram of categories
    update_categories_for($category,$mdef_fileno[$index]);
    #print STDERR "$mdef_name[$index] in $files[$mdef_fileno[$index]], type ", compute_ftype_index($mdef_fileno[$index]), "\n";

    if ($debug_categorize_macro)
      { print "categorize_macro_def ($index: $mdef_name[$index]): $categoryname[$category]",
	    (defined($type) ? "(" . type_name($type) . ")" : ""),
	    ": $body\n"; }
  }
}


sub get_macro_properties ( $ )
{ my ($index) = check_args(1, @_);

  my $result = $propNONE;
  my $body = $mdef_body_simple[$index];


  # Use of $parse_exp_saw_equals is more exact when it's an expression.
  # no: == != <= >=
  # yes: = += -= *= /= %= <<= >>= &= ^= |=; ($body =~ /(<<|>>|[-+*\/%&^|])=/)
  # yes: ++ --
  if (($body =~ /(<<|>>)=|\+\+|--/) || ($body =~ /[^!<>=]=[^=]/))
    { $result |= $propASSIGN; }

  if (($body =~ /,\s*$builtin_type_re\s*[,\)]/o)
      || ($body =~ /\(\s*$builtin_type_re\s*(\)$|,)/o)
      || ($body =~ /,\s*($type_re\s*$type_suffix_re+)\s*[,\)]/o) # ends with *: pointer
      || ($body =~ /\(\s*($type_re\s*$type_suffix_re+)\s*(\)$|,)/o)
      || ($body =~ /,\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*[,\)]/o) # identifier ending with _t
      || ($body =~ /\(\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*(\)$|,)/o))
    { $result |= $propPASSES_TYPE_AS_ARG; }

  if ($body =~ /^\b(__)?asm(__)?\b$/)
    { $result |= $propASSEMBLY_CODE; }

  if ($body =~ /\#\#/)
    { $result |= $propPASTING; }
  # Not clearly the right place for this...  In fact, certainly wrong.  FIX.
  # This list from GNU C preprocessor manual
  # It's not complete, since #assert introduces new preprocessor commands.
  if ($body =~ /(^|\n)\s*\#\s*(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|system|unassert|warning)\b/)
    { evilprint("illegal: preprocessor directive \#$MATCH in macro body:\n    $mdef_body[$index]\n"); }
  if ($body =~ /[^\#]\#[^\#]/)
    { $result |= $propSTRINGIZE; }

  if ($body =~ /(^|[^\$])\b\Q$mdef_name[$index]\E\b($|[^\$])/)	# no /o
    # The checks for abutting "$" are necessary because Perl doesn't treat
    # it as a word constituent.
    { $result |= $propSELF_REFERENTIAL; }


  # It looks like the below stuff requires results from parse_expression,
  # so doesn't work on statements (right)?

  # Check whether a macro argument was used as a type.
  foreach my $arg (formals_array($mdef_formals[$index]))
    { delete $parsevars{$arg};
      if (defined($parsetypes{$arg}))
	{ $result |= $propUSES_ARG_AS_TYPE; }
      delete $parsefuns{$arg}; }

  ## This isn't really INVOKES_MACRO, but "something that looks like a
  ## function call in an expression is actually a macro invocation."
  ## That's not interesting, so comment it out for the time being.
  #   # Assume the functions and types are well-defined if not macros
  #   # If they are macros, should check 'em, not just fail.
  #   foreach my $fun (keys %parsefuns)
  #     { if (defined $macros{$fun})
  # 	# This is actually fine most of the time; fix later.
  # 	{ $result |= $propINVOKES_MACRO; } }

  foreach my $type (keys %parsetypes)
    { if (defined($macros{$type}))
	# This may be fine; fix later.
	{ $result |= $propUSES_MACRO_AS_TYPE; } }

  ## Free variables: new implementation.
  { my %vars = ();
    if ($body !~ /^$identifier_re$/o) # if body is a symbol, never report free vars
      { foreach my $var (identifiers_in($body))
	  { $vars{$var} = $true; }
	foreach my $arg (formals_array($mdef_formals[$index]))
	  { delete $vars{$arg}; }
	foreach my $var (keys %vars)
	  { if (exists($macros{$var})
		|| exists($macros_used_by_cpp{$var})
		|| exists($functions{$var})
		|| exists($typedefs{$var})
		|| ($var =~ /^$reserved_word_re$/)
		|| ($body =~ /(\.|->|\bstruct|\bunion)\s*$var\b/)
		|| ($body =~ /\b\Q$var\E\s*(\*\s*)+\)/)
		|| ($body =~ /\b\Q$var\E\s*\(/))
	      { delete $vars{$var}; } }
	if (scalar(keys %vars) > 0)
	  { my $body_remaining = $body;
	    while ($body_remaining =~ /\{/)
	      { my ($post_decls, $warnings, %name_types) = parse_declarations($POSTMATCH);
		$body_remaining = $post_decls;
		for my $local_var (keys %name_types)
		  { delete $vars{$local_var};
		    for my $var (keys %vars)
		      { if ($name_types{$local_var} =~ /\b$var\b/) # no /o
			  { delete $vars{$var}; } } } } } }

    $mdef_free_vars[$index] = join(",", keys %vars);
    if ($mdef_free_vars[$index])
      { $result |= $propFREE_VAR; } }

  ## Free variables: old implementation.
  #   # For each free variable, check its type.
  #   foreach my $var (keys %mdef_freevars)
  #     { # print "examining free var $var ($mdef_name[$index])\n";
  #       if (defined($macros{$var}))
  # 	{ my $varclass;
  # 	  foreach my $i (@{$macros{$var}})
  # 	    { if ($mdef_category[$i] == $catNOT_YET)
  # 		{ categorize_macro_def($i); }
  # 	      if (!defined($varclass))
  # 		{ $varclass = $mdef_category[$i]; }
  # 	      elsif ((($mdef_category[$i] == $catLITERAL)
  # 		      || ($mdef_category[$i] == $catCONSTANT)
  # 		      || ($mdef_category[$i] == $catSOME_CONSTANT))
  # 		     && (($varclass == $catLITERAL)
  # 			 || ($varclass == $catCONSTANT)
  # 			 || ($varclass == $catSOME_CONSTANT)))
  # 		{ $varclass = $catSOME_CONSTANT; }
  # 	      elsif ($varclass != $mdef_category[$i])
  # 		{ $category = $catFAILURE;
  # 		  goto CATEGORIZED; }
  # 	      else
  # 		# fix: not sure what would get us here.
  # 		# (Never saw this error message yet...)
  # 		{ mdie("Huh?"); } }
  # 	  if (!(($varclass == $catLITERAL)
  # 		|| ($varclass == $catCONSTANT)
  # 		|| ($varclass == $catSOME_CONSTANT)))
  # 	    # Is this right?
  # 	    { $category = $catFAILURE; # should be more specific here
  # 	      goto CATEGORIZED; } }
  #       else
  # 	# This is a free variable.  Should check whether it is a global
  # 	# (which would be OK; a local would be bad).
  # 	{ $result = $propFREE_VAR; # should be more specific here
  # 	  goto CATEGORIZED; }
  #     }

  return $result;
}


# Return true for a macro that takes a single arg and either returns it or
# returns only open and close parens, which can be used to construct either
# a K&R or ANSI function declaration by passing in a parenthesized list as
# the argument.
sub is_fun_decl_arg_macro ( $ )
{ my ($identifier) = check_args(1, @_);

#  print STDERR "is_fun_decl_arg_macro: $identifier $#{$macros{$identifier}} ", join(', ',(map {$mdef_formals[$macros{$identifier}[$_]]} (0..$#{$macros{$identifier}}))), "\n";

  # don't require only 2 definitions-- require > 1 and
  # check that all definitions
  # return either the single arg or "()"
  # __P in /usr/include/{sys/cdefs,ctype}.h is defined 5 times

  if (!exists $macros{$identifier})
    { mdie("is_fun_decl_arg_macro: $identifier"); }
  if (!defined($macros{$identifier}))
    { die "\$macros{" . $identifier . "} not defined"; }

  # MNFIX: use @m_i = @{$macros{$identifier}}, to reduce repetitivity
  my $cMacroDefs = $#{$macros{$identifier}} + 1;

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs <= 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_just_parens = $false;
  my $one_expanded_to_itself = $false;

  foreach my $i (0..($cMacroDefs-1)) {
    if (!defined($macros{$identifier}[$i])) {
      die "\$macros{" . $identifier . "} not defined, cMacroDefs = $cMacroDefs";
    }
    if (!defined($mdef_formals[$macros{$identifier}[$i]])) {
      die "mdef_formals of \$macros{" . $identifier . "}[$i] not defined";
    }
    if (count_macro_args($mdef_formals[$macros{$identifier}[$i]]) != 1) {
      #      print STDERR "=> false1 at $i\n";
      return $false;
    }
    my $args = $mdef_formals[$macros{$identifier}[$i]];
    my $body = $mdef_body_simple[$macros{$identifier}[$i]];

    my $expands_to_just_parens = $false;
    my $expands_to_itself = $false;
    # Can't be $body ne "()" because there might be space between the parens.
    if ($body =~ /^\(\s*\)$/) {
      $expands_to_just_parens = $true;
      $one_expanded_to_just_parens = $true;
    } elsif (($body =~ /^$identifier_re$/o)
	     && ($args =~ /^\(\s*\Q$body\E\s*\)$/)) { # no /o in regexp match
      $expands_to_itself = $true;
      $one_expanded_to_itself = $true;
    }

    #    if ($body !~ /\(\s*\)/ && $args !~ /^\(\s*\Q$body\E\s*\)$/ ) {
    if (!$expands_to_just_parens && !$expands_to_itself) {
      #      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
      return $false;
    }

  }
#  print STDERR "=> true\n";

  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_itself && $one_expanded_to_just_parens) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}

# Return true for a macro that takes a single arg and either returns it or
# returns only an open paren.  See bc-1.03/dc.h line 35.
sub is_semi_fun_decl_arg_macro ( $ )
{ my ($identifier) = check_args(1, @_);

#  print STDERR "is_fun_decl_arg_macro: $identifier $#{$macros{$identifier}} ", join(', ',(map {$mdef_formals[$macros{$identifier}[$_]]} (0..$#{$macros{$identifier}}))), "\n";

  # don't require only 2 definitions-- require > 1 and
  # check that all definitions
  # return either the single arg or "()"
  # __P in /usr/include/{sys/cdefs,ctype}.h is defined 5 times

  die "is_fun_decl_arg_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use @m_i = @{$macros{$identifier}}
  my $cMacroDefs = @{$macros{$identifier}} + 1;

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_just_paren = $false;
  my $one_expanded_to_itself = $false;

  foreach my $i (0..$#{$macros{$identifier}}) {
    if (count_macro_args($mdef_formals[$macros{$identifier}[$i]]) != 1) {
#      print STDERR "=> false1 at $i\n";
      return $false;
    }
    my $args = $mdef_formals[$macros{$identifier}[$i]];
    my $body = $mdef_body_simple[$macros{$identifier}[$i]];

    my $expands_to_just_paren = $false;
    my $expands_to_itself = $false;
    # Perhaps this test is overly strict.
    if ($body eq "\(") {
      $expands_to_just_paren = $true;
      $one_expanded_to_just_paren = $true;
    } elsif ($args =~ /^\(\s*\Q$body\E\s*\)$/) { # no /o in regexp match
      $expands_to_itself = $true;
      $one_expanded_to_itself = $true;
    }

#    if ($body !~ /\(\s*\)/ && $args !~ /^\(\s*\Q$body\E\s*\)$/ ) {
    if (!$expands_to_just_paren && !$expands_to_itself) {
#      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
      return $false;
    }

  }
#  print STDERR "=> true\n";

  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_itself && $one_expanded_to_just_paren) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}


# Return true for a non-function macro that expands to either nothing or "void".
sub is_void_macro ( $ )
{ my ($identifier) = check_args(1, @_);

  die "is_void_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use @m_i = @{$macros{$identifier}}
  my $cMacroDefs = $#{$macros{$identifier}} + 1;

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_empty = $false;
  my $one_expanded_to_void = $false;

  foreach my $i (0..$#{$macros{$identifier}}) {
    my $args = $mdef_formals[$macros{$identifier}[$i]];
    my $body = $mdef_body_simple[$macros{$identifier}[$i]];

    if ($args ne "") {
      #      print STDERR "=> false1 at $i\n";
      return $false;
    }

    my $expands_to_empty = $false;
    my $expands_to_void = $false;
    if ($body eq "") {
      $expands_to_empty = $true;
      $one_expanded_to_empty = $true;
    } elsif ($body eq "void") {
      $expands_to_void = $true;
      $one_expanded_to_void = $true;
    }

    if (!$expands_to_empty && !$expands_to_void) {
#      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
      return $false;
    }

  }
#  print STDERR "=> true\n";

  # Actually, this isn't necessary here.
  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_empty && $one_expanded_to_void) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}


###########################################################################
### Miscellaneous
###

# just return the current file and line number as a string
sub input_file_and_line ( )
{
  check_args(0, @_);
  return "$current_file_name:" . current_line_no();
}

# Like input_file_and_line, but terser (though less user-friendly)
sub input_fileno_and_line ( )
{
  check_args(0, @_);
  return "$current_file_number:" . current_line_no();
}

# Like die, but with file and line number prefix.  Do NOT redefine this so
# that it doesn't die -- this is for dying.  If you don't want to die, call
# something that doesn't necessarily die, like parse_error.  Do not use
# regular die; this should have all the same functionality and more.

# This only adds input_file_and_line; is it now gratuitous?
sub mdie ( $@ ) {
  my (@msg) = check_args_at_least(1, @_);
  # Could use croak instead.
  my ($file,$line) = (caller)[1,2];
  print STDERR "$file:$line ",
      # (defined($current_function) ? "function $current_function " : ""),
      "on ", input_file_and_line(), ": ", @msg, "\n";
  exit -1;
}

# Perhaps make this die/mdie when debugging.
sub parse_error ( $@ )
{
  my (@msg) = check_args_at_least(1, @_);
  my ($file,$line) = (caller)[1,2];
  my $message = "$file:$line on " . input_file_and_line() . ": @msg\n";
  $message =~ s/\n+\n$/\n/;
  if ($opt_p) { print STDERR $message; }
  print PARSE_ERRS $message;
  return;
}


# Print a message to the EVIL stream, with file and line number prefix
sub evilprint ( $@ ) {
  my (@msg) = check_args_at_least(1, @_);
  print EVIL input_file_and_line(), ": ", @msg;
  return;
}

sub current_line_no ( ) {
  check_args(0, @_);
  if (!$categorizing_macros) {
    return int($. - cline_ungot_phys_lines());
  } else {
    return $current_macro_line_number;
  }
}


# Should be replaced by uses of c-files-listing or better heuristics.
# sub forbidden_file ( $ )
# { my ($filename) = check_args(1, @_);
#   # bash/machines.h is for use by the makefile, not C code
#   # /usr/include/linux/linkage.h is assembly, not C code
#   # glibc/asm-syntax.h and glibc/sysdep.h are assembly, not C code
#   # print "Checking '$filename'\n";
#   if ($filename eq "/usr/include/linux/linkage.h") {
#     return $true;
#   }
#   #FIX: This should use a package name, not $opt_d
#   if (!defined($opt_d)) {
#     return $false;
#   }
#   if ((($opt_d =~ /bash/) && ($filename eq "./machines.h"))
#       || (($opt_d =~ /gawk/) && ($filename eq "./config/solaris2.cc"))
#       || (($opt_d =~ /glibc/) && (($filename =~ /\/asm-syntax\.h$/)
# 				  || ($filename =~ /\/sysdep\.h$/)))) {
#     return $true;
#   }
# }


# Return the index into the @ftype_ arrays for the current filename.
# Consider how it was included, and whether it's a header or code.
sub compute_ftype_index ( $ ) {
  my ($fileno) = check_args(1, @_);
  my $filename = $files[$fileno];
  if (!defined($filename))
    { die "No name for file number $fileno"; }

  my $offset = file_is_header($filename) ? $ftype_HEADER_Start : $ftype_NONHEADER_Start;

  die "compute_ftype_index can't determine an index for inclusion method $file_inclusion_method[$fileno]"
    if !exists $InclusionMethod_to_Index{$file_inclusion_method[$fileno]};

#  print STDERR "CFI: $offset,", $InclusionMethod_to_Index{$file_inclusion_method[$fileno]}, "\n";

  return $offset + $InclusionMethod_to_Index{$file_inclusion_method[$fileno]};
}


# Tell us if the current file was added by a #include directive
# (as opposed to passed in to evilmacros on the cmd line or in STDIN w/ -i )
sub file_was_included ( $ ) {
  my ($fileno) = check_args(1, @_);
  my $inclusion_method = $file_inclusion_method[$fileno];
  if (!defined($inclusion_method))
    { die "No inclusion method for file #$fileno"; }
  if ($file_inclusion_method[$fileno] =~ /^FromInclude/)
    { return $true; }
  return $false;
}

# Tell if the current filename looks like a header file
sub file_is_header ( $ ) {
  my ($filename) = check_args(1, @_);
  if ($filename =~ /.[hH].?.?$/) { return $true; }
#  print STDERR "FIH: failed for \"$filename\"\n";
  return $false;
}

# Initialize the lists of hashes
# for each filetype.
# This is done so that the outputs across all files
# has the same columns, and none missing
sub initialize_lists_of_hashes ( ) {
  check_args(0, @_);
  # print "initialize lists of hashes\n";
  foreach my $i (0..$c_ftype-1) {
    foreach my $j (keys %cppcmdcount) {
      $rg_cppcmdcounts[$i]->{$j} = 0;
    }
    foreach my $j (@categoryname) {
      $rg_category_counts[$i]->{$j} = 0;
    }
    foreach my $j (0..$#cond_category_name) {
      $rg_ccd_cat_counts[$i][$j] = 0;
    }
  }
}


# FIXGJB: Put these in the correct lists; each should only appear once, probably.

# Initialize the macros structures for the builtin macros of gcc
# FIX: Should generalize so that it works for non-gcc compilers
# This list is not necessarily comprehensive even for gcc
# I got it with:
# uni,p1:~/macros% strings /usr/lib/gcc-lib/i486-linux/2.7.2/cpp | grep __ | more
sub initialize_builtin_macros ( ) {
  check_args(0, @_);
  # The standard defines __LINE__ __STDC__ __STDC_VERSION__ __FILE__ __DATE__
  # __TIME__.  __STDC__ is undefined or has a nonzero value.
  # __STDC_VERSION__ is 199409L if implementation complies with Amendment 1.

  # The blank lines in the qw() constructs below separate "standard"
  # builtins from gcc builtins; perhaps make this nicer.
  my @num_def_macros = (
    qw(__LINE__ __STDC_VERSION__

       __BASE_FILE__ __IMMEDIATE_PREFIX__ __INCLUDE_LEVEL__ __OBJC__
       __PTRDIFF_TYPE__ __REGISTER_PREFIX__ __SIZE_TYPE__
       __USER_LABEL_PREFIX__ __VERSION__ __WCHAR_TYPE__ ) );

  my @string_def_macros = (
    qw(__DATE__ __FILE__ __TIME__

       __BASE_FILE__ __VERSION__ __SIZE_TYPE__ __PTRDIFF_TYPE__
       __WCHAR_TYPE__ __DATE__ ) );

  my @empty_def_macros = ( qw(__STDC__

			      __OBJC__ ) );

  foreach my $mac (@empty_def_macros) {
#       my $i = introduce_builtin_mdef($mac);
#       $mdef_body[$i] = " /* Fake built-in null define */";
#       $mdef_body_noc[$i] = "";
#       $mdef_body_simple[$i] = "";
    $mncategory{$mac} = $catNULL_DEFINE;
    $mntype{$mac} = $typeUNSPECIFIED;
    $macros_used_by_cpp{$mac} = "builtin_empty_def";
  }

  foreach my $mac (@string_def_macros) {
#       my $i = introduce_builtin_mdef($mac);
#       $mdef_body[$i] = "\"\" /* Fake built-in string */";
#       $mdef_body_noc[$i] = "\"\"";
#       $mdef_body_simple[$i] = "\"\"";
    $mncategory{$mac} = $catLITERAL;
    $mntype{$mac} = $typeSTRING;
    $macros_used_by_cpp{$mac} = "builtin_string_def";
  }

  foreach my $mac (@num_def_macros) {
#       my $i = introduce_builtin_mdef($mac);
#       $mdef_body[$i] = "1 /* Fake built-in number */";
#       $mdef_body_noc[$i] = "1";
#       $mdef_body_simple[$i] = "1";
    $mncategory{$mac} = $catLITERAL;
    # This isn't quite right; some are long, some float.
    $mntype{$mac} = $typeINT;
    $macros_used_by_cpp{$mac} = "builtin_num_def";
  }

  # This works:
  # print "HERE:", join(',',@$macros{"__LINE__"}), "\n";

#   $cMacrosInTables = $cBuiltinMacros;

  return;
}

# analyze_for_macro_use($spliced_line)
# looks for macros in $spliced_line (which is simplified) and saves the file,line#

# These are macro expansions, not mere uses/appearances:  we don't count the
# argument to #undef, for instance.

# This won't be quite right since we currently don't look through
# include-s in order.  Note that this is still subject to differences
# from the actual parse by cpp, since not all files are included by
# all files, but we work with a global (to the project) macro
# definitions list.
#
# We can do better by ensuring that before we count a macro usage,
# double check to make sure the current file includes a (or is the)
# file which defines the macro (and if it is the file, then make sure
# that the macro was defined on an earlier line number than we're at).
# (That's not quite enough; maybe this is included by a file that
# previously included the file that defines the macro.  We really need
# to read files in order...)
# 
# None of this is done for now, but probably should be later.
# Currently, we err on the side of reporting too many uses of macros.

# This runs on the second pass only.

# Note: another possible way to do (some of?) this is with
# ~gjb/bin/share/make-include-for-defs-file.
sub analyze_for_macro_use ( $ ) {
  my ($line) = check_args(1, @_);

  # print "analyze_for_macro_use ($cline_simplify_strings): ", ($line ? $line : "\n");

  if ($finding_macro_defs)
    { die "Shouldn't be analyzing for macro use when finding defs!"; }

  if ($line =~ /^\s*$/)
    { return; }

  # study $line;  # use this if you're gonna do lots of pattern matches


  my $macro_uses_index = $i_usage_code;
  my $cpp_defining_macro_name;

  # Old version (but some CPPs permit whitespace before "#"):
  # if (substr($line,0,1) eq "#") {
  #   $line =~ s/^\#\s*//;

  if ($line =~ s/^\s*\#\s*//) {
    $macro_uses_index = $i_usage_cond;
    if ($line =~ /^define\s+($identifier_re)/o)
      { $cpp_defining_macro_name = $1;
	#print STDERR "Defining $cpp_defining_macro_name\n";
	# Don't report the macro being defined unless it calls itself recursively
	# (in the body), which is legal in the current standard.
	$line = $POSTMATCH;
	$macro_uses_index = $i_usage_macro; }
    elsif ($line =~ /^undef\b/)
      { return; }
    elsif ($line =~ /^(if(n?def)?|elif)?\b/)
      { my $restofline = $POSTMATCH;
	# print STDERR "Got $line\n";
	if ($line =~ /^ifndef\s+($identifier_re)\s*$/ ||
	    $line =~ /^if\s+!\s*defined\s*\(\s*($identifier_re)\s*\)\s*$/) {
	  my $macro_not_defined = $1;
	  my $simplified_line = peek_fulltoken_line(1);
	  # print STDERR "Got $simplified_line\n";
	  if ($simplified_line =~ m/^\s*\#\s*define\s+\Q$macro_not_defined\E[\s\(\n]/) {
	    my $better_be_endif = peek_fulltoken_line(2);
	    if ($better_be_endif =~ m/^\s*\#\s*endif\s*$/) {
	      $macro_uses_index = $i_usage_cond_redef;
	    }
	  }
	}
	$line = $restofline;
      }
    else
      { # Let all the others default to "in conditional" also.
	# Perhaps macros can't expand anywhere else except in #include.
	# In that case, it would be safe to just return (after adding
	# the case to check for #include(_next)? and #import).
      }
  }

  # Use local hashes to avoid counting a controlling macro twice
  my %incl_deps = ();
  my %exp_deps = ();

  foreach my $word (macros_in($line)) {
    # Need to remember:
    #  * that this macro was used on a code line, or not
    #  * that the macro was used on a preprocessor line, or not
    #  * that the macro was used in the current function, if any
    #  * that the macro was used globally, if it wasn't in a function
    # FIX: do we want to include information about a macro's expansion
    # including another macro?  (like dependent-macros)

    $macros_uses{$word}[$macro_uses_index]++;

    # Store the fact that $word is expanded in the expansion
    # of $cpp_defining_macro_name.
    if (defined($cpp_defining_macro_name)) {
	my $mi = mindex_from_name_file_line($cpp_defining_macro_name,
					    $current_file_number,
					    current_line_no());
	push @{$mdef_direct_expansion_uses[$mi]}, $word;
	# print STDERR "Macro $cpp_defining_macro_name expands to something with $word-- using index $mi\n";
    }
    push @{$macros_file_line_uses{$word}}, ($current_file_number,current_line_no());

    $exp_deps{$word} = $true;
    foreach my $incl_dep (keys %{$macro_inclusion_dependenton{$word}})
      { $incl_deps{$incl_dep} = $true; }
    foreach my $exp_dep (keys %{$macro_expansion_dependenton{$word}})
      { $exp_deps{$exp_dep} = $true; }
  }

  #   if ($debug_dependences)
  #     { print "$current_file_name:",current_line_no(),":\n";
  #       print "  incl_dep: ", join(" ",(keys %incl_deps)), "\n";
  #       print "  exp_dep: ", join(" ",(keys %incl_deps)), "\n"; }

  foreach my $incl_dep_phrase (@current_inclusion_dependenton)
    { # This work is redone for every inclusion dependence of every line.  Bad!
      foreach my $word (macros_in($incl_dep_phrase))
	{ $incl_deps{$word} = $true;
	  if ($debug_dependences)
	    { print "processing macro use $word; ",
  	        join(" ", keys %{$macro_inclusion_dependenton{$word}}), ";",
	        join(" ", keys %{$macro_expansion_dependenton{$word}}), "\n"; }
	  foreach my $incl_dep (keys %{$macro_inclusion_dependenton{$word}})
	    { $incl_deps{$incl_dep} = $true; }
	  foreach my $exp_dep (keys %{$macro_expansion_dependenton{$word}})
	    { $incl_deps{$exp_dep} = $true; } } }

  if ($debug_dependences)
    { print "$current_file_name:",current_line_no(),": ", add_newline($line);
      print "  incl_dep: ", join(" ",(keys %incl_deps)), "\n";
      print "  file_incl_dep: @{$file_inclusion_dependent_macros{$current_file_name}}\n";
      print "  exp_dep: ", join(" ",(keys %exp_deps)), "\n"; }

  foreach my $file_incl_dep (@{$file_inclusion_dependent_macros{$current_file_name}})
    { $incl_deps{$file_incl_dep} = $true; }

  # Now %incl_deps and %exp_deps are set for this line; for each such
  # controller, increment its global count.
  my %either_deps = ();
  foreach my $incl_dep (keys %incl_deps)
    { $inclusion_dependee_lines{$incl_dep}++;
      $either_deps{$incl_dep} = $true; }
  foreach my $exp_dep (keys %exp_deps)
    { $expansion_dependee_lines{$exp_dep}++;
      $either_deps{$exp_dep} = $true; }
  foreach my $either_dep (keys %either_deps)
    { $either_dependee_lines{$either_dep}++; }

  my $num_incl_deps = scalar(keys %incl_deps);
  my $num_exp_deps = scalar(keys %exp_deps);
  my $num_either_deps = scalar(keys %either_deps);
  $incl_dependence_count[$num_incl_deps]++;
  $exp_dependence_count[$num_exp_deps]++;
  $either_dependence_count[$num_either_deps]++;
  if (defined($opt_L) && ($num_either_deps > $opt_L))
    { print LARGE_DEPEND input_file_and_line(), ": dependences incl=$num_incl_deps; exp=$num_exp_deps; either=$num_either_deps\n";
      print LARGE_DEPEND add_newline($line); }
}

# Note that "words" include literal numbers, etc.
sub words_in ( $ )
{
  my ($text) = check_args(1, @_);
  # \W+ is probably more efficient than \b for the split criterion.
  # Without this, we can get an empty first component.
  $text =~ s/^\W+//;
  # \W+ in place of char class is wrong:  $ may appear in identifier.
  return split(/[^a-zA-Z0-9_\$]+/,$text);
}

sub identifiers_in ( $ )
{
  my ($text) = check_args(1, @_);
  return grep { $_ =~ /$identifier_re/o } words_in($text);
}

# This may not be quite right, but it works well enough
sub possible_macro_names_in ( $ )
{
  my ($text) = check_args(1, @_);
  return grep { $_ ne "defined" } identifiers_in($text);
}


sub macros_in ( $ )
{
  my ($text) = check_args(1, @_);
  if ($finding_macro_defs) {
    warn "subroutine macros_in is used on first pass";
  }
  # I suspect that words_in is more efficient than identifiers_in, here.
  return grep { defined($macros{$_}) } words_in($text);
}


# cached values for which_function
# FIXPERL: perhaps we can simulate static function variables
# by putting functions that need them after a "package" declaration
# to change their scope.  We might then need to access globals explicitly,
# but it could be worth it-- definitely if we move to separate files
my $wf_last_fileno = -1;
my $wf_last_line_no = -1;
my $wf_last_index = -1;

# Note: which_function can only be used after a complete second parse
# if you want to be sure you get things right
# use the $files_function_lines[$fileno] list to find what function we're in,
# if any
sub which_function ( $$ ) {
  my ($fileno, $line_no) = check_args(2, @_);

  if (!defined($files[$fileno]))
    { die "Bad file number $fileno"; }

  my $i = 0;

  my $listref = $files_function_lines[$fileno];
  if (!defined($listref))
    { die "Didn't find listref for file#$fileno, $files[$fileno]"; }

  # FIXPERL: what is the implementation of lists? vector or linked-list?
  # FIXPERL: any way to do c-style static lexical variables?
  if ($fileno == $wf_last_fileno &&
      $line_no >= $wf_last_line_no) {
    # we're moving forward in the same file, so use our old $wf_last_index
    $i=$wf_last_index;
  }

  # $$listref[i] is starting line of function,
  # $$listref[i+1] is name of function w/ leading "{"
  # $$listref[i+2] is ending line of function,
  # $$listref[i+3] is the information for the next function linearly

  # so if $line_no is between $$listref[i] and $$listref[i+2], inclusively,
  # we return $$listref[i+1]

  # first step through the list to the interesting case

  if (!defined($listref)) {
    print STDERR "no function information for $files[$fileno] (file#$fileno), $line_no";
    return;
  }

  if ($#{$listref} < $[ || $line_no < $$listref[0]) {
    return;
  }

  while ( $i <= $#{$listref} && $line_no > $$listref[$i]) {
    # print STDERR "Looking at fn $$listref[$i+1] ($$listref[$i],$$listref[$i+2]) for line $line_no in $files[$fileno]\n";
    $i += 3;
    }

  if ($i >= 3) {
    $i -= 3;
  }

  # three possibilities:
  # 1) $i > $#{$listref} => return undef, since it's past all the fns listed
  # 2) $line_no is in the range $$listref[$i] thru $$listref[$i+2] (inclusive),
  #      so return $$listref[$i+1]
  # 3) $line_no > $$listref[$i] => return undef since we're past the line we want

  my $fn_name;			# starts out undefined

  if ($line_no >= $$listref[$i] && $line_no <= $$listref[$i+2]) {
    $fn_name = $$listref[$i+1];
  } elsif ($line_no > $$listref[$i+2]) {
    # undef
  } elsif ($line_no < $$listref[$i]) {
    # undef
  } else {
    die "Uexpected case in which_function: file#$fileno $files[$fileno]:$line_no, @$listref[$i,$i+2]:\
$i $#{$listref}\n";
  }

  ($wf_last_fileno, $wf_last_line_no) = ($fileno,$line_no);
  $wf_last_index = $i;

  return $fn_name;
}


sub compute_macros_used_in_functions ( ) {
  check_args(0, @_);

  my ($macro,$uses_ref);

  while ( ($macro,$uses_ref) = each %macros_file_line_uses) {
    # FIX: this is a bit of a hack; we need to empty the cache
    # when we start looking at a different macro's uses, since
    # we can't just continue from our last point if the use
    # happens to be in the same file
    $wf_last_fileno = -1;
    # print STDERR "Handling $macro\n";
    for (my $i = 0; $i+1 <= $#{$uses_ref}; $i+=2 ) {
      my ($fileno,$line) = @{$uses_ref}[$i,$i+1];
      my $function_name = which_function($fileno,$line);
      my $function_id;
      if ($function_name) {
	$function_id = "$fileno:$function_name";
      } else {
	$function_name = "%global%";
	$function_id = "$fileno:%global%";
      }
      # print STDERR "USEIN: $function_name\n";
      push @{$macros_used_in_functions{$macro}}, $function_id;
      push @{$function_name_to_macros_it_uses{$function_id}}, $macro;
    }
  }
}

# return the index into the @mdef_XXX arrays for the macro definition described
sub mindex_from_name_file_line ( $$$ ) {
  my ($name,$fileno,$line) = check_args(3, @_);

  foreach my $mindex (@{$macros{$name}}) {
    my $c_phys_lines = $mdef_physical_lines[$mindex];
    my $first_phys_line = $mdef_line[$mindex];

    #if ($name eq "NEXTBYTE" || $name eq "NLENGTH") {
    #  print STDERR "l,c,f: $line,$c_phys_lines,$first_phys_line\n";
    #}

    #FIX: I'm not convinced about why it needs to be $first_phys_line-1
    if ($mdef_fileno[$mindex] eq $fileno &&
	($line >= $first_phys_line-1 && $line <= $first_phys_line + $c_phys_lines)) {
      return $mindex;
    }
  }

  die "couldn't find mindex for $name file#$fileno=$files[$fileno] $line";

  return;
}



###########################################################################
### data structure ops for orthogonal file types
###

sub update_cpp_directive_counts ( $ ) {
  my ($cpp_cmd) = check_args(1, @_);

  #FIXPERL: emacs cperl mode requires the space between $ and { below
  #to correctly not parse the { as an open block

  # This code avoids warnings about using uninitialized values
  no strict 'refs';  #FIX: Must I do this?

  if (!defined($cppcmdcount{$cpp_cmd})) {
    print STDERR "Warning: Uncounted %OTHER% directive: $cpp_cmd for $current_ftype_index\n";
    $cpp_cmd = "%OTHER%";
  }
  $rg_cppcmdcounts[$current_ftype_index]->{$cpp_cmd}++;

  $rg_cpp_cmds[$current_ftype_index]++;
  #print STDERR "GOTCPP: $cpp_cmd, for $current_ftype_index, so have $rg_cpp_cmds[$current_ftype_index]\n";
}

# Increment the count of times a macro definition was categorized as (say)
# statement for files of a particular type; see $rg_category_counts.
sub update_categories_for ( $$ ) {
  # second argument is the file (index) that we're updating the category
  # for; we use it to compute the ftype_index that is used to index
  # into rg_category_counts
  my ($catnumber,$fileno) = check_args(2, @_);
  my $category = $categoryname[$catnumber];
  my $ftype_index = compute_ftype_index($fileno);

  if (!defined($rg_category_counts[$current_ftype_index]->{$category})) {
    print "$current_ftype_index\n";
    print "$category\n";
    print "$rg_category_counts[$current_ftype_index]\n";
    print "$rg_category_counts[$current_ftype_index]->{$category}\n";
    die "Does this happen?";
    $rg_category_counts[$ftype_index]->{$category} = 0;
  }
  $rg_category_counts[$ftype_index]->{$category}++;

  if ($debug_categorize_macro)
    { print STDERR "CAT: $category got incremented -- now is ",
        $ {$rg_category_counts[$ftype_index]}{$category}, "\n"; }
}


###########################################################################
### #include handling
###


# FIX: Should optionally query system for the path
# With gcc, this means compiling a minimal program with gcc -v -c
# and parsing the output.
sub get_include_path ( ) {
  check_args(0, @_);
  @include_path = (
		   # Platform-independent
		   "/usr/local/include",
		   # Linux
		   "/usr/local/.contrib/gcc-2.7.2/i586-unknown-linux/include",
		   "/usr/local/.contrib/gcc-2.7.2/lib/gcc-lib/i586-unknown-linux/2.7.2/include",
		   # Platform-independent
		   "/usr/include",
		   "/usr/X11/include",
		   "/homes/gws/gjb/include",
		   "/uns/include",
		   "/uns/include/openwindows",  # for workman, which needs xview 3.2
		   # Solaris
		   "/usr/local/sparc-sun-solaris2.5/include",
		   "/usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2.f.1/include",
#FIX: Should I include "."?  If so, then we have to be careful about
# multiple inclusions of header files in the project, since they will
# by pushed onto @files, and also exist in @files already (w/o complete
# pathname) from stdin
#		   ".",
		  );
  if ($opt_n)
    { $opt_n =~ s/\/$//;	# remove trailing slash
      my @custom_include_path = map { $opt_n . $_ } @include_path;
      @include_path = (@custom_include_path, @include_path); }

  return;
}

sub look_in_path_for_filename ( $ ) {
  my ($file) = check_args(1, @_);

  my $complete_file_try;
  my $complete_file = undef;
  foreach my $dir (@include_path) {
    $complete_file_try = "$dir/$file";
    if (-f $complete_file_try) {
      $complete_file = $complete_file_try;
      last;
    }
  }
  return $complete_file
}


sub CPathComponentsOfFile ( $ ) {
  my ($fname) = check_args(1,@_);
  $fname =~ s%/%/%g;
}

# fix: If $system is true, look first for system include file.
# Otherwise, look in package and system directories.
# Search through @include_path's directories and find the first
# directory that has $file in it.
sub complete_include_pathname ( $$$ ) {
  my ($file, $system, $curr_name) = check_args(3, @_);
  my $dirname = dirname($curr_name);
  my $local_name;
  if ($file =~ m%^/%) {
    $local_name = $file;
  } else {
    $local_name = "$dirname/$file";
    $local_name = simplify_path_name($local_name);
  }


  my $complete_file = undef;
  # NOTE: this is just like a if (!$system) block, below; only
  # one or the other gets run, depending on whether include was <> or ""
  if ($system) {
    $complete_file = look_in_path_for_filename( $file );
    if (defined($complete_file)) {
      return ($false,$complete_file);
    }
  }

  # This doesn't actually check the local directory on the theory that the
  # file should have been included on the standard input.
  #DBG print STDERR "Trying $local_name...";
  # test was (scalar(grep($_ eq $local_name, @files)) != 0)
  if (exists($file_numbers{$local_name})) {
    #DBG print STDERR "already in list!\n";
    return ($true,$local_name);
  }
  #DBG print STDERR "\n";


  # This just grabs the first file name that has the right trailing path
  # component (
  if (grep {/^(.*$file)$/ && ($complete_file = $1);}
      sort { CPathComponentsOfFile($a) <=> CPathComponentsOfFile($b) }
      @files )  {
    return ($true,$complete_file);
  }

  # NOTE: this is just like a if ($system) block, above
  if (!$system) {
    $complete_file = look_in_path_for_filename( $file );
    if (defined($complete_file)) {
      return ($false,$complete_file);
    }
  }

  #DBG print STDERR "Found $file to be ", (defined($complete_file) ? $complete_file : "<<UNDEFINED>>"), \n";
  # returns undefined if never set

  return ($false,$complete_file);
}


sub add_file ( $$ )
{ my ($file, $inclusion_method) = check_args(2, @_);

  # Add leading "./" so these filenames look like those returned
  # by complete_include_pathname.
  if ($file !~ m/^\.?\//)
    { $file = "./" . $file }
  push @files,$file;
  my $fileno = $#files;
  $file_numbers{$file} = $fileno;
  $file_inclusion_method[$fileno] = $inclusion_method;
}


###########################################################################
### Testing
###

# Don't bother checking type; we test expression types elsewhere.
sub test_categorize_macro_def ( $$$ )
{ my ($category,$properties,$body) = check_args(3, @_);
  if (is_number($category))
    { $category = $categoryname[$category]; }
  $mdef_body[1000] = $body;
  # $mdef_body_noc[1000] = $body;
  $mdef_body_simple[1000] = $body;
  $mdef_name[1000] = "dummy";
  $mdef_formals[1000] = "(arg)";
  $mdef_fileno[1000] = $#files;
  undef $mdef_category[1000];
  categorize_macro_def(1000);
  if ($category ne $categoryname[$mdef_category[1000]])
    { print "Category $categoryname[$mdef_category[1000]] should have been $category: $body\n"; }
  $mdef_properties[1000] &= ~$propFREE_VAR;
  if ($properties != $mdef_properties[1000])
    { print "Property $mdef_properties[1000] should have been $properties: $body\n"; }
}

sub test_cat ( $$$ )
{ my ($category,$properties,$body) = check_args(3, @_);
  test_categorize_macro_def($category,$properties,$body); }

# This needs to test properties too
sub test_categorize_macro_defs ( )
{
  $current_file_name = "testing";	# hack, for input_file_and_line
  $current_ftype_index = 1;	# hack, for update_categories_for

  test_cat("literal", $propNONE, "\"\\037\\235\"");
  test_cat("literal", $propNONE, "\"\037\235\"");
  test_cat("expression", $propNONE, "(uch)get_byte()");
  test_cat("expression", $propNONE, "memset ((voidp)(s), 0, (n))");
  test_cat("expression", $propNONE, "((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
  test_cat("expression", $propNONE, "((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
  test_cat("expression", $propNONE, "((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
  test_cat("expression", $propNONE, "malloc((size_t)(items)*(size_t)(size))");
  test_cat("expression", $propASSIGN, "(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
  test_cat($catTYPE, $propNONE, "struct bsdtty");
  test_cat($catTYPE, $propNONE, "extern inline");
  test_cat("statement", $propASSIGN, "if (status < 0) { perror(name); error=1; }");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "if (foo) bar(baz)");
  test_cat("statement", $propNONE, "if (foo) bar(baz);");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "while (b - bufp->buffer + (n) > bufp->allocated)  EXTEND_BUFFER ()");
  test_cat("statement", $propNONE, "while (b - bufp->buffer + (n) > bufp->allocated)  EXTEND_BUFFER ();");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "goto yyerrlab1");
  test_cat("statement", $propNONE, "goto yyerrlab1;");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "return 0");
  test_cat("statement", $propNONE, "return 0;");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "return err__fl((int)f,m,s)");
  test_cat("statement", $propNONE, "return err__fl((int)f,m,s);");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "if (auth != mach_task_self () && ! __USEPORT (AUTH, port == auth))  return EPERM");
  test_cat("statement", $propNONE, "if (auth != mach_task_self () && ! __USEPORT (AUTH, port == auth))  return EPERM;");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "if (x == NULL) goto error");
  test_cat("statement", $propNONE, "goto error;");
  test_cat("statement", $propNONE, "if (x == NULL) goto error;");
  test_cat("statement", $propNONE, "do { foo(); } while (0);");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "do { foo(); } while (0)");
  test_cat("statement", $propASSIGN, "do { GET_BUFFER_SPACE (1); *b++ = (unsigned char) (c); } while (0);");
  test_cat($catSTATEMENT_SANS_SEMI, $propASSIGN, "do { GET_BUFFER_SPACE (1); *b++ = (unsigned char) (c); } while (0)");

  test_cat("recursive", $propNONE, "foo(dummy)");
  test_cat("recursive", $propNONE, "foo(dummy);");

  test_cat("expression", $propPASSES_TYPE_AS_ARG, "((d)->d_reclen - offsetof (struct direct, d_name) - 1)");
  test_cat("expression", $propPASSES_TYPE_AS_ARG, "_IOR('m', 2, struct mtget)");
  test_cat("expression", $propPASSES_TYPE_AS_ARG, "__BITS(char*)");
  test_cat("expression", $propSTRINGIZE, "((void) ((expression) ? 0 : __assert (#expression, __FILE__, __LINE__)))");
  test_cat($catSTATEMENTS, $propASSIGN, "if (var) free (var); var = NULL;");
  test_cat($catSTATEMENTS_SANS_SEMI, $propASSIGN, "if (var) free (var); var = NULL");
  test_cat($catSTATEMENT_SANS_SEMI, $propASSIGN,
			    "if (CHUNK_VAR->sp == ((char *)CHUNK_VAR + sizeof(*CHUNK_VAR))) { random code in here; } else (CHUNK_VAR->sp -= BYTES), (CHUNK_VAR->bytes_left += BYTES)");

  test_cat($catSTATEMENT, $propASSIGN, "for (rl = 0;;) { code goes here; }");
  test_cat($catSTATEMENT, $propNONE, "for ( ; ; ) { code goes here; }");
  test_cat($catSTATEMENT, $propASSIGN, "for ( ; ; i++) { code goes here; }");
  test_cat($catSTATEMENT, $propNONE, "switch (a ? b : c) { case d: e; case 'f': g(h); }");

  test_cat($catDECLARATION, $propASSIGN, "register gx_clip_rect *rptr = rdev->current.rptr;  gx_device *tdev = rdev->target;");
  test_cat($catDECLARATION_SANS_SEMI, $propASSIGN, "register gx_clip_rect *rptr = rdev->current.rptr;  gx_device *tdev = rdev->target");
  test_cat($catSTATEMENTS_SANS_SEMI, $propASSIGN, "if ( --h == 0 ) break;  bptr += sdelta; dbptr += ddelta");
  test_cat($catPARTIAL_STATEMENT, $propNONE, "if ( cp != 0 ) { statements; } else");
  test_cat($catPARTIAL_STATEMENTS, $propASSIGN, "cp = foo; if ( cp != 0 ) { statements; } else");
  test_cat($catPARTIAL_STATEMENTS, $propASSIGN, "cp = (alloc_change *)alloc(2, sizeof(alloc_change), cname); if ( cp != 0 ) { cp->next = ap->changes; cp[1].next = cp; cp[1].where = 0; cp[1].contents.value.refs = 0; r_set_size(&cp[1].contents, 0); ap->changes = cp + 1; } else");
  test_cat($catDECLARATION_SANS_SEMI, $propNONE, "gs_paint_cspace_params gs_base_cspace_params; gs_separation_params separation; gs_indexed_params indexed");
  # because one argument is "goto fail"
  test_cat($catFAILURE, $propNONE, "rc_allocate_struct(pgs->element, gx_transfer_map, pgs->memory_procs, goto fail, cname);");
  test_cat($catSTATEMENT_SANS_SEMI, $propNONE, "do; while (0)");
  test_cat($catCOMMAND_LINE, $propNONE, "-q nodirect_code");
  test_cat($catCOMMAND_LINE, $propNONE, "-W0,-ncompress -W0,-opt,2 -A cpu,a88k -A sys,any -A run,bsd4.3");
  test_cat($catCOMMAND_LINE, $propASSIGN, "-O1 -fomit-frame-pointer -w -g -Dgetopt=gnu_getopt -Dopterr=gnu_opterr -Doptind=gnu_optind -Doptarg=gnu_optarg -Dcfree=gnu_cfree -D___type=");
  test_cat($catSYMBOLS, $propNONE, "Lisp_Object fnname");
  test_cat($catDECLARATION_SANS_SEMI, $propNONE, "Lisp_Object fnname ()");
  test_cat($catDECLARATION, $propNONE, "Lisp_Object fnname ();");
  test_cat($catDECLARATION_SANS_SEMI, $propASSIGN, "struct Lisp_Subr sname = { PVEC_SUBR | (sizeof (struct Lisp_Subr) / sizeof (EMACS_INT)), fnname, minargs, maxargs, lname, prompt, 0}; Lisp_Object fnname");
  test_cat($catDECLARATION_SANS_SEMI, $propASSIGN, "Lisp_Object fnname (); struct Lisp_Subr sname = { PVEC_SUBR | (sizeof (struct Lisp_Subr) / sizeof (EMACS_INT)), fnname, minargs, maxargs, lname, prompt, 0}; Lisp_Object fnname");
  test_cat($catDECLARATION_SANS_SEMI, $propNONE, "int mkdir (const char *dpath, unsigned short dmode)");
# These use "new", which is a reserved word in C++ (perfectly legal in C).
#   test_cat($catEXP, $propNONE, "(((new) + 1) < ((cur) - (new)))");
#   test_cat($catEXP, $propNONE, "report_error_1(new, msg, x, 0)");
#   test_cat($catEXP, $propNONE, "report_error_1 (new, msg, x, 0)");
#   test_cat($catSTATEMENT, $propNONE, "report_error_1 (new, msg, x, 0);");
#   test_cat($catSTATEMENTS_SANS_SEMI, $propNONE, "report_error_1 (new, msg, x, 0); return -1");
  test_cat($catEXP, $propNONE, "(void (*)(int))1");
  test_cat($catEXP, $propASSIGN, "pthread_run->error_p =(x)");
  test_cat($catSTATEMENT, $propASSIGN, "reject = true;");
  test_cat($catSTATEMENT, $propASSIGN, "if ( allupper( str ) ) reject = true;");
  test_cat($catSTATEMENT_SANS_SEMI, $propASSIGN, "if (--(op)->ob_refcnt != 0) ; else _Py_Dealloc(op)");
  test_cat($catSTATEMENT, $propNONE, "while ((wait3(NULL, WNOHANG, NULL)) > 0);");
  # This is deeply broken:  that trailing semicolon is a killer
  test_cat($catSTATEMENTS, $propASSIGN, "if((nodes[J].flag & 0x20) != 0) { x = nodes[J].x; y = nodes[J].y; nodes[J].flag -= 0x20; if (!clip_point(x,y) && !IFSET(XREDUCE(x)-XREDUCE(xleft),YREDUCE(y)-YREDUCE(ybot))) (*t->point)(x,y, plot_info[nplot].point_type); };");

  test_cat(0,0, '"ZERO","HUP","INT","QUIT","ILL","TRAP","ABRT","BUS","FPE","KILL","USR1","SEGV","USR2","PIPE","ALRM","TERM","STKFLT","CHLD","CONT","STOP","TSTP","TTIN","TTOU","URG","XCPU","XFSZ","VTALRM","PROF","WINCH","IO","PWR","UNUSED","IOT","CLD","POLL",0	/**/');
  test_cat(0,0, '"`echo $sig_name | sed \'s/ /","/g\'`",0	/**/');
}


# Print all lines that look like declarations.
sub test_typedecl_regexp ( )
{
  check_args(0, @_);
#  foreach my $this_file (@files)
  # skip index 0, which is built_in_fake_filename
  for (my $ifiles = 1; $ifiles <= $#files; $ifiles++)
    { $current_file_number = $ifiles;
      $current_file_name = $files[$current_file_number];
      $current_ftype_index = compute_ftype_index($current_file_number);
      if ($opt_v)
	{ print STDERR $current_file_name . "\n"; }
      open(INPUT,$current_file_name) or next; # skip to next file if open fails
      check_file_boundary();
      while ($line = get_fulltoken_line())
	{ if ($line =~ /^$type_specifier_re/o)
	    { print "ts: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re/o)
	    { print "td: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re\s*[,=;\(]/o)
	    { print "td+: $line"; }
	}
      check_file_boundary();
      close(INPUT);
    }
}


sub test_parse_expressions ( )
{
  check_args(0, @_);

  # Integers
  test_parse_expression("int", "0400");
  test_parse_expression("unsigned int", "0x8000");
  # Different than the above because 55 is an int -- might be negative,
  # which wouldn't fit into unsigned int.  type_lub should take values
  # when appropriate, too, maybe.
  test_parse_expression("unsigned long", "33 ? 55 : 0x8000");
  # Should be int, not bool; it's (5 > 4) ? 3 : 2, not 5 > (4 ? 3 : 2).
  # This leads me down the slippery slope of coping with operator precedence...
  test_parse_expression("int", "5 > 4 ? 3 : 2");
  test_parse_expression("unsigned long", "2ULL");
  test_parse_expression($typeUNKNOWN, "LONG_LONG_MAX");
  test_parse_expression("unsigned long", "(LONG_LONG_MAX * 2ULL + 1)");
  test_parse_expression("unsigned long", "0X7FFFFFFFL");

  # Floating-point literals
  test_parse_expression("float", "2.f");
  test_parse_expression("float", ".2f");
  test_parse_expression("float", "2.2f");
  test_parse_expression("float", "2.e3f");
  test_parse_expression("float", ".2e-4f");
  test_parse_expression("float", "2.2e8f");
  test_parse_expression("float", "2e22f");
  test_parse_expression("float", "22f");
  test_parse_expression("double", "2.");
  test_parse_expression("double", ".2");
  test_parse_expression("double", "2.2");
  test_parse_expression("double", "2.e3");
  test_parse_expression("double", ".2e-4");
  test_parse_expression("double", "2.2e8");
  test_parse_expression("double", "2e22");
  test_parse_expression("long double", "2.l");
  test_parse_expression("long double", ".2l");
  test_parse_expression("long double", "2.2l");
  test_parse_expression("long double", "2.e3l");
  test_parse_expression("long double", ".2e-4l");
  test_parse_expression("long double", "2.2e8l");
  test_parse_expression("long double", "2e22l");

  # Casts and named types
  test_parse_expression("char *", "(char*)NULL");
  test_parse_expression("ct_data near *", "(ct_data near *)0");
  test_parse_expression("uch", "(uch)get_byte()");
  test_parse_expression("char *", "(char*)&window[(unsigned)block_start]");
  test_parse_expression("char *", "(char*)NULL, (long)strstart - block_start, (eof)");
  test_parse_expression("long", "(long)strstart - block_start");
  test_parse_expression("char_type *", "((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
  test_parse_expression("ush", "((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
  test_parse_expression("ulg", "((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
  test_parse_expression("uch", "(uch)get_byte");
  test_parse_expression("uch", "(uch)get_byte()");
  test_parse_expression("va_list", "(va_list)__builtin_saveregs()");
  test_parse_expression("va_list", "((AP) = (va_list)__builtin_saveregs())");
  test_parse_expression("XColormapEvent *", "(XColormapEvent *)&Event");
  test_parse_expression("unsigned", "(unsigned)(1<<HASH_BITS)");
  test_parse_expression("__sighandler_t", "((__sighandler_t)-1)");
  test_parse_expression("size_t", "((size_t) &((TYPE *)0)->MEMBER)");
  test_parse_expression("Dimension", "((Dimension)~0)");
  test_parse_expression("struct __va_regs", "((struct __va_regs) foo)");
  test_parse_expression("struct __va_regs", "((struct __va_regs) { 1 })");
  test_parse_expression("struct __va_regs", "((struct __va_regs) {  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11})");
  test_parse_expression("struct __va_regs", "_AP =  ((struct __va_regs) {  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11})");

  # Characters
  test_parse_expression("char", "'\\'");
  test_parse_expression("char *", "\"foo\"");
  test_parse_expression("char *", "flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))");
  test_parse_expression("char *", "\"foo\" \"bar\"");
  test_parse_expression("char *", "\"foo\" \"bar\" \"baz\"");

  # Boolean
  test_parse_expression("bool", "inptr < insize");
  test_parse_expression("bool", "block_start >= 0L");
  test_parse_expression("bool", "(strcmp((s1),(s2)) == 0)");
  test_parse_expression("bool", "(state->basic.eax == MACH_RCV_INTERRUPTED && !memcmp (pc, &syscall, sizeof syscall))");
  test_parse_expression("bool", "(size1 == 0)");
  test_parse_expression("bool", "(startpos >= size1)");
  test_parse_expression("bool", "(foo || bar)");
  test_parse_expression("bool", "(size1 == 0 || startpos >= size1)");
  test_parse_expression("bool", "result = true");

  # Array
  test_parse_expression("typeUNKNOWN", "{  { LONG_MAX, LONG_MAX },  { LONG_MAX, LONG_MAX }, }");

  # Unknown
  test_parse_expression("typeUNKNOWN", "((B) - 1)");
  test_parse_expression("typeUNKNOWN", "tab_prefix[i]");
  test_parse_expression("typeUNKNOWN", "&window");
  test_parse_expression("typeUNKNOWN", "NULL");
  test_parse_expression("typeUNKNOWN", "(eof)");
  test_parse_expression("typeUNKNOWN", "memset ((voidp)(s), 0, (n))");
  test_parse_expression("typeUNKNOWN", "malloc((size_t)(items)*(size_t)(size))");
  test_parse_expression("typeUNKNOWN", "inbuf[inptr++]");
  test_parse_expression("typeUNKNOWN", "((A) < (B) ? (A) : (B))");
  test_parse_expression("typeUNKNOWN", "(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
  test_parse_expression("typeUNKNOWN", "fill_inbuf(0)");
  test_parse_expression("typeUNKNOWN", "BLOCK_SIGNAL (SIGCHLD, nvar, ovar)");
  test_parse_expression("typeUNKNOWN", "_elf_data_set_element(set, symbol)");
  test_parse_expression("typeUNKNOWN", "symbol_set_declare(set)");
  test_parse_expression("typeUNKNOWN", "_elf_text_set_element(set, symbol)");
  test_parse_expression($typeUNKNOWN, "get_byte()");
  test_parse_expression($typeUNKNOWN, "strcmp((s1),(s2))");
  test_parse_expression($typeUNKNOWN, "((s1),(s2))");
  test_parse_expression($typeUNKNOWN, "(s1),(s2)");
  test_parse_expression($typeUNKNOWN, "(s1)");
  test_parse_expression($typeUNKNOWN, "s1,s2");
  test_parse_expression($typeUNKNOWN, "strcmp(s1,s2)");
  test_parse_expression($typeUNKNOWN, "(1L << (n))");
  test_parse_expression($typeUNKNOWN, "(1 << (n))");
  test_parse_expression($typeUNKNOWN, "(1 << n)");
  test_parse_expression($typeUNKNOWN, "(1<<HASH_BITS)");
  test_parse_expression($typeUNKNOWN, "(((struct mhead *) mem) - 1) -> mh_index");
  test_parse_expression($typeUNKNOWN, "8 << (((struct mhead *) mem) - 1) -> mh_index");
  test_parse_expression($typeUNKNOWN, "O_WRONLY | O_CREAT | O_EXCL | O_BINARY");
  test_parse_expression($typeUNKNOWN, "(foo ? string2[startpos - size1]  : string1[startpos])");
  test_parse_expression($typeUNKNOWN, "(size1 == 0 || startpos >= size1 ? string2[startpos - size1]  : string1[startpos])");
  test_parse_expression($typeUNKNOWN, '$$PsectAttributes_NOSHR$$environ');
  test_parse_expression($typeUNKNOWN, "pthread_run->error_p =(x)");
  test_parse_expression("typeUNKNOWN", "{  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11}");
}

sub test_parse_expression ( $$ )
{
  my ($expected_type, $exp) = check_args(2, @_);
  $expected_type = type_name(type_to_num($expected_type));
  if ($debug_parse_expression)
    { print "test_parse_expression <= '$expected_type' '$exp'\n"; }
  my ($parsed_type, $remaining) = parse_expression($exp);
  my $parsed_type_name = type_name($parsed_type);
  if ($debug_parse_expression)
    { print "test_parse_expression => '$expected_type' '$exp' '$parsed_type' '$parsed_type_name'\n"; }
  if ($remaining ne "")
    { print STDERR "Didn't parse all of $expected_type '$exp',\n    got $parsed_type_name with remaining = '$remaining'\n"; }
  elsif ($expected_type ne $parsed_type_name)
    { if ($exp =~ /\?/)
	{ print STDERR "Conditional flub? "; }
      print STDERR "Type $parsed_type_name ($parsed_type) should have been $expected_type: $exp\n"; }
}

sub test_regexp ( $$;$ )
{
  my ($string, $regexp, $regexp_pretty) = check_args_range(2, 3, @_);
  if ($string !~ /$regexp/)	# no /o
    { print "'$string' should have matched "
	. (defined($regexp_pretty) ? $regexp_pretty : "regexp '$regexp'") . "\n"; }
}

sub anchor ( $ )
{ my ($regexp) = check_args(1, @_);
  return '^' . $regexp . "\$";
}

sub test_declarator_re ( $ )
{
  my ($string) = check_args(1, @_);
  test_regexp($string, anchor($declarator_re), "declarator_re");
}

sub test_type_declarator_re ( $ )
{
  my ($string) = check_args(1, @_);
  test_regexp($string, anchor($type_declarator_re), "type_declarator_re");
}

sub test_type_declarator_re_plus ( $ )
{
  my ($string) = check_args(1, @_);
  test_regexp($string, anchor('\s*' . $type_declarator_re . '\s*([,=;\(])'), "type_declarator_re plus");
}

sub test_type_declarator_arglist_re ( $ )
{
  my ($string) = check_args(1, @_);
  test_regexp($string, anchor($type_declarator_arglist_re), "type_declarator_arglist_re");
}

sub test_typedecl_regexps ( )
{
  check_args(0, @_);
  test_type_declarator_re_plus("int fill_inbuf(eof_ok);");
  test_type_declarator_arglist_re("int fill_inbuf(eof_ok)");
  test_type_declarator_re_plus("static char *license_msg[] =");
  test_type_declarator_re("static char *license_msg[]");
  test_type_declarator_re_plus("char z_suffix[MAX_SUFFIX+1];");
  test_declarator_re("(*out_char)");
  test_type_declarator_re("void (*out_char)");
  test_type_declarator_re_plus("void (*out_char)(");
  test_type_declarator_arglist_re("void (*out_char)()");
  test_declarator_re("(*close_func)");
  test_type_declarator_re("int (*close_func)");
  test_type_declarator_re_plus("int (*close_func)(");
  test_type_declarator_arglist_re("int (*close_func)(CL_Handle)");
  test_type_declarator_arglist_re("int (*func)(CL_Handle, int *, int)");
  test_type_declarator_re("register gx_clip_rect *rptr");
  test_type_declarator_re_plus("register gx_clip_rect *rptr =");
}


## Random tests

# First argument should always be   sub {eval $_[0]}
# and second arg should be in single, not double, quotes.
sub check ( $$ )
{ my ($ev_fn,$str) = check_args(2, @_);
  my $val = &$ev_fn($str);
  if (!defined($val))
    { print STDERR "$@    while evaluating $str\n"; }
  elsif (! $val)
    { print STDERR "Assertion failed: $str\n"; }
}

sub check_val ( $$$ )
{ my ($ev_fn,$expected,$str) = check_args(2, @_);
  my $actual = &$ev_fn($str);
  if ($actual ne $expected)
    { print STDERR "Failed value assertion: $str => $actual, expected $expected\n"; }
}


## sub check2 ( $$ )
## { my ($val, $str) = check_args(2, @_);
##   if (!$val)
##     { print STDERR "Failed assertion: $str\n"; }
## }
## 
## 
## # This can be a tad shorter than putting the == in both args to "check".
## sub check_val ( $$$ )
## { my ($actual, $expected, $expression) = check_args(3, @_);
##   if ($actual ne $expected)
##     { print STDERR "Failed value assertion: $expression => $actual, expected $expected\n"; }
## }

sub test_misc ( )
{
  { my @foo = (1, 2, 3);
    my @bar = (1, 2, 3);
    my @baz = (1, 2);
    #     check2(array_equal(\@foo, \@bar), 'array_equal(\@foo, \@bar)');
    #     check2(array_equal(\@bar, \@foo), 'array_equal(\@bar, \@foo)');
    #     check2(!array_equal(\@foo, \@baz), '!array_equal(\@foo, \@baz)');
    #     check2(!array_equal(\@baz, \@foo), '!array_equal(\@baz, \@foo)');
    check(sub {eval $_[0]}, 'array_equal(\@foo, \@bar)');
    check(sub {eval $_[0]}, 'array_equal(\@bar, \@foo)');
    check(sub {eval $_[0]}, '!array_equal(\@foo, \@baz)');
    check(sub {eval $_[0]}, '!array_equal(\@baz, \@foo)');
  }
  { my $dep1 = [ 'a', 'b', 'c' ];
    my $dep2 = [ 'a', 'b', 'c' ];
    my $dep3 = [ 'a', 'b' ];
    my $dep4 = [ 'a', 'b', '!(c)' ];
    my $dep12 = merge_dependenton($dep1, $dep2);
    my $dep13 = merge_dependenton($dep1, $dep3);
    my $dep14 = merge_dependenton($dep1, $dep4);

    check(sub {eval $_[0]}, 'array_equal($dep1, $dep12)');
    check(sub {eval $_[0]}, '!$dep13');
    check(sub {eval $_[0]}, 'ref $dep14');
    check(sub {eval $_[0]}, 'array_equal($dep3, $dep14)');

    check(sub {eval $_[0]},'"" eq format_dependentons(reduce_dependentons())');
    check(sub {eval $_[0]}, '"a b c" eq format_dependentons(reduce_dependentons($dep1))');
    check(sub {eval $_[0]}, '"a b c" eq format_dependentons(reduce_dependentons($dep1, $dep2))');
    check(sub {eval $_[0]}, '"a b ; a b c" eq format_dependentons(reduce_dependentons($dep1, $dep3))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep1, $dep4))');
    check(sub {eval $_[0]}, '"a b ; a b c" eq format_dependentons(reduce_dependentons($dep2, $dep3))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep2, $dep4))');
    check(sub {eval $_[0]}, '"a b ; a b !(c)" eq format_dependentons(reduce_dependentons($dep3, $dep4))');
    check(sub {eval $_[0]}, '"a b ; a b c" eq format_dependentons(reduce_dependentons($dep1, $dep2, $dep3))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep1, $dep2, $dep4))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep1, $dep3, $dep4))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep2, $dep3, $dep4))');
    check(sub {eval $_[0]}, '"a b" eq format_dependentons(reduce_dependentons($dep1, $dep2, $dep3, $dep4))');
  }

  { my $dep1 = [ 'a', 'b', 'c', 'd' ];
    my $dep9 = [ 'a', 'b', 'c', 'd' ];
    my $dep4 = [ 'a', 'b', 'c', 'd', '!(e)', '!(f)' ];
    my $dep10 = [ 'a', 'b', 'c', 'd', 'e', '!(g)' ];
    my $dep7 = [ 'a', 'b', 'c', 'd', 'e', 'g' ];
    my $dep3 = [ 'a', 'b', 'c', 'd', '!(e)', 'f' ];
    my $dep2 = [ 'a', 'b', 'c', 'd', 'h' ]; # "extra"
    my $dep8 = [ 'a', 'b', 'c', '!(d)' ];
    my $dep5 = [ 'a', 'b', 'c', 'd', 'e' ];
    my $dep6 = [ 'f', 'o', 'o' ]; # "extra"

    check(sub {eval $_[0]}, '"a b c d" eq format_dependentons(reduce_dependentons($dep3, $dep4, $dep5))');
    check(sub {eval $_[0]}, '"a b c" eq format_dependentons(reduce_dependentons($dep1, $dep3, $dep4, $dep5, $dep7, $dep8, $dep9, $dep10))');
    check(sub {eval $_[0]}, '"f o o ; a b c ; a b c d h" eq format_dependentons(reduce_dependentons($dep1, $dep2, $dep3, $dep4, $dep5, $dep6, $dep7, $dep8, $dep9, $dep10))');
  }
}

# print defined($type_num["foo"]);
# print "foo" + 0;
# print type_name(1);

# $foo = "x"; $foo =~ /x/; print defined($POSTMATCH), defined($POSTMATCH), defined($POSTMATCH), "\n";
# print ("" eq "\n"), "\n";
# "abaababb" =~ /(((a+)(b+))*)/; print "<<$1>><<$2>><<$3>><<$4>><<$MATCH>>\n";
# print scalar("static char" =~ /^\s*$type_specifier_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_unparenthesized_re$/o), "\n";
# print scalar("*" =~ /^$pointer_declarator_prefix_re/o), "\n";
# print scalar("license_msg" =~ /^\s*$identifier_re/o), "\n";
# print scalar("[]" =~ /^\s*$array_declarator_suffix_re/o), "\n";
# print scalar("char" =~ /^$type_re$/o), "\n";
# print scalar("char" =~ /^$type_specifier_re$/o), "\n";
# print scalar("char" =~ /^$identifier_re$/o), "\n";
# print scalar("(ct_data near *)" =~ /^\s*\(\s*$type_re\s*\)\s*$/o), "\n";
# print parse_array_initializer("bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};\n"), "\n";
# print scalar("(*sig_type)" =~ /^$declarator_re$/o), "\n";
# print scalar("z_suffix[MAX_SUFFIX+1]" =~ /^$declarator_re$/o), "\n";
# print scalar("[MAX_SUFFIX+1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print scalar("[1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print join(' -- ', parse_declarator("char", "z_suffix[MAX_SUFFIX+1]")), "\n";
# my @foo = (3,4,5,6); my @bar = @foo; $foo[0] = "new"; print @foo, "\n", @bar, "\n";

# print scalar("static void *" =~ /^$builtin_type_re/o), "\n";
# print scalar("void *" =~ /^$builtin_type_re/o), "\n";
# print scalar("void *" =~ /^$type_specifier_re/o), "\n";


# "extern void dc_binop (int (*)(dc_num, dc_num, int, dc_num *), int);"

# print scalar("int (*)(dc_num, dc_num, int, dc_num *), int));" =~ /^\s*($type_re_special)\s*([,\(\)])/o), "\n";
# print $type_re_special, "\n";

# print join(':', formals_array("(foo)")), "\n";
# print join(':', formals_array("()")), "\n";
# print join(':', formals_array("(foo,bar)")), "\n";
# print join(':', formals_array("(foo, bar)")), "\n";
# print join(':', formals_array(" ( foo , bar ) ")), "\n";
# 
# print join(':', actuals_array("(foo)")), "\n";
# print join(':', actuals_array("()")), "\n";
# print join(':', actuals_array("(foo,bar)")), "\n";
# print join(':', actuals_array("(foo, bar)")), "\n";
# print join(':', actuals_array(" ( foo , bar ) ")), "\n";


###########################################################################
### Save state
###

# Output big dependence variables to their own file
sub save_dependence_to_file ( $ )
{ my ($filename) = check_args(1, @_);
  if ($compute_transitive_dependence_info)
    { my %namevalhash = ();
      for my $varname (@depend_state_file_vars)
	{ $namevalhash{$varname} = eval '\\' . $varname;
	  if ($@) { die "Problem evaling '$varname': $@"; } }
      save_dependence_state($filename, %namevalhash);
    }
  else
    { unlink($filename); }
  # Reclaim space by undefining the variables
  for my $varname (@depend_state_file_vars)
    { eval "undef $varname;\n"; }
}

sub SaveMacroAnalysisState ( $ )
{ my ($output_filename) = check_args(1, @_);

  ## Try to save some space, to avoid running out of memory in Data::Dumper
  # undef @mdef_body_noc;
  undef @mdef_body_simple;

  #FIXGJB: We probably want this info, but maybe we can settle for a count
  # of No. of different fns which use the macro or just not bother with it
  undef %macros_used_in_functions;

  ## Now do the actual output.
  save_dependence_to_file(depend_state_file_name($output_filename));

  save_variables($output_filename, @state_file_vars);
}

sub save_variables ( $@ )
{
  my ($output_filename, @vars) = check_args_at_least(1, @_);

  $Data::Dumper::Indent = 1;
#  $Data::Dumper::Purity = 1;

# DumpxsFile prints to a file named "state"
#  system("rm state");
  open(OUTSTATE, ">$output_filename")
    or (open(OUTSTATE, ">state" && printf STDERR "Couldn't open $output_filename, using \"state\" instead\n"))
      or die "Failed opening output file: $!";
  # Without the selects and setting of $|, -*- Perl -*- appears at end of file.
  { select(OUTSTATE); $| = 1;
    print OUTSTATE "\# -*- Perl -*-\n";
    $| = 0; select(STDOUT); }

  foreach my $v (@vars) {
    my $g = $v;
    $g =~ s/[\@\%\$]/\*/;
    # DumpxsFd used to cause trouble with closing random open files, discarding
    # buffered output.  It doesn't seem to do that any more, though...
    my $es = "Data::Dumper->DumpxsFd(fileno OUTSTATE,[\\$v],[\"$g\"]);\n";
#    my $es = "print OUTSTATE Data::Dumper->Dumpxs([\\$v],[\"$g\"]);\n";
    print STDERR $es if $opt_v;
    eval $es;
    $es = "undef $v;\n";
    eval $es;
  }

  close(OUTSTATE);
#  system("mv state $output_filename");

}


###########################################################################
### Main loop
###

# This is at the end of the file so that constants and variables can be
# introduced and set near where they are used rather than at the top of the
# file (before the main loop).  This is especially nice for globals that
# are only used by one or two routines.


use Getopt::Std;
getopts($getopts_option_letters);

usage() if ($opt_h);

if ($opt_e) { $compute_transitive_dependence_info = $false; }

#SaveMacroAnalysisState("/tmp/gjb/macros");
#exit 0;

if ($opt_F) {
  unshift(@INC,$opt_F);
}

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    add_file($_, "FromStdin");
  }
}

if ($opt_a && ($opt_u || $opt_1)) {
  die "Option -a is incompatible with options -u or -1";
}

my $statename = "state";

# TESTING of CPathComponentsOfFile of searching @files for a filename trailer
#print CPathComponentsOfFile("./foo/bar"), "\n";
#print CPathComponentsOfFile("./foo"), "\n";
#print CPathComponentsOfFile("./foo/bar/testing"), "\n";
#my $file = "readline/readline.h";
#my $complete_file = undef;
#if (grep {/^(.*$file)$/ && ($complete_file = $1);} sort { CPathComponentsOfFile($a) <=> CPathComponentsOfFile($b) }  @files )  {
#    print $complete_file, "\n";
#}
#print join("\n",sort { CPathComponentsOfFile($a) <=> CPathComponentsOfFile($b) }  @files);
#exit 0;

# Clunky, but faster than editing and saving the file over NFS.
if ($opt_g)
{ if ($opt_g == 0)
    { $fDebugCmdProcessing = $false;
      $fDebugCommentRemoval = $false;
      $debug_scopes = $false;
      $debug_type_match = $false;
      $debug_parse_function = $false;
      $debug_parse_expression = $false;
      $debug_parse_statement = $false;
      $debug_parse_declaration = $false;
      $debug_merge_branches = $false;
      $debug_parse_array_init = $false;
      $debug_peek = $false;
      $debug_getline = $false;
      $debug_categorize_macro = $false;
      $debug_cpp_if_comments = $false;
      $debug_dependences = $false;
      $debug_dependences_internal = $false;
      $debug_ccd_categories = $false;
    }
  $opt_g =~ s/[ \t]+//;		# squeeze out whitespace
  if ($opt_g !~ /[0-9]+(,[0-9]+)*/)
    { die "Bad -g option (should be number or comma-separated list of numbers): $opt_g"; }
  if ($opt_g =~ /\b1\b/) { $fDebugCmdProcessing = $true; }
  if ($opt_g =~ /\b2\b/) { $fDebugCommentRemoval = $true; }
  if ($opt_g =~ /\b3\b/) { $debug_scopes = $true; }
  if ($opt_g =~ /\b4\b/) { $debug_type_match = $true; }
  if ($opt_g =~ /\b5\b/) { $debug_parse_function = $true; }
  if ($opt_g =~ /\b6\b/) { $debug_parse_expression = $true; }
  if ($opt_g =~ /\b7\b/) { $debug_merge_branches = $true; }
  if ($opt_g =~ /\b8\b/) { $debug_parse_array_init = $true; }
  if ($opt_g =~ /\b9\b/) { $debug_peek = $true; }
  if ($opt_g =~ /\b10\b/) { $debug_getline = $true; }
  if ($opt_g =~ /\b11\b/) { $debug_categorize_macro = $true; }
  if ($opt_g =~ /\b12\b/) { $debug_cpp_if_comments = $true; }
  if ($opt_g =~ /\b13\b/) { $debug_dependences = $true; }
  if ($opt_g =~ /\b14\b/) { $debug_ccd_categories = $true; }
  if ($opt_g =~ /\b15\b/) { $debug_parse_statement = $true; }
  if ($opt_g =~ /\b16\b/) { $debug_parse_declaration = $true; }
  if ($opt_g =~ /\b17\b/) { $debug_dependences_internal = $true; }
}
if ($opt_T)
{
  print "fDebugCmdProcessing = $fDebugCmdProcessing\n";
  print "fDebugCommentRemoval = $fDebugCommentRemoval\n";
  print "debug_scopes = $debug_scopes\n";
  print "debug_type_match = $debug_type_match\n";
  print "debug_parse_function = $debug_parse_function\n";
  print "debug_parse_expression = $debug_parse_expression\n";
  print "debug_merge_branches = $debug_merge_branches\n";
  print "debug_parse_array_init = $debug_parse_array_init\n";
  print "debug_peek = $debug_peek\n";
  print "debug_getline = $debug_getline\n";
  print "debug_categorize_macro = $debug_categorize_macro\n";
  print "debug_cpp_if_comments = $debug_cpp_if_comments\n";
  print "debug_dependences = $debug_dependences\n";
  print "debug_ccd_categories = $debug_ccd_categories\n";
  print "debug_parse_statement = $debug_parse_statement\n";
  print "debug_parse_declaration = $debug_parse_declaration\n";
  print "debug_dependences_internal = $debug_dependences_internal\n";
}


# using a default directory-- only open the files that
# aren't explicitly given
if ($opt_d) {
  my ($dir,$base_name) = split /:/,$opt_d;


  if (!defined($base_name) || $base_name eq "") {
    $base_name = "";
  } else {
    $base_name .= ".";
  }

  if ($dir !~ /\/$/) {
    $dir .= "/";
  }

  print STDERR "Output to $dir with prefix '$base_name'\n";

  $statename = "$dir/${base_name}state";

  if (!$opt_E) {
    open(EVIL,">$dir/${base_name}evil") || die "Failed opening $dir/${base_name}evil: $!";
  }

  if (!$opt_P) {
    open(PARSE_ERRS,">$dir/${base_name}perr") || die "Failed opening $dir/${base_name}perr: $!";
  }

  if (defined($opt_L)) {
    open(LARGE_DEPEND,">$dir/${base_name}ldepend") || die "Failed opening $dir/${base_name}ldepend: $!";
  }

  if ($debug_ccd_categories) {
    open(CCD_CATEG,">$dir/${base_name}ccd_debug") || die "Failed opening $dir/${base_name}ccd_debug: $!";
  };

  if ($debug_ccd_categories) {
    open(CCD_CATEG,">$dir/${base_name}ccd_debug") || die "Failed opening $dir/${base_name}ccd_debug: $!";
  };
}

if ($opt_E) { open(EVIL,">$opt_E") || die "Failed opening $opt_E"; }
  elsif (!$opt_d) { open(EVIL,">-") || die "Failed opening stdout!"; }
if ($opt_P) { open(PARSE_ERRS,">$opt_P") || die "Failed opening $opt_P"; }
  elsif (!$opt_d) { open(PARSE_ERRS,">-") || die "Failed opening stdout!"; }
# This probably doesn't slow things down too much, and it's convenient.
EVIL->autoflush(1);
PARSE_ERRS->autoflush(1);
STDIN->autoflush(1);
STDOUT->autoflush(1);
STDERR->autoflush(1);

if ($opt_I) { $fIgnoreIncludes = $true; }
if ($opt_t) { $outOFS = "\t"; } # use tab for OFS
if ($opt_l) { $identifier_re = $identifier_no_dollar_re; } # no $ in identifiers

# Fix: Explain why these are set unconditionally.
# Now set these so we'll actually do the output
# (output_stats uses $opt_X as a guard for printing)
$opt_E = $true;
$opt_P = $true;

$fDebugCmdProcessing && print "ARGV = @ARGV";

# Add the rest of the arguments to the files list
foreach my $file (@ARGV) {
  add_file($file, "FromCmdLine");
}

get_include_path();
initialize_builtin_macros();
initialize_lists_of_hashes();

# Testing
if ($opt_T)
{ local $categorizing_macros = $true;
  STDIN->autoflush(1);
  STDOUT->autoflush(1);
  STDERR->autoflush(1);

  add_file("testing", "FromStdin");
  $current_file_number = $#files;
  $current_file_name = $files[$current_file_number];

  test_typedecl_regexps();
  test_parse_expressions();
  test_categorize_macro_defs();
  test_misc();

  exit -1;			# Don't run following programs, eg from gzip.
  # exit;			# Find this via search for the string "exit;".
}

## Begin processing files

# "scalar(@files)" because index 0 is built_in_fake_filename
if ($opt_v) { print STDERR "Processing $#files files",
  	                   ($opt_I ? "" : " (plus \#included files)"), "...\n"; }

## This is pass 1 over the input files
find_macro_definitions();	# also counts other preprocessor usage
if ($opt_v) { print STDERR "Done finding macro definitions.\n"; }
{ my %undefined_macros = ();
  for my $word (keys %macros_used_by_cpp)
    { if (!defined($macros{$word}))
	{ # It would be nice to order these better (sort by filename?)
	  # Maybe don't complain if this is an $ifdef, or if all uses are
	  # dependent on it being defined?
	  my $where_used_by_cpp = $macros_used_by_cpp{$word};
	  $where_used_by_cpp =~ s/^([0-9]+)/$files[$1]/e;
	  $undefined_macros{$word} = $where_used_by_cpp;
	  introduce_new_macro($word); } }
  for my $word (sort { $undefined_macros{$a} cmp $undefined_macros{$b} } keys(%undefined_macros))
    { if ($macros_used_by_cpp{$word} !~ /^builtin_(empty|string|num)_def$/)
	{ print EVIL "$undefined_macros{$word}: macro $word never defined\n"; } } }


# Kind of a hack
if ($opt_v) { print STDERR "Another loop over the macros...\n"; }
for my $name (keys %macros)
  { if (is_fun_decl_arg_macro($name))
      { $fun_decl_arg_macros{$name} = $true; }
    if (is_semi_fun_decl_arg_macro($name))
      { $semi_fun_decl_arg_macros{$name} = $true; }
    if (is_void_macro($name))
      { $void_macros{$name} = $true; } }
# print "fun_decl_arg_macros: ", join(" ", (keys %fun_decl_arg_macros)), "\n";
# print "semi_fun_decl_arg_macros: ", join(" ", (keys %semi_fun_decl_arg_macros)), "\n";
# print "void_macros: ", join(" ", (keys %void_macros)), "\n";


# Print number of definitions for each macro
# for my $name (sort keys %macros)
#   { print "$name ", scalar(@{$macros{$name}}), " ", join(" ",@{$macros{$name}}), "\n"; }
# Print body (less comments) for each macro definition.
# for my $i (0..$cMacrosInTables)
#   { print "$i $mdef_formals[$i] $mdef_body_noc[$i]\n"; }

# For now, when debugging, move this to near the end.
# # Save some space: output AND UNDEFINE variables not needed for the second pass
# save_variables(extra_state_file_name($statename), @extra_state_file_vars);

if (!$opt_1)
{ if ($opt_v) { print STDERR "done with that loop; now finding macro uses...\n"; }
  dumpallvars() if $opt_M;
  if ($compute_transitive_dependence_info)
    { compute_transitive_dependences(); }
  dumpallvars() if $opt_M;
  ## This is pass 2 over the input files
  process_macro_calls();
}

if ($opt_v) { print STDERR "Computing macro/function use relations...\n"; }
compute_macros_used_in_functions();
undef %macros_file_line_uses;
if ($opt_v) { print STDERR "Undef-ed \%macros_file_line_uses\n"; }


### All the files have been read; now process the macros
print STDERR "Categorizing $cMacrosInTables macros\n";
{ local $categorizing_macros = $true;
  for (my $i = 0;
       $i < $cMacrosInTables;
       $i++ )
    { # print "$i: $mdef_body[$i]\n";
      #   print &parse_expression($mdef_body[$i]) . ": ";
      #   foreach my $var (keys(%parsevars)) { print $var . " "; }
      #   print "\n  $mdef_name[$i]";
      #   if (defined($mdef_formals[$i])) { print $mdef_formals[$i]; }
      #   print " $mdef_body[$i]\n";
      # current_file_name and current_line_no need to be set
      # while we are categorizing.  Also must always
      # set $current_ftype_index when we change the $current_file_name
      # (use compute_ftype_index() )
      $current_file_number = $mdef_fileno[$i];
      $current_file_name = $files[$current_file_number];
      $current_ftype_index = compute_ftype_index($current_file_number);
      $current_macro_line_number = $mdef_line[$i];
      categorize_macro_def($i);	# also gets properties (currently, discards)
    }

  # If anything was originally categorized as in_process, try again:
  #  erase the macro name's category, and try again for the parts.
  for my $mname (keys %macros)
    # Not sure why I'm using mntype instead of mncategory; I do so elsewhere.
    { if (defined($mntype{$mname}) && ($mncategory{$mname} == $catIN_PROCESS))
	{ delete $mntype{$mname};
	  delete $mncategory{$mname}; } }
  # Maybe should undef all these before trying again.
  # Or maybe should try in the reverse order.
  for (my $i = 0; $i < $cMacrosInTables; $i++)
    { if ($mdef_category[$i] == $catIN_PROCESS)
	{ undef $mdef_category[$i];
	  undef $mdef_type[$i];
	  categorize_macro_def($i); } }
  # If a name is STILL in_process, give it one more try (probably fruitless)
  for my $mname (keys %macros)
    # Not sure why I'm using mntype instead of mncategory; I do so elsewhere.
    { if (defined($mntype{$mname}) && ($mncategory{$mname} == $catIN_PROCESS))
	{ delete $mntype{$mname};
	  delete $mncategory{$mname}; } }

  for my $mname (keys %macros)
    { categorize_macro_name($mname); }
}

# print STDERR "Files:",join("\n  ",@files),"\n";
# print STDERR "Included files:", join("\n    ",@files_included), "\n";
# print STDERR "fun_decl_arg_macros:", join("\n",keys %fun_decl_arg_macros), "\n";

# Flush the output, becuase DumpxsFd may close them and delete buffered output.
# (I can no longer reproduce that problem, but just in case...)
select(EVIL); $| = 1; print EVIL "\n";
select(PARSE_ERRS); $| = 1; print PARSE_ERRS "\n";
if (defined($opt_L)) { select(LARGE_DEPEND); $| = 1; print LARGE_DEPEND "\n"; }
# # close(EVIL);
# # close(PARSE_ERRS);

dumpallvars() if $opt_M;
save_variables(extra_state_file_name($statename), @extra_state_file_vars);
print STDERR "Save macro analysis state\n";
SaveMacroAnalysisState($statename);
print STDERR "Successful completion!\n";
dumpallvars() if $opt_M;

exit();

use Devel::Peek 'Dump','DumpArray';
use Devel::Symdump;
sub dumpallvars {
  my $old = select STDERR;
  print "-=-=-=-=-=-=-=-=-=-=-=-=-=-\n";
  no strict 'refs';
  my $obj = Devel::Symdump->rnew;
  my @vars = $obj->scalars;
  foreach my $v (@vars) {
    print "\$", $v, "\n";
    Dump($$v);
    print "---------";
  }
  @vars = $obj->arrays;
  foreach my $v (@vars) {
    print "\@", $v, "\n";
    Dump(\@$v);
    print "---------";
  }
  @vars = $obj->hashes;
  foreach my $v (@vars) {
    print "\%", $v, "\n";
    Dump(\%$v);
    print "---------";
  }
  # Do not even think about changing the below line! :-) --gjb
  @vars = split(/\n/,`perl <$0 -ne \'if (/^my ([\\\$\\\@\\\%]\\w+)/) { print \$1, "\\n"; };\'`);
  foreach my $v (@vars) {
    my $evalstr = "Dump(\\$v);";
    print $v, "\n";
    eval $evalstr;
    print "---------";
  }
  select $old;
}

### Local Variables:
### page-delimiter: "^#################################################*\n"
### End:
