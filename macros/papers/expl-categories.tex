

\begin{description}
  \sloppy
  \emergencystretch=2em

%%  mcat_NULL: 5391
%%    100%  null_define (5391)
% @mcat_NULL = qw( catNULL_DEFINE );
\item[Null define]  The {\tt \#define} directive gives only an
  identifier name but no macro body, as in {\tt \#define
  \verb|HAVE_PROTO|}\@.  Such macros appear frequently in Cpp
directives (such as {\tt \#ifdef}), where they are used as boolean
variables by the preprocessor.  In code, they often represent optional
syntax.  For instance,
macro {\tt private} may expand either to {\tt static} or to nothing,
depending on whether a debugging mode is set.

%%  mcat_CONSTANT: 18971
%%    0.00%  constant (0)
%%    97%  literal (18426)
%%    2.9%  some_constant (545)
% @mcat_CONSTANT = qw( catCONSTANT catLITERAL catSOME_CONSTANT );
\item[Constant] The macro body is either a literal (97\% of this category)
  or an operator applied to constant values (3\% of this category).
  These macros act like {\tt const} variables. 
  For instance, {\tt \#define NULL 0}, {\tt \#define \verb|ARG_MAX|
  131072}, and {\tt \#define ETCHOSTS "/etc/hosts"} define literals, while
{\tt \#define \verb|RE_DUP_MAX| ((1<<15)-1)} and {\tt
\#define \verb|RED_COLS| (1 << \verb|RED_BITS|)} (where \verb|RED_BITS| is
a constant, possibly a literal) define constants.  This category includes
both macros whose value is invariant across all configurations of the
package and those which depend on other compile-time values.  

%%  mcat_NONCONSTANT_EXPRESSION: 13529
%%    100%  expression (13529)
% @mcat_NONCONSTANT_EXPRESSION = qw( catEXP );
\item[Expression]  The macro body is an expression, as in {\tt \#define
  sigmask(x) (1 << ((x)-1))} or {\tt \#define mtime mailfiles[i]->\verb|mod_time|}.
Such a macro acts like a function which returns a value (though the
macro need not take any arguments, so its uses may look syntactically
unlike function calls). 
The expression might have a single constant value everywhere (the usual
case for expression macros without arguments, most of which are classified
as constants, above) or might have a different value on each use (the usual
case for expression macros with arguments).

%%  mcat_STATEMENT: 2656
%%    47%  statement (1242)
%%    45%  semicolonless_statement (1197)
%%    1.5%  partial_statement (40)
%%    3.0%  statements (79)
%%    3.5%  semicolonless_statements (94)
%%    0.15%  partial_statements (4)
% @mcat_STATEMENT = qw( catSTATEMENT catSTATEMENT_SANS_SEMI catPARTIAL_STATEMENT
%                        catSTATEMENTS catSTATEMENTS_SANS_SEMI catPARTIAL_STATEMENTS );
% These aren't great examples (not from actual code); but so be it, as the
% actual examples are *very* long.
\item[Statement]  The macro body is a complete statement such as
  ``{\tt plu = ".";}'', ``{\tt if (x) \verb|{|free(x); x=NULL;\verb|}|'' or
    ``{\tt \verb|{| int c; while ((c = getc(fp)) != '\n' && c != EOF);
    \verb|}|''.  Such a macro is like a function 
    returning {\tt void}, except that uses should not be followed by a
    semicolon (see section~\ref{sec:lint}).
    
    To reduce the number of categories in this presentation, the statement
    categogry aggregates single statements (comprising 47\% of the category),
    statements missing their final semicolon (as in {\tt \#define QUIT if
    (\verb|interrupt_state|) \verb|throw_to_top_level|()}; these account
  for 45\%), multiple statements (3.0\%), multiple statements where the
  last one is missing its final semicolon (3.5\%), and partial statements
  (as in {\tt \#define ASSERT(p) if (!(p)) botch(\verb|__STRING|(p));
  else}; these are the final less than 2\% of the statement category).

%%  mcat_TYPE: 697
%%    82%  type (569)
%%    0.00%  partial_type (0)
%%    3.3%  declaration (23)
%%    15%  semicolonless_declaration (105)
% @mcat_TYPE = qw( catTYPE catPARTIAL_TYPE catDECLARATION catDECLARATION_SANS_SEMI);
% #my @mcat_DECLARATION = qw( catDECLARATION catDECLARATION_SANS_SEMI );
% #folded DECLARATION into the above, TYPE
% The DECLARATION ones are quite rare.
\item[Type] 
  These macros expand to a type or partial type (such as a storage class),
  or expand to a declaration (possibly missing its terminating semicolon).
  [[Not all such are caught in the ``type'' category; some get classified
  as ``multiple symbols''.]]  Examples include {\tt \#define \verb|__ptr_t|
  void *}, {\tt \#define \verb|__INLINE| extern inline}, {\tt \#define
private static}, {\tt \#define \verb|FLOAT_ARG_TYPE| union \verb|flt_or_int|}, and {\tt
\#define CMPtype SItype}.  As a result, these macros may be tricky to
understand, and cannot be eliminated via straightforward translation
(though C++ templates may provide some hope).



%%  mcat_SYNTAX: 189
%%    18%  mismatched_entities (34)
%%    82%  punctuation (155)
% This includes ( catUNBALANCED catPUNCTUATION )
\item[Syntactic]  The macro body is either punctuation (82\% of this
  category; for example, {\tt \#define AND ;}) or contains unbalanced
  parentheses, braces, or brackets.  The latter are often used to create a
  block and perform actions that must occur at its beginning and end, as
  for \verb|BEGIN_GC_PROTECT| and \verb|END_GC_PROTECT|.
  Macros in this category are inexpressible in the underlying programming
  language, but depend on the preprocessor's manipulation of uninterpreted
  token streams; see also section~\ref{sec:extralinguistic}.

%%  mcat_SYMBOL: 870
%%    1.7%  reserved_word (15)
%%    94%  function_name (820)
%%    4.0%  symbols (35)
%%  fudged to:
%%    1.8%  reserved_word (15)
%%    98%  function_name (820)

% @mcat_SYMBOL = qw( catRESERVED_WORD catFUNCTION_NAME catSYMBOLS);
\item[Symbol]
  The macro body is a single identifier that is either a function name
  (98\% of this category) or a reserved word (2\%, much of it uses of
  variable names such as {\tt new} which are reserved words in another
  C dialect).  A macro body which is a macro name inherits that macro's
  classification rather than appearing here.


%%  mcat_SYMBOL_UNKNOWN: 2765
%%    100%  unknown_symbol (2765)
% @mcat_SYMBOL_UNKNOWN = qw( catSYMBOL_UNKNOWN );
\item[Unknown symbol]
  The macro expands to a single symbol which is not defined in the package
  or in any library header files included by the package.  The symbol may
  be defined by compiler command arguments or may be used only inside an
  appropriate conditional compilation guard because it is only meaningful
  with a particular architecure, system, or library (for which we did not
  have header files available).
  
  Unknown symbols can also be variables or functions that we failed to
  parse.  Our approximate parser can succeed where an exact parse would not
  (as for unsyntactic code or entities interrupted by preprocessor
  directives), but sometimes fails to recognize declarations or
  definitions.


%%  mcat_NON_C_CODE: 639
%%    90%  command_line_arguments (574)
%%    10%  assembly_code (65)
% @mcat_NON_C_CODE = qw( catCOMMAND_LINE catASSEMBLY_CODE );
\item[Not C code]  The predominant use of such macros is for 
  filenames and operating system command lines (together, 90\% of this
  category) and assembly code (the remaining 10\%).  The former usually
  appear in a file which is used by the preprocessor when run over both
  code and Makefiles.\footnote{Cpp's specification states that its input
    should be syntactic C code, so it can avoid performing replacements in
    comments and string constants.  Cpp may not behave as expected when its
    input is not C, so it is good style to avoid such uses.  In practice,
    such uses have forced many C preprocessors to make fewer assumptions
    about their input than they otherwise might be able to.}  Our
  heuristics misclassify some such macros\,---\,after all, {\tt \#define
  \verb|SYSDEP_CFLAGS| -43 -w} creates a perfectly valid C expression.
(See the ``expression plus not C code'' line at 0.14\% in
figure~\ref{fig:subset-categories}.)  The assembly code component includes
only macros whose expansion is assembly code, not all expressions and
statements that contain snippets of assembly code.

%%  mcat_FAILURE: 802
%%    0.00%  uncategorized (0)
%%    7.9%  being_categorized (63)
%%    10%  never_defined (82)
%%    78%  failed_categorization (628)
%%    3.6%  multiply_categorized (29)
% @mcat_FAILURE = qw( catNOT_YET catIN_PROCESS catNO_DEF catFAILURE catMULTIPLE );
\item[Failed classification]
  Our tool failed to categorize less than 2\% of the 46462 definitions, and
  8 of the {\numpackages} packages had no macro classification failures.
  No one variety of macro stands out among the failures, so a more complete
  categorization is unlikely to affect our conclusions.
  
  Some failures resulted from limitations of our parser, which does not
  handle uses of pasting, and does not handle C++ or some non-portable C
  extensions.  Handling of partial entities is incomplete, so case labels
  and parts of structure declarations, and partial expressions are left
  unclassified.  Heuristics for recognizing operating system command lines
  or flags occasionally faied.  Additional failures result from macro
  bodies which cannot be unambiguously assigned to another category because
  their syntactic class depends on their arguments\,---\,such as {\tt
  \#define EXFUN(name, proto) name proto} and {\tt \#define
\verb|DO_OP|(OP,a,b) (a OP b)}.  Finally, macros in bodies were not
expanded (though their classifications were examined, causing a small
amount of cascading of failures when complicated or unclassified macros
appeared in other macro definitions.

\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "emp-use-2"
%%% End: 
