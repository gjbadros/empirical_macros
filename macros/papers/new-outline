Introduction
  The C preprocessor is viewed as a source of difficulty for understanding
  and transforming C programs -- most tools just preprocess, which has
  undesirable consequences.
  Indeed, in the worst case, this makes determing the program text as
  difficult as determining the output of an ordinary program.
  In order to assess the practical difficulty of understanding uses of CPP
  (and the potential for replacement by other language constructs), we
  examined actual CPP use in 30 programs comprising approximately 2 million
  lines of source code.

We identified and investigated a number of potential sources of complexity
in understanding and translating CPP, including:
 * high total use
 * complicated bodies
    * categories -- what it expands to (ie, the syntactic/parsing category)
    * properties -- what it uses internally (eg, stringization, pasting)
 * multiple definitions per name (and potential inconsistency)
 * high usage
 * where used (control, replacement)
 * mixed usage in conditional (control)
 * highly dependent
    * line dependent on many macros
    * macro controlling many lines
    * cppp experiment
One orthogonal point:
 * variation in use (no obvious point of attack) -- true throughout.
     No pattern according to package size, relative or absolute cppp use, etc.

Related work
  Strategies for CPP
  * real related work

Discussion
  Related work
    LCLint: core dumped
      describe methodology

Conclusion
  Future work
    Compare uses to definitions, to see if the lint problems are real or not.
    Do classification based on expansion, which can eliminate some failures
	(because after a few levels of expansion, what "symbols" means may
        become obvious).
    Do classification based on uses (eg, if every call passes a type, then
	treat that parameter as a type even if it might not be.

  Advice for cppp users

===========================================================================

[[Say this both early and late in the paper.]]
Take a stand about whether it's hard or not, and whether it's worthwhile or
not.  (We should conclude that it's not as hard as we thought it would be,
though we had to do a fair amount of engineering and examination of data to
find that what initially appeared problematic really wasn't after all.)
