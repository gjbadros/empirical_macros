%$Id$
%evil.bib

@string{ph = {Prentice-Hall}}
@string{ph:adr = "Englewood Cliffs, New Jersey"}
@string{aw = "Addison-Wesley"}
@string{aw:adr = "Reading, Massachusetts"}

@string{PARC = "Xerox Palo Alto Research Center"}

@string{fse94="Proceedings of SIGSOFT '94 Second ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{fse95="Proceedings of SIGSOFT '95 Third ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{fse96="Proceedings of SIGSOFT '96 Fourth ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{icse18 = "Proceedings of the 18th International Conference on
Software Engineering"}

@string{icse97 = "Proceedings of the 1997 International Conference on
Software Engineering"}


@TechReport{ellemtel92,
  author = 	 {Ellemtel Telecommunication Systems Laboratory},
  title = 	 {Programming in {C++}: Rules and Recommendations},
  institution =  {Ellemtel Telecommunications},
  year = 	 1992,
  address =	 {Sweden}
}


Update according to GCC manual?
@Manual{cpp-manual,
  title = 	 {{GNU} {C} Preprocessor Manual},
  author =	 {{GNU} Project},
  edition =	 {v2.7.2}
}

@Manual{GCC,
  title = 	 "Using and Porting {GNU} {CC}",
  author = 	 "Richard M. Stallman",
  organization = "Free Software Foundation",
  address = 	 "Boston, MA, USA",
  edition = 	 "2.7.2",
  year = 	 1996,
  month = 	 jun # "~29,",
}

@Manual{Stallman97,
  title = 	 {{GNU} Coding Standards},
  author =	 {Richard Stallman},
  organization = {{GNU} Project},
  year =	 1997,
  month =	 {July},
  note =	 {ftp://prep.ai.mit.edu/pub/gnu/standards/standards.texi}
}



@Misc{Deutsch90,
  author =	 {Deutsch, Peter},
  title =	 {ansi2knr},
  howpublished = {Freely available software program},
  year =	 1990,
  month =	 {December},
  note =	 {Included in the ghostscript distribution from Aladdin Enterprises}
}


@Manual{Cannon95,
  title = 	 {Recommended {C} Style and Coding Standards},
  author =	 {Cannon, L.W. and Elliott, R.A. and Kirchoff, L.W. and Miller, J.H. and Mitze, R.W. and Schan, E.P. and Whittington, N.O. and Spencer, Henry and Keppel, David and Brader, Mark},
  edition =	 {6.0},
  year =	 1995,
  month =	 {14 February}
}

@Manual{Dolenc90,
  title = 	 {Notes on Writing Portable Programs in {C}},
  author =	 {Dolenc, A. and Keppel, D. and Reilly, G.V.},
  edition =	 {8th Revision},
  year =	 1990,
  month =	 {November}
}

@InProceedings( Murphy-icse18,
  author= 	"Murphy, Gail C. and Notkin, David and Lan, Erica S.-C.",
  title= 	"{An empirical study of static call graph extractors}",
  booktitle= 	icse18,
  pages= 	"90--99",
  month= 	mar,
  year= 	1996
)

@book( Stroustrup-DesignEvolution,
  author=       "Stroustrup, Bjarne",
  title=        "The Design and Evolution of {C++}",
  publisher=    aw,
  address =	aw:adr,
  year=         1994
)

@InProceedings( Siff-fse96,
  author= 	"Siff, Michael and Reps, Thomas",
  title= 	"Program generalization for software reuse: From {C} to {C++}",
  booktitle= 	FSE96,
  pages= 	"135--146",
  month= 	oct,
  year= 	1996
)

@InProceedings( OCallahan-icse97,
  author= 	"O'Callahan, Robert and Jackson, Daniel",
  title= 	"{Lackwit}: A program understanding tool based on type 
                inference",
  booktitle= 	icse97,
  month= 	may,
  year= 	1997,
  notes=        "To appear."
)

@Book{ansi,
  author = 	 "Kernighan, Brian W. and Ritchie, Dennis M.",
  title = 	 "The {C} Programming Language",
  publisher = 	 ph,
  year = 	 1988,
  address =	 ph:adr,
  edition =	 "Second"
}

@Book{Carroll95,
  author = 	 {Carroll, Martin D. and Ellis, Margaret A.},
  title = 	 "Designing and Coding Reusable {C++}",
  publisher = 	 aw,
  address =	 aw:adr,
  year = 	 1995
}

@Book{Harbison91,
  author = 	 "Harbison, Samuel P. and Guy L. {Steele Jr.}",
  title = 	 "{C}: A Reference Manual",
  publisher = 	 ph,
  year = 	 1995,
  address =	 ph:adr,
  edition =	 "Fourth"
}

@InProceedings( Evans-fse94,
  author= 	"Evans, David and Guttag, John and Horning, Jim and Tan, Yang Meng",
  title= 	"{LCLint}: A tool for using specifications to check code",
  booktitle= 	FSE94,
  pages= 	"87--96",
  month= 	dec,
  year= 	1994
)

@InProceedings( Evans-pldi96,
  author= 	"Evans, David",
  title= 	"Static detection of dynamic memory errors",
  booktitle= 	"ACM SIGPLAN '96: Programming Language Design
		  and Implementation",
  pages= 	"44--53",
  month= 	may,
  year= 	1996
)

@InProceedings{Krone94,
  author = 	 {Krone, Maren and Snelting, Gregor},
  title = 	 "On the Inference of Configuration Structures from Source Code",
  booktitle = 	 {Proceedings of the 16th International Conference on Software Engineering},
  year =	 1994,
  publisher =	 {IEEE Computer Society Press},
  month =	 {May},
  pages =	 {49-57}
}

@TechReport{Zellweger83:TR,
  author = 	 "Polle T. Zellweger",
  title = 	 "An Interactive High-Level Debugger for Control-Flow
		  Optimized Programs",
  institution =  PARC,
  year = 	 1983,
  number =	 "CSL-83-1",
  address =	 "Palo Alto, California",
  month =	 Jan
}

@Manual{Evans:LCLint,
  title = 	 {LCLint User's Guide},
  author =	 {David Evans},
  OPTorganization = {},
  OPTaddress = 	 {},
  year =	 1996,
  month =	 Aug,
  note =	 {Version 2.2.  http://larch-www.lcs.mit.edu:8001/\discretionary{}{}{}larch/\discretionary{}{}{}lclint/\discretionary{}{}{}guide/\discretionary{}{}{}guide.html}
}


@InProceedings{WeiseC93,
  author =       "Daniel Weise and Roger Crew",
  title = 	 "Programmable Syntax Macros",
  booktitle =    "ACM SIGPLAN Conference on Programming Language Design and
  	         Implementation",
  year =	 1993,
  address =	 "Albuquerque, NM",
  month =	 jun,
  pages =        "156--165"
}
PLDI93, SIGPLAN Notices 6:28







W. G. Griswold, D. C. Atkinson, C. McCurdy, ``Fast, Flexible Syntactic
Pattern Matching and Processing,'' Proceedings of the IEEE 1996 Workshop on
Program Comprehension, March, 1996.
  Abstract:
"Program understanding can be assisted by tools that match patterns in the
program source. Lexical pattern matchers provide excellent performance and
ease of use, but have a limited vocabulary. Syntactic matchers provide more
precision, but may sacrifice performance, retargetability, ease of use, or
generality.
  "To achieve more of the benefits of both models, we extend the pattern
syntax of awk to support matching of abstract syntax trees, as demonstrated
in a tool called tawk. Its pattern syntax is language-independent, based on
abstract tree patterns. As in awk, patterns can have associated actions,
which in tawk are written in C for generality, familiarity, and
performance. The use of C is simplified by high-level libraries and dynamic
linking. To allow processing of program files containing non-syntactic
constructs, mechanisms have been designed that allow transparent matching
in a syntactic fashion. So far, tawk has been retargeted to the MUMPS and C
programming languages.
  "We survey and apply prototypical approaches to concretely demonstrate the
tradeoffs. Our results indicate that tawk can be used to quickly and easily
perform a variety of common software engineering tasks, and the extensions
to accommodate non-syntactic features significantly extend the generality
of syntactic matchers."
  My comments:
  I read a draft longer version (apparently word-for-word from the workshop,
but with some additions such as expanded related work).
  The goal is to provide a version of grep or awk customized for a
particular programming language:  permit programmers to easily make queries
over abstract syntax trees, not just the characters in a file.  The first
half of the paper just reviews other tools (AWK, MAWK, LSME, Scruple, A*,
Genoa) and gives examples of building call graphs from them.  The authors
conclude that matching power, flexibility, and scalability are key (see
section 4).  Their solution is TAWK, which builds an abstract syntax tree
and permits regular expressions that are based on it.  As such, it is much
more specialized to its task than are the other tools.
  For each new language, a full parser must be written (or hooked into an
existing grammar).  Actions are written in C for execution speed, and
dynamically linked for compilation/loading speed.  Users may specify on the
command line that certain symbols are typedefs.  An expert user could do a
lot with this; but after how much overhead and learning curve?
  Section 6.2 discusses macros at some length; the approach is to try parsing
the body.  If the macro body parses as a C expression or statement
(possibly sans a trailing semicolon), then leave it in the parse tree,
along with putting it in a global data structure.  (The authors state that
Scruple makes a similar suggestion for handling macros.)  Otherwise, first
try parsing assuming that each macro argument (in turn) is a typedef; if
those parses all fail, then expand the macro.  (A special version of cpp
does this, and emits pragmas for type arguments and typedefs.)  The claim
is that this works for the vast majority of macros.  This is somewhat
plausible, but apparently no testing was done on programs that support
multiple dialects/languages, etc.
  The paper compares the various call graph extraction algorithms; naturally
tawk wins.  It also discusses how well macros are coped with -- only 4% to
9% of uses need to be expanded (or is that uses of 4% to 9% of macros need
to be expanded?), but this apparently doesn't include header files.  Most
of the macros that are expanded have empty bodies.
  Formatting:
Lots of confusion over "cawk" vs "tawk"; was the name recently changed?
LaTeX spacing:  "C." should be "C\<atsign>."; "\. T" should be ". T".

Greg Minshall suggests
   Evan Adams: The Old Man and the C. USENIX Summer 1994: 15-26
I don't see the relevance and didn't get past the second page.  This is an
anecdotal, meandering account of a group of C programmers who decided to
switch their project to C++.  It describes what features they used and
which they avoided.  The audience is programmers with no knowledge of C++.


Need to add reference on CCEL.
Also CodeWizard, which implements the tests in Scott Myers's books:
     http://www.parasoft.com/wizard/papers/tech.htm




@InProceedings{SpencerC92,
  author = 	 "Henry Spencer and Geoff Collyer",
  title = 	 "\#ifdef Considered Harmful, or Portability Experience with C News",
  booktitle = 	 "Usenix Summer 1992 Technical Conference",
  year =	 1992,
  address =	 "San Antonio, Texas",
  month =	 jun # "~8-12,",
  pages =	 "185-197",
  url = 	 "http://9www.x.bell-labs.com/user/geoff/ifdefs.ps.Z",
}
Abstract:
  We believe that a C programmer's impulse to use #ifdef in an attempt at
  portability is usually a mistake.  Portability is generally the result of
  advance planning rather than trench warfare involving #ifdef.  In the
  course of developing C News on different systems, we evolved various
  tactics for dealing with differences among systems without producing a
  welter of #ifdefs at points of difference.  We discuss alternatives to,
  and occasional proper use of, #ifdef.
While this paper talks a fair amount about #ifdef, it is more about
portability -- and even just good software engineering, such as advance
planning.  It makes strong arguments against most uses of #ifdef.  The
concluding paragraph:
  In our experience, #ifdef is usually a bad idea (though we do use it in
  places).  Its legitimate uses are fairly narrow, and it gets abused
  almost as badly as the notorious goto statement.  Like the goto, the
  #ifdef often degrades modularity and readability (intentionally or not).
  Given some advance planning, there are better ways to be portable.
The authors provide a number of principles to follow, such as
 * define a portable interface used everywhere, then provide multiple
   implementations of that interface for different systems.
 * use #ifdef only in declarations and macro definitions, never at call sites.
 * choose a standard interface, implementing it if your system's is broken
   or missing.
 * write shell scripts or use standard programs (ls, du) instead of C code
 * abolish arbitrary numeric limits; use dynamically-sized objects instead
 * choose among including separate files, rather than merging them via #ifdef
They give some statistics about C News; in 1000 lines of header files and
20,000 lines of C, they use only 166 #ifdefs.  Apparently #ifndef is
included in this count; they don't say whether #if defined(X) is included.
This isn't directly comparable to our statistics, but here's a try:
  Assume that 30% of lines are comments or code (the average over 30 packages).
  Assume that 30% of all conditional lines are #if[n]def (also the average).
  Then they have 14375 = (* (+ 19762 955) (/ 136 196.0)) NCNB lines, of which
  543 = (* 166 (/ (+ 202  6902  25844  8871  13433  4966 0.0) (+ 13433  4966)))
  are conditionals, or 3.78% = (/ 54300.0 14375).
  3.8% is under our average of 4.4%, and for a highly portable program.
They also break down the 166 uses of #ifdef into categories:
 * providing defaults (#ifndef X  #define X  default #endif)
 * commenting
 * configuration
 * multiple inclusion prevention
 * __STDC__
 * pdp11
 * lint
 * sccsid
 * STATS
 * other (just one in this category)
