%$Id$
%evil.bib

@string{ph = {Prentice-Hall}}
@string{ph:adr = "Englewood Cliffs, New Jersey"}
@string{aw = "Addison-Wesley"}
@string{aw:adr = "Reading, Massachusetts"}

@string{PARC = "Xerox Palo Alto Research Center"}

@string{fse94="Proceedings of SIGSOFT '94 Second ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{fse95="Proceedings of SIGSOFT '95 Third ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{fse96="Proceedings of SIGSOFT '96 Fourth ACM SIGSOFT Symposium
on the Foundations of Software Engineering"} 

@string{icse18 = "Proceedings of the 18th International Conference on
Software Engineering"}

@string{icse97 = "Proceedings of the 1997 International Conference on
Software Engineering"}


@InProceedings( Murphy-icse18,
  author= 	"Murphy, Gail C. and Notkin, David and Lan, Erica S.-C.",
  title= 	"{An empirical study of static call graph extractors}",
  booktitle= 	icse18,
  pages= 	"90--99",
  month= 	mar,
  year= 	1996
)

@book( Stroustrup-DesignEvolution,
  author=       "Stroustrup, Bjarne",
  title=        "The Design and Evolution of {C++}",
  publisher=    aw,
  address =	aw:adr,
  year=         1994
)

@InProceedings( Siff-fse96,
  author= 	"Siff, Michael and Reps, Thomas",
  title= 	"Program generalization for software reuse: From {C} to {C++}",
  booktitle= 	FSE96,
  pages= 	"135--146",
  month= 	oct,
  year= 	1996
)

@InProceedings( OCallahan-icse97,
  author= 	"O'Callahan, Robert and Jackson, Daniel",
  title= 	"{Lackwit}: A program understanding tool based on type 
                inference",
  booktitle= 	icse97,
  month= 	may,
  year= 	1997,
  notes=        "To appear."
)

@Book{ansi,
  author = 	 "Kernighan, Brian W. and Ritchie, Dennis M.",
  title = 	 "The {C} Programming Language",
  publisher = 	 ph,
  year = 	 1988,
  address =	 ph:adr,
  edition =	 "Second"
}

@Book{Carroll95,
  author = 	 {Carroll, Martin D. and Ellis, Margaret A.},
  title = 	 "Designing and Coding Reusable {C++}",
  publisher = 	 aw,
  address =	 aw:adr,
  year = 	 1995
}

@Book{Harbison91,
  author = 	 "Harbison, Samuel P. and Guy L. {Steele Jr.}",
  title = 	 "{C}: A Reference Manual",
  publisher = 	 ph,
  year = 	 1995,
  address =	 ph:adr,
  edition =	 "Fourth"
}

@InProceedings( Evans-fse94,
  author= 	"Evans, David and Guttag, John and Horning, Jim and Tan, Yang Meng",
  title= 	"{LCLint}: A tool for using specifications to check code",
  booktitle= 	FSE94,
  pages= 	"87--96",
  month= 	dec,
  year= 	1994
)

@InProceedings( Evans-pldi96,
  author= 	"Evans, David",
  title= 	"Static detection of dynamic memory errors",
  booktitle= 	"ACM SIGPLAN '96: Programming Language Design
		  and Implementation",
  pages= 	"44--53",
  month= 	may,
  year= 	1996
)

@InProceedings{Krone94,
  author = 	 {Krone, Maren and Snelting, Gregor},
  title = 	 "On the Inference of Configuration Structures from Source Code",
  booktitle = 	 {Proceedings of the 16th International Conference on Software Engineering},
  year =	 1994,
  publisher =	 {IEEE Computer Society Press},
  month =	 {May},
  pages =	 {49-57}
}

@TechReport{Zellweger83:TR,
  author = 	 "Polle T. Zellweger",
  title = 	 "An Interactive High-Level Debugger for Control-Flow
		  Optimized Programs",
  institution =  PARC,
  year = 	 1983,
  number =	 "CSL-83-1",
  address =	 "Palo Alto, California",
  month =	 Jan
}

@Manual{Evans:LCLint,
  title = 	 {LCLint User's Guide},
  author =	 {David Evans},
  OPTorganization = {},
  OPTaddress = 	 {},
  year =	 1996,
  month =	 Aug,
  note =	 {Version 2.2.  http://larch-www.lcs.mit.edu:8001/\discretionary{}{}{}larch/\discretionary{}{}{}lclint/\discretionary{}{}{}guide/\discretionary{}{}{}guide.html}
}


@InProceedings{WeiseC93,
  author =       "Daniel Weise and Roger Crew",
  title = 	 "Programmable Syntax Macros",
  booktitle =    "ACM SIGPLAN Conference on Programming Language Design and
  	         Implementation",
  year =	 1993,
  address =	 "Albuquerque, NM",
  month =	 jun,
  pages =        "156--165"
}
PLDI93, SIGPLAN Notices 6:28




@Manual{GCC,
  title = 	 "Using and Porting {GNU} {CC}",
  author = 	 "Richard M. Stallman",
  organization = "Free Software Foundation",
  address = 	 "Boston, MA, USA",
  edition = 	 "2.7.2",
  year = 	 1996,
  month = 	 jun # "~29,",
}



W. G. Griswold, D. C. Atkinson, C. McCurdy, ``Fast, Flexible Syntactic
Pattern Matching and Processing,'' Proceedings of the IEEE 1996 Workshop on
Program Comprehension, March, 1996.
  Abstract:
"Program understanding can be assisted by tools that match patterns in the
program source. Lexical pattern matchers provide excellent performance and
ease of use, but have a limited vocabulary. Syntactic matchers provide more
precision, but may sacrifice performance, retargetability, ease of use, or
generality.
  "To achieve more of the benefits of both models, we extend the pattern
syntax of awk to support matching of abstract syntax trees, as demonstrated
in a tool called tawk. Its pattern syntax is language-independent, based on
abstract tree patterns. As in awk, patterns can have associated actions,
which in tawk are written in C for generality, familiarity, and
performance. The use of C is simplified by high-level libraries and dynamic
linking. To allow processing of program files containing non-syntactic
constructs, mechanisms have been designed that allow transparent matching
in a syntactic fashion. So far, tawk has been retargeted to the MUMPS and C
programming languages.
  "We survey and apply prototypical approaches to concretely demonstrate the
tradeoffs. Our results indicate that tawk can be used to quickly and easily
perform a variety of common software engineering tasks, and the extensions
to accommodate non-syntactic features significantly extend the generality
of syntactic matchers."
  My comments:
  I read a draft longer version (apparently word-for-word from the workshop,
but with some additions such as expanded related work).
  The goal is to provide a version of grep or awk customized for a
particular programming language:  permit programmers to easily make queries
over abstract syntax trees, not just the characters in a file.  The first
half of the paper just reviews other tools (AWK, MAWK, LSME, Scruple, A*,
Genoa) and gives examples of building call graphs from them.  The authors
conclude that matching power, flexibility, and scalability are key (see
section 4).  Their solution is TAWK, which builds an abstract syntax tree
and permits regular expressions that are based on it.  As such, it is much
more specialized to its task than are the other tools.
  For each new language, a full parser must be written (or hooked into an
existing grammar).  Actions are written in C for execution speed, and
dynamically linked for compilation/loading speed.  Users may specify on the
command line that certain symbols are typedefs.  An expert user could do a
lot with this; but after how much overhead and learning curve?
  Section 6.2 discusses macros at some length; the approach is to try parsing
the body.  If the macro body parses as a C expression or statement
(possibly sans a trailing semicolon), then leave it in the parse tree,
along with putting it in a global data structure.  (The authors state that
Scruple makes a similar suggestion for handling macros.)  Otherwise, first
try parsing assuming that each macro argument (in turn) is a typedef; if
those parses all fail, then expand the macro.  (A special version of cpp
does this, and emits pragmas for type arguments and typedefs.)  The claim
is that this works for the vast majority of macros.  This is somewhat
plausible, but apparently no testing was done on programs that support
multiple dialects/languages, etc.
  The paper compares the various call graph extraction algorithms; naturally
tawk wins.  It also discusses how well macros are coped with -- only 4% to
9% of uses need to be expanded (or is that uses of 4% to 9% of macros need
to be expanded?), but this apparently doesn't include header files.  Most
of the macros that are expanded have empty bodies.
  Formatting:
Lots of confusion over "cawk" vs "tawk"; was the name recently changed?
LaTeX spacing:  "C." should be "C\<atsign>."; "\. T" should be ". T".

Greg Minshall suggests
   Evan Adams: The Old Man and the C. USENIX Summer 1994: 15-26
I don't see the relevance and didn't get past the second page.  This is an
anecdotal, meandering account of a group of C programmers who decided to
switch their project to C++.  It describes what features they used and
which they avoided.  The audience is programmers with no knowledge of C++.


Need to add reference on CCEL.
Also CodeWizard, which implements the tests in Scott Myers's books:
     http://www.parasoft.com/wizard/papers/tech.htm
