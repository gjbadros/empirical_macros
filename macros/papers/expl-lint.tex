
\begin{description}
\item[free variables]
  As before.

\item[multiple formal uses]
        Some argument is used as an expression multiple times, so any side
        effects in the expression will occur multiple times.

        In some, but not all, C dialects there ways to declare a local
          variable so that each formal only need be used once.  Eg, GNU C:
          give an example.


\item[unparenthesized formal uses]
        Some argument is used as a subexpression (ie, adjacent to an
        operator) without being enclosed in parentheses, so that precedence
        rules could result in an unanticipated computation being performed.
        For instance, in
\begin{verbatim}
                #define DOUBLE(i) (2*i)
                DOUBLE(3+4)
\end{verbatim}
        the macro body computes the value 10, not 14.
        This warning is suppressed when the argument is the entire body
        or is the last element of a comma-delimited list.

\item[unparenthesized body]
        The macro body is an expression which ought to be parenthesized.
        This warning is suppressed if the body is a single token or a
        function call (which has high precedence).  Since this is
        applicable only to mcros that expand to an expression (69\% of all
        macros), it's more common than it looks

\item[doesn't swallow semicolon]
        The macro body takes arguments and expands into a statement or
        multiple statments.  Thus, its uses look like function calls, but
        it cannot be legally used where a function call can be, as in
\begin{verbatim}
             if (*p != 0)
               MACRO_CALL (p, lim);
             else ...
\end{verbatim}
        because the presence of two statements -- the expansion of the macro and
        a null statement -- between the `if' condition and the `else'
        is unsyntactic.  The solution is to wrap the macro body in
\begin{verbatim}
             do {...} while (0);
\end{verbatim}

        [[This, too, is more common than it looks, as it applies only to a
        small fraction (5.7\%) of macro definitions.]]

        [[Perhaps ditch this as redundant.]]
Since the body is already a complete statement, the
      extra semicolon can cause problems such as mis-parsing of nested {\tt
      if} statements.  Such macros can be confusing to use, because
    programmers are inclined to add a semicolon after invocations that look
    like functions; wrapping the body in {\tt do \{\ldots\} while (0)}, a
    partial statement which requires a trailing semicolon, solves this
    problem.  To our surprise, we found few uses of that construct, but
    many error-prone instances of a macro that expanded to a statement like
    \{\ldots\} in which a call to the macro was immediately followed by a
    semicolon.

\item[null body with arguments]
        The macro is of the form {\tt \#define name(e)} 
        which might have been intended to be {\tt \#define name (e)}[
        This warning is suppressed if a comment appears where the macro
        body would be, as in
\begin{verbatim}
  #define name(e)         /**/
  #define name(e)         /* Do nothing in the FOO case */
\end{verbatim}

\item[side-effected formal]
        A formal argument is side-effected.  This is erroneous if the
        argument is not an lvalue.

        [[What about side-effected free variables?  Not erroneous, but may
        cause unexpected consequences.]]

\item[inconsistent arity]
        The macro name is defined multiple times with different arity.
        This (and ``all warnings by name'') is reported as a percentage of
        names; other numbers are reported as a percentage of definitions.

\item[bad formal name]
        The formal name is not a valid identifier or is a reserved word in
        some dialects of C (eg, {\tt new}).  CPP will work fine, but a
        programmer reading the body may become confused.
        [[This is usually the case for ``reserved word'' as symbol, too.]]

\end{description}



%%% Local Variables: 
%%% mode: latex-mode
%%% TeX-master: "emp-use-2"
%%% End: 
