\label{desc:properties}

\begin{description}
\item[Free variables]
  The macro body uses as a subexpression (that is, applies an operator or
  function to) a symbol which is not a formal argument, a variable defined
  in the macro body, or a function, macro, typedef, or reserved word.  Such
  symbols are typically local or global variables.  Uses of global
  variables are generally innocuous; uses of local variables (in which the
  local definition in scope at the point of use captures the free variable
  in the macro body) can be used to achieve dynamic scoping, which C does
  not directly support.  We did not separately analyze global and local
  free variables.

\item[Assignment]
  The macro body side-effects state via assignment (of the form {\tt =},
  {\tt {\em op}=}, {\tt -{}-}, or {\tt ++}).  We did not look for calls to
  functions or macros that might have side effect, nor did we discount side
  effects to variables local to the macro body.  
  
  Macros containing assignment operators have potentially unexpected
  results (doubly so for those with no arguments, whose invocations look
  like variable uses, not function calls).  A macro argument that is
  assigned to is similar to a pass-by-reference function argument and need
  only be noted in the macro's documentation.  A macro that assigns a
  global variable also presents no difficulties in understanding or
  translation into a C++ inline function.  Assignment to other variables
  free in the macro body demands that such a variable exist wherever the
  macro is invoked, and assigns to different variables at different
  invocations.\footnote{[[To related work?: By contrast, LCLint considers
    assignment to a macro argument dangerous but does not appear to check
    for assignments to local variables.~\cite{Evans:LCLint}]]} Such a macro
  implements a restricted form of dynamic scoping by capturing the instance
  of a variable visible at the point of macro invocation.

[[IMPORTANT:  Should this even be here?  Assignment isn't extra-linguistic!]]

\item[Use macro as type]
  In this macro's body, the result of another macro invocation is used as a
  type\,---\,for instance, in a declaration or a type cast.  C cannot
  simulate this behavior, because its types are not first class; they may
  not be passed to functions, returned as results, or otherwise
  manipulated.

\item[Pass type as argument]
  In this macro's body, a literal type is passed to another macro, as in
  {\tt \#define PTRBITS \verb|__BITS|(char*)}.  Like using a macro result
  as a type, this is impossible in C\@.

\item[Pasting]
  The body uses symbol pasting ({\tt \#\#}), which treats its arguments not
  as tokens but as strings, constructing a new token out of their
  concatenation, as in {\tt \#define \verb|_SIZEOF|(x) \verb|sz_|\#\#x}.
  The resulting symbol might appear literally, or only as a pasted symbol,
  at its other uses.  Since pasting is often abstracted out into a separate
  macro\,---\,such as {\tt \#define \verb|__CONCAT|(x,y) x \#\#
  y}\,---\,the incidence of pasting is higher than the direct uses
  reflected by this statistic.

\item[Use argument as type]
  This macro uses one of its arguments as a type.  Not all uses can be
  unambiguously identified lexically.  For instance, the macro 
  {\tt \#define \verb|MAKE_DECL|(type, name) type name;}
  is not identified as necessarily using its first argument as a type, for
  it might be invoked as {\tt \verb|MAKE_DECL|(printf, ("hello
  world\verb|\|n"))} or as {\tt \verb|MAKE_DECL|(x =, y+z)}.
  Like using a macro result
  as a type, this is impossible in C\@.

\item[Self-referential]
  The body refers to its own name, as in {\tt \#define LBIT vcat(LBIT)}.
  This feature is used when building a wrapper around an existing function
  or variable.  Since the ISO C preprocessor performs only one level of
  expansion on such recursively defined macros,\footnote{Pre-ANSI
    implementations were permitted to loop forever when expanding
    self-referential macros.} the expanded macro contains a reference to
  the original name.

\item[Stringization]
  The body uses argument stringization ({\tt \#}), which converts its
  argument from a token stream into a string.  Examples include {\tt
  \#define spam1(OP,DOC) \verb|{|\#OP, OP, 1, DOC\verb|}|,} (the comma is
part of the macro body) and {\tt \#define REG(xx) register long int xx asm
(\#xx)}.  No C or C++ language mechanism can replace such macros.  This
feature is particularly useful in debugging, in order to print or record
the exact operations being performed.

\end{description}

