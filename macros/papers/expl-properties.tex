\label{desc:properties}

\begin{description}
\item[Free variables]\label{page:freevar}
  The macro body uses as a subexpression (that is, applies an operator or
  function to) a symbol which is not a formal argument, a variable defined
  in the macro body, or a function, macro, typedef, or reserved word.  Such
  symbols are typically local or global variables.  Uses of global
  variables are generally innocuous; uses of local variables (in which the
  local definition in scope at the point of use captures the free variable
  in the macro body) can be used to achieve dynamic scoping, which C does
  not directly support.  We did not separately analyze global and local
  free variables.

\item[Assignment]
  The macro body side-effects state via assignment (of the form {\tt =},
  {\tt {\em op}=}, {\tt -{}-}, or {\tt ++}).  We did not look for calls to
  functions or macros that might have side effect, nor did we discount side
  effects to variables local to the macro body.  
  
  Assignment is not extra-linguistic per se, but macros containing
  assignment operators have potentially unexpected results (doubly so for
  those with no arguments, whose invocations look like variable uses, not
  function calls), some of which lie outside the scope of C\@.  A macro
  argument that is assigned to is similar to a pass-by-reference function
  argument and need only be noted in the macro's documentation.  A macro
  that assigns a global variable also presents no difficulties in
  understanding or translation into a C++ inline function.  Assignment to
  other variables free in the macro body demands that such a variable exist
  wherever the macro is invoked, and assigns to different variables at
  different invocations.  Such a macro implements a restricted form of
  dynamic scoping by capturing the instance of a variable visible at the
  point of macro invocation.

\item[Use macro as type]
  In this macro's body, the result of another macro invocation is used as a
  type\,---\,for instance, in a declaration or a type cast.  C cannot
  simulate this behavior, because its types are not first class; they may
  not be passed to functions, returned as results, or otherwise
  manipulated.

\item[Pass type as argument]
  In this macro's body, a literal type is passed to another macro, as in
  {\tt \#define PTRBITS \verb|__BITS|(char*)}.  Like using a macro result
  as a type, this is impossible in C\@.

\item[Pasting]\label{def:pasting}
  The body uses symbol pasting ({\tt \#\#}), which treats its arguments not
  as tokens but as strings, constructing a new token out of their
  concatenation, as in {\tt \#define \verb|_SIZEOF|(x) \verb|sz_|\#\#x},
  after which the macro invocation {\tt \verb|_SIZEOF|(int)} expands to the
  symbol {\tt sz_int}.  The resulting symbol might appear literally, or
  only as a pasted symbol, at its other uses.  Since pasting is often
  abstracted out into a separate macro\,---\,such as {\tt \#define
  \verb|__CONCAT|(x,y) x \#\# y}\,---\,the incidence of pasting is higher
than the direct uses reflected by this statistic.

\item[Use argument as type]
  This macro uses one of its arguments as a type.  Not all uses can be
  unambiguously identified lexically.  For instance, the macro 
  {\tt \#define \verb|MAKE_DECL|(type, name) type name;}
  is not identified as necessarily using its first argument as a type, for
  it might be invoked as {\tt \verb|MAKE_DECL|(printf, ("hello
  world\verb|\|n"))} or as {\tt \verb|MAKE_DECL|(x =, y+z)}.
  Like using a macro result
  as a type, this is impossible in C\@.

\item[Self-referential]
  The body refers to its own name, as in {\tt \#define LBIT vcat(LBIT)}.
  This feature is used when building a wrapper around an existing function
  or variable.  Since the ISO C preprocessor performs only one level of
  expansion on such recursively defined macros,\footnote{Pre-ANSI
    implementations were permitted to loop forever when expanding
    self-referential macros.} the expanded macro contains a reference to
  the original name.

\item[Stringization]
  The body uses argument stringization ({\tt \#}), which replaces its
  argument (a preprocessor symbol) by its contents as a C string.  After
  {\tt \#define FOO BAR BAZ}, the expression {\tt \#FOO} expands to {\tt
  "BAR~BAZ"}.  Examples using stringization include
\begin{verbatim}
    #define spam1(OP,DOC) {#OP, OP, 1, DOC},
    #define REG(xx) register long int xx asm (#xx)
\end{verbatim}
  No C or C++ language mechanism can replace such macros.  This feature is
  particularly useful in debugging, in order to print or record the exact
  operations being performed.

\end{description}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "emp-use-2"
%%% End: 
