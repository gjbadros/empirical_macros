#!/uns/bin/perl -w
# $Id$
# evilmacros

# TERMS:
#   project file == a file passed in via -i, or on cmd line
#                   it is also called an NI (not-included) file
#   system file == a file that got parsed because another file
#                  #include-d it
#   ncnb == non-comment, non-blank; a line containing code
#   c_ == count of, an integer variable
#   rg_ = region, an array of indices for extracting slices from another array
#   _ni = non-include; for a file, means it was on command line (?)
#   mi = method of inclusion; why this file is being processed

# Can't use "use", as it is executed upon parsing even if in guard.
BEGIN { if (defined $ENV{"PERLINC"})
	  { unshift(@INC, split(/[ :]+/, $ENV{"PERLINC"})); } }

# Fix: I want to use '-$' like cpp does, not '-l'; how to do this?
my $getopts_option_letters = 'ihvtIAau1pTlg:d:D:M:S:F:L:C:E:P:';

# fix: remove -D -U -S -F -L -C options.

# Remove the asterisks below when the options are known to the users.

sub usage () {
  die "@_\nUsage: $0 [-$getopts_option_letters] <files>
New options marked with *; options with ':', above, take an argument
  -i  use files listed on stdin [one per line] in addition to any on cmd line
  -h  display this help message
  -v  be verbose and list files as they are processed to stderr
  -t  use [TAB] as the OFS for the statistics files (not space)
  -I  ignore include files--just parse files passed in
  -A  do the second pass on all files, not just those passed in
  -a  do macro statistics on all files, not just those passed in
  -u  ignore usage [hey, explain this!]
  -1  do only the first pass (don't do function parsing, usage)
	This is a numeral 1, not a lowercase L.
* -l  forbid the use of `\$' in identifiers, per ANSI standard
	This is a lowercase L, not a numeral 1.
* -g [num]  set the num'th debugging option to true  {ought to be able to name}
	-g 0 turns off all debugging flags.
* -T  run tests instead of main code body
* -d [directory:basename]  use standard filenames under the given directory
	If basename is not supplied, use extensions (sans .) as whole name.
  -D [file]  output the names of the macros (and number of times defined)
  -U [file]  output macro usage information
  -S [file]  output the per directive statistics to file
  -F [file]  output the function information to a file
  -L [file]  output the file's lines/functions information to a file
  -C [file]  show categorizations to file
  -E [file]  send evil macros to file instead of stdout
  -P [file]  send parse errors to file instead of stdout
  -p  send parse errors to stdout even if also sending to file

(Note: -{D,S,F,C,E,P} options take precedence over the -d option)

e.g.

find-c | evilmacros -iv -d ~/macros/data/stable
";
}

# Invoke like this:   evilmacros `find-c`
# or like this:  find-c | evilmacros -i

#Complex execution (use zsh):    (how do I set $TM in zsh?)
#
# for i in *(/); do echo $i; pushd $i; find-c | evilmacros -i -d $TM:${i%%-*} >$TM/${i%%-*}.out 2> $TM/${i%%-*}.err; popd; done
#
# For a second run for first-run failures:
# for i in *(/); do if [[ ! -s $TM/${i%%-*}.stat ]]; then echo $i; pushd $i; find-c | evilmacros -i -d $TM2:${i%%-*}1 >$TM2/${i%%-*}.out 2>$TM2/${i%%-*}.err ; popd; fi; done
#
#
# ext=all; p=~/505/data; for i in *(/); do pushd $i; find-c | nice evilmacros -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# alias find-c='find . \( -name UNUSED -o -name CVS -o -name SCCS -o -name RCS \) -prune -o \( -name "*.[chCH]" -o -name "*.[cC][cC]" -o -name "*.[cC][pP][pP]" \) -print'
# ext=all; p=/tmp/mernst/data; for i in *(/); do pushd $i; find-c | nice /homes/rivers/mernst/research/notkin/macros/evilmacros-961223 -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# Bad idea: it's best to operate on an entire project, so you know all the
# functions, macros, etc.
# evilmacros -d ../ -v getopt.c
# evilmacros -v -d ../../:reg /usr/include/stdlib.h
## Other interesting options: -A -T -g 6
# find-c | evilmacros -v -p -d ../../:evilout -i

# Harbison & Steele p. 53:
#   ISO C reaffirms that macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.


###########################################################################
### To do
###

# Categorize essential macros.

# Make sure info about uses of built-in macros like __STDC__ gets output.

# fixgjb:
#    Change current_line_no() into two functions which return
#    the first and last physical lines associated with the current lines being
#    processed; in general, prefer the former to the latter, except when
#    the end of a function definition, etc.
#
# Small code stuff:
#  * when body = expression + semicolon, warn; but check that every use of
# 	the macro is followed by a semicolon, and if so, eliminate the one
# 	in the body (ie, converts to function not returning void).
#       Or check the context: is it void?
#  * Maybe look at whole functions at a time rather than being line-oriented,
#    or break on semicolons or braces instead of newlines.  But sometimes
#    when we're confused, restarting at the next newline is the right thing to do.

# All calls to get_fulltoken_line should check the result value before
# using it (might get to end of file).

# Uniformize uses of $type_declarator_re.
# Probably don't need the type special cases any more.

# Break some huge regexps into separate tests for smaller pieces, which is
# more efficient.

# Optionally specify values for certain macros (such as __STDC__: always
# take the true branch and omit a lot of hard declaration-munging
# nonsense).

# Collect statistics on number of lines dependent on each particular macro.

# Small projects:
#  * Recognize macros that build assembly code, and treat/report specially?
# 	(What % of interesting macros are such?  Very few, I think.)
#  * Look for macro definitions from makefiles (-D option to compiler)
# 	We can't know all the things that are macros, but can try.
#	[Greg will do this.]
#  * Try other (non-gcc) preprocessors on the problematic stuff, to see if they
# 	deal with it identically.
#  * Get more packages (eg GNAT), until nishin:/tmp is full.  Then stop.
#	In particular, get elk and saoimage.
# 	/tmp policy is basically that they'll try not to blow stuff away
#  * Add additional pass for function and global types before inferring macro
# 	invocation types.  Does a tool already exist to compute this for us?
#	Perhaps this isn't necessary if processing #includes in order??
# 
# Major projects:
#  * convert from macros into language constructs; see if code still works.
# 	Perhaps do this by hand for some small codebase.
# 	Need to worry about new files, #include, extern, etc.
#  * dependentmacros, showing which macros' values depend on the values of
# 	other macros.  Perhaps only the non-dependent ones need to be true
# 	macros, while the others can be turned into consts.
#	Also do this per line a la Krone & Snelting.
#  * do type inference for macro arguments, type lookup for globals and functions.
# 	This entails checking for free variables and more.
#  * find all non-dependent macros -- including those mentioned in #if lines.
#  *  (maybe
# 	do this automatically by reading lots of standard header files?
# 	Then note which header files have been read so we don't reread them.)
#  * check for side effects in macros (eg, function calls in an argumentless
# 	macro probably prevent it from being turned into a const, unless
# 	the call is to a known side-effect-less library function.  This requires
#	me to write side-effect specifications for library functions; don't
#	do so unless I determine this is valuable.  This is interesting only
#	in constant-like macros that make function calls; the compiler will
#	do it for function-like macros that get converted in to functions.
#  * Track assigned-to lvalues, but remember whether it's to a macro arg (in
# 	which case it must be passed by reference) or to a global (which is
# 	hunky-dory) or to a local (which is evil).  The latter is evil anyway,
#	so maybe assignment is never a problem?
#  * Check for/recognize template-like macros (that take a type as an argument).
#  * for lightweight (non-parsing) tool, determine the effect a macro would
# 	have on parser state, e.g. like a function call, a block, a
# 	statement, a constant, etc.
#  * Move conditional compilation into inline functions (to unclutter source).
#	For instance, change #if #def #else #def #endif into
#	inline { #if #else #endif }; is the latter really better?

#  * Analysis of purpose of each define and other preprocessor command (eg,
# 	portability, efficiency, etc.), like that done by hand for gzip.

# Perhaps do something special about macros that expand into reserved words.
# Specially recognize types, partical declarations.
# 
# I want to recognize that these are type macros (maybe hard, maybe not) and
# that for each the two alternate definitions are equivalent.
# #  define EXTERN(type, array)  extern type * near array
# #  define DECLARE(type, array, size)  type * near array
# #  define EXTERN(type, array)  extern type array[]
# #  define DECLARE(type, array, size)  type array[size]
# 
# deflate.c defines check_match sometimes as a macro and sometimes as a
# function.  (This is for debugging, but one can imagine other reasons.)
# Perhaps remember what the macro is dependenton and if exclusive with the
# definition, don't conflict; also cope with this later.
# 
# PreventMI line count should include the #ifdef and the #endif.
# 
# Look for shadowed globals, also for whether specific globals are ever
# assigned (which is irrelevant for function-like macros, but essential for
# const-like macros).
# 
# Another use of macros is to either "import" or "export" in a header file
# depending on whether you are that DLL or some other user.



###########################################################################
### Strictures
###

# Use strict requires that for each global, either
#  * all uses are fully qualified with the package name ($main::$true), or
#  * it is declared with "my" or appears in a use vars qw( ... ) declaration.
use strict;
## This gives Mike an error as of 1/27/97.
# use diagnostics;

# Permit use of $MATCH for $& and so forth.
use English;

## Other packages

use Carp;
use checkargs;


###########################################################################
### Constants
###

### Boolean
my $true = (1 == 1);
my $false = (1 == 0);

# some evilness (pasting, stringization) is independent of the others,
# though it may not be able to be classified (actually, stringization
# is pretty easy to classify, when we see that a macro argument follows #).
# In this case evilness is more need-for-preprocessor.

# Also note that some evilness has to do with whole files, or parsing,
# while other has to do with macros that have to be macros.
# Maybe rename the latter from "evil" to "macrofeature" or some such.

# These should probably be merged into failure categories, below
my $OBSOLETE = 1;
my $DANGER = 2;
my $EVIL = 3;
my $ILLEGAL = 4;

# Nonconstant: free var (var, function, etc), expression w/side effect,
#	inconsistent types, etc.
# Statement (??)
# Other unclassifiable: give evilness reason, or name the free var,
#	or do multiple of these.


# Categories

# These speak of the BODY; whether the macro takes args is a different matter.
# Right now I return "some constant" many places that I should really return "some value".
# Fix later.

my $catNOTYET = 0;		# shouldn't be used; should be undefined instead
my $catINPROCESS = 1;
my $catMULTIPLE = 2;
my $catNULLDEFINE = 3;
# Expressions
my $catEXP = 4;
my $catEXPASSIGN = 5;
my $catEXPFREE = 6;		# expression with free variables
my $catLITERAL = 7;		# also specify the literal value
my $catCONSTANT = 8;		# need to also specify the particular value, if possible
my $catSOMECONSTANT = 9;	# a constant, but not known which (e.g., multiple #defines)
# Non-expressions
my $catFAILURE = 10;		# shouldn't have just one, should have many
my $catHASTYPEARG = 11;		# macro argument has a type
# These shouldn't be failures
my $catMACROFUN = 12;
my $catMACROTYPE = 13;
my $catUSESTYPEARG = 14;

# New categories -- higher numbers take precedence over lower ones
# Be sure to keep in sync w/ strings of @categoryname
my $catASM = 15;
my $catSYNTAX = 16;		# this goes along with MISMATCH, sort of
my $catTYPE = 17;
my $catRESDWORD  = 18;
my $catSTATEMENT = 19;  # STATEMENT-s likely contain reserved words, but are more specific
my $catRECURSIVE = 20;
my $catMISMATCH  = 21;
my $catPASTING   = 22;
my $catSTRINGIZE = 23;


my @categoryname = (
		    'uncategorized', 'being_categorized',
		    'multiply_categorized', 'null_define',
		    'expression', 'expression_with_assignment',
		    'expression_with_free_variables',
		    'literal', 'constant', 'some_constant',
		    'failed_categorization', 'has_type_argument',
		    'macro_as_function', 'macro_as_type',
                    'uses_type_argument',
		    'assembly_code', 'syntax_tokens',
		    'expands_to_type', 'expands_to_reserved_word',
		    'statement',
                    'recursive',
		    'mismatched_entities',
		    'token_pasting',
		    'stringization',
		   );

# my %failed_categorization_type_count =
#   (
#    "unknown" => 0,
#    "close_but_no_open" => 0,
#    "mismatched_entities" => 0,
#    "empty_string" => 0,
#    "unterminated_string" => 0,
#    "bad_char_constant" => 0,
#    "unterminated_char_constant" => 0,
#    "token_pasting" => 0,
#    "preprocessor_directive" => 0,
#    "stringization" => 0,
#    "unterminated_comment" => 0,
#   );

## Needs to be fixed.
## Perhaps give actual constant, so it can be determined.
sub category_lub ($$)
{ my ($c1, $c2) = check_args(2, @_);
  return (($c1 == $c2) ? $c1 : $catMULTIPLE);
}


###########################################################################
### Regular expressions
###

# Use /o in matches for these, so interpolation/compilation occurs just once.
# Use single, not double, quotes so as not to lose the backslashes.
# But note that \\ and \' are interpolated in single-quoted strings.
# "\b" prevents two words from running up against one another.
# These regexps are intended not to include any leading or trailing space

### Reserved words

# can appear in a type
my $c_reserved_type_word_alternatives = 'char|const|double|enum|extern|float|int|long|register|short|signed|static|struct|union|unsigned|void|volatile';
# can't appear in a type
my $c_reserved_nontype_word_alternatives = 'asm|auto|break|case|continue|default|do|else|entry|for|fortran|goto|if|return|sizeof|switch|typedef|while';
my $c_plus_plus_reserved_type_word_alternatives = 'bool|class|friend|inline|private|protected|public|virtual';
my $c_plus_plus_reserved_nontype_word_alternatives = 'asm|catch|const_cast|delete|dynamic_cast|false|mutable|namespace|new|operator|reinterpret_cast|static_cast|template|this|throw|true|try|typeid|using';

my $reserved_type_word_re = '\b(' . $c_reserved_type_word_alternatives
  . '|' . $c_plus_plus_reserved_type_word_alternatives . ')\b';
my $reserved_nontype_word_re = '\b(' . $c_reserved_nontype_word_alternatives
  . '|' . $c_plus_plus_reserved_nontype_word_alternatives . ')\b';
my $reserved_word_re ='\b(' . $c_reserved_type_word_alternatives
  . '|' . $c_plus_plus_reserved_type_word_alternatives
  . '|' . $c_reserved_nontype_word_alternatives
  . '|' . $c_plus_plus_reserved_nontype_word_alternatives . ')\b';


### Literals

# FIX: this regexp is lame-- L,x,U needed for 0x80 << 1LU
# It also matches whitespace and (bad!) the variable x, etc.
my $constant_exp_re = '[-lLuUxX0-9() \t<>+=*|&%!]+';
# $like constant_exp_re, but supposed to match macro uses too.
my $constant_or_upcase_exp_re = '[-a-zA-Z_lLuUxX0-9() \t<>+=*|&%!]+';

# Numeric literals
# floating-point number (four variants): $1 = exponent, $2 = suffix (fFlL)
my $float_literal_whole_re = '[-+]?\d+\.\d*([eE][-+]?\d+)?([fFlL]?)'; # decimal 2.
my $float_literal_frac_re = '[-+]?\d*\.\d+([eE][-+]?\d+)?([fFlL]?)'; # fraction .2
my $float_literal_exp_re = '[-+]?\d+([eE][-+]?\d+)([fFlL]?)'; # exponent 1e37
my $float_literal_noexp_re = '[-+]?\d+()([fF])'; # no exponent 22f
# integer regexp: $1 = number, $2 = suffix (uUlL); permit two L's for GNU extension
my $hex_literal_re = '(0[xX][0-9a-fA-F]+)([uUlL]?[uUlL]?[uUlL]?)'; # regexp failed with \d for 0-9
my $dec_oct_literal_re = '(\d+)([uUlL]?[uUlL]?[uUlL]?)';
# Using this is probably ill-advised.
my $number_literal_re = '((' . join(')|(', $float_literal_whole_re, $float_literal_frac_re, $float_literal_exp_re, $float_literal_noexp_re, $hex_literal_re, $dec_oct_literal_re) . '))';

# Character and string literals
# NOTE: GJB changed the below to {1,3}, but ANSI requires exactly 3 --
# will just evilprint an error.  Changed back to 3
my $char_literal_contents_re = '(\\\\?.|\\\\[0-7]{3})';
my $char_literal_re = "L?'" . $char_literal_contents_re . "'";
my $non_escaped_double_quote_re = '(^|[^\\\\])(\\\\\\\\)*\"';
# non-greedy '.*?' because '.*' matches too much, skips over intervening quotes
my $string_literal_re = 'L?\"(|.*?[^\\\\])(\\\\\\\\)*\"'; # string literal

### Types

# Types and declarations/definitions.
# In general, use $identifier_re in preference to "\w+"
my $identifier_no_dollar_re = '\b[a-zA-Z_]\w*\b';	# 0 groups
# Fix: $ as first character doesn't work: the leading \b won't match.
my $identifier_re = '\b[a-zA-Z_\$][a-zA-Z0-9_\$]*\b';	# 0 groups
my $type_specifier_re = $identifier_re . '(?:\s+' . $identifier_re. ')*'; # 0 groups
# Gross special case.  I'm sorry.  [I think this isn't necessary any more.]
# Don't combine with type_re because that is sometimes combined with
# $type_declarator_re, which must match before $type_re but after this.
my $type_special = 'int (*)(dc_num, dc_num, int, dc_num *)';
# Can't get \Q, \E to work.
# my $type_re_special = '(?:\Q$type_special\E)';	# 0 groups
# my $type_re_special = "(?:\\Q$type_special\\E)";
my $type_re_special_1 = 'int \(\*\)\(dc_num, dc_num, int, dc_num \*\)';
my $type_re_special_2 = 'int \(\*\)\(void\)';
my $type_re_special = '(?:' . $type_re_special_1 . '|' . $type_re_special_2 . ')';
# contains leading whitespace; unconditional; 0 groups
my $type_suffix_re = '(?:\s*(?:\*|\[\s*\]))';
my $type_re = $type_specifier_re . $type_suffix_re . '*'; # 0 groups
# Use $type_declarator_re instead.
# $type_identifier_re = $type_re . '\s*' . $identifier_re;

# Declarators are actually rather more complicated than this:  see H&S p. 85.
# We can't really use a regexp to catch them all.  Just hope to catch most...
my $type_qualifier_re = '\b(?:const|volatile)\b'; # 0 groups
my $pointer_declarator_prefix_re = '\*(?:\s*' . $type_qualifier_re . ')*'; # 0 groups
my $pointer_declarator_prefixes_re = '(?:' . $pointer_declarator_prefix_re . '\s*)*'; # 0 groups
my $array_declarator_suffix_re = '\[(?:' . $constant_or_upcase_exp_re . ')?\]'; # 0 groups
my $array_declarator_suffixes_re = '(?:\s*' . $array_declarator_suffix_re . ')*'; # 0 groups
# Don't do this!  Just look for type_declarator followed by open paren.
# $function_declarator_suffix_re = ...;
# declaratorsuffix = $array_declarator_suffix_re plus $function_declarator_suffix_re
my $declarator_unparenthesized_re = $pointer_declarator_prefixes_re
  . $identifier_re . $array_declarator_suffixes_re; # 0 groups
my $declarator_parenthesized_re = $pointer_declarator_prefixes_re
  . '\(' . $declarator_unparenthesized_re . '\)' . $array_declarator_suffixes_re; # 0 groups
my $declarator_re = '(' . $declarator_parenthesized_re . '|'
  . $declarator_unparenthesized_re . ')'; # 1 group: the declarator
# Use this in preference to $type_identifier_re
# 2 groups: $1 = type specifier, $2 = declarator
# my $type_declarator_unparen_re = '(' . $type_specifier_re . ')\s*' . $declarator_re;
# For functions, does NOT include teh open paren or any argument info.
my $type_declarator_re = '(' . $type_specifier_re . ')\s*' . $declarator_re;
# Should probably use $type_declarator_re and $type_re
my $simple_arglist_re = '\(\s*(?:' . $identifier_re . '\s*\**\s*(?:,\s*' . $identifier_re . '\s*\**\s*)*)?\s*\)'; # 0 groups
# 3 groups: $1 = type specifier, $2 = declarator, $3 = arglist
my $type_declarator_arglist_re = $type_declarator_re . '\s*(' . $simple_arglist_re . ')';

# # This isn't going to work, because of looping.  Break the loop somehow.
# $simple_declarator_re = $identifier_re;
# $arraydeclarator = $directdeclarator . '\s*\[(' . $constant_exp_re . ')?\]';
# $direct_declarator_re = '(' . $arraydeclarator . '|' . $simple_declarator_re . ')';
# $pointer_declarator_re = '\*(\s*' . $type_qualifier_re . ')*\s*' . $direct_declarator_re;
# $declarator_re = '(' . $pointer_declarator_re . '|' . $direct_declarator_re . ')';
# type plus identifier:  $1 = type, $5 = identifier

# Does not handle function types
my $numeric_type_word_re = '\b(short|signed|unsigned|long|int|char|float|double)\b';
my $numeric_type_re = $numeric_type_word_re . '(\s+' . $numeric_type_word_re . ')*';
my $non_numeric_type_re = '\b(void)\b';
my $builtin_type_base_re = "($numeric_type_re|$non_numeric_type_re|" . '\b(struct|union|enum)\s+' . "$identifier_re)";
my $builtin_type_re = $builtin_type_base_re . $type_suffix_re . '*';

## Binary operators
# $numeric_binop_regexp should precede $bool_binop_regexp because of < and <<.
# $bool_binop_regexp should precede $numeric_binop_regexp because of | and ||.
# Better yet, get rid of this, go back to one regexp, and have a hashtable to
# give precedences, types, etc.
my $numeric_binop_regexp = '<<=?|>>=?|[-*\/%+&^\|]=?';
my $bool_binop_regexp = '[<=>!]=|&&|\|\||<|>';
# This might return a boolean, number, or something else.
my $arb_type_binop_regexp = '=';
my $binop_regexp = '<<=?|>>=?|&&|\|\||[<=>!]=|[-*\/%+&^\|]=?|[<=>]';


###########################################################################
### Types
###

# Perhaps reserve 0 for unrecognized (non-built-in) type.
# No, with new scheme it's important that it be 0
my $typeFAIL = 0;			# does not parse as a valid type
my $typeBOOL = 1;
my $typeCHAR = 2;			# ought to have typeWCHAR as well
my $typeUCHAR = 3;
my $typeSCHAR = 4;
my $typeSHORT = 5;
my $typeUSHORT = 6;
my $typeINT = 7;
my $typeUINT = 8;
my $typeLONG = 9;
my $typeULONG = 10;
my $typeFLOAT = 11;
my $typeDOUBLE = 12;
my $typeLDOUBLE = 13;
my $typeSTRING = 14;
my $typeNUMBER = 15;
my $typeUNKNOWN = 16;		# we know it's some type, but don't know which
my $typeUNSPECIFIED = 17;		# declared w/o a type (e.g., as function arg)

my %type_num = ('short' => $typeSHORT, 'short int' => $typeSHORT,
		'signed short' => $typeSHORT, 'signed short int' => $typeSHORT,
		'unsigned short' => $typeUSHORT, 'unsigned short int' => $typeUSHORT,
		'int' => $typeINT, 'signed int' => $typeINT, 'signed' => $typeINT,
		'unsigned int' => $typeUINT, 'unsigned' => $typeUINT,
		'long' => $typeLONG, 'long int' => $typeLONG,
		'signed long' => $typeLONG, 'signed long int' => $typeLONG,
		'unsigned long' => $typeULONG, 'unsigned long int' => $typeULONG,
		'char' => $typeCHAR,
		'unsigned char' => $typeUCHAR,
		'signed char' => $typeSCHAR,
		'float' => $typeFLOAT,
		'double' => $typeDOUBLE,
		'long double' => $typeLDOUBLE,
		'char *' => $typeSTRING, 'char*' => $typeSTRING);

my @type_name_array = ('typeFAIL', 'bool',
		       'char', 'unsigned char', 'signed char',
		       'short', 'unsigned short',
		       'int', 'unsigned int',
		       'long', 'unsigned long',
		       'float', 'double', 'long double',
		       'char *',
		       'typeNUMBER',
		       'typeUNKNOWN',
		       'typeUNSPECIFIED');

# For determining whether a Perl variable has numeric type.
# This is incredibly disgusting; do something about it.
sub is_number ($)
{
  my ($arg) = check_args(1, @_);
  return ($arg =~ /^\d+$/);
}

sub type_name ($)
{
  my ($type) = check_args(1, @_);
  if (is_number($type))
    { return $type_name_array[$type]; }
  else
    { return $type; }
}

sub type_to_num ($)
{
  my ($type) = check_args(1, @_);
  # print "type = $type; type_num{type} = $type_num{$type} \n";
  # Compress multiple spaces to just one, but don't remove all space!
  $type =~ s/\s+/ /og;
  if (defined($type_num{$type}))
    { return $type_num{$type}; }
  else
    { return $type; }
}


### Numeric types

# This doesn't yet do the right thing.
sub infer_int_type ($)
{
  my ($int) = check_args(1, @_);
  if ($int =~ /^0[xX]/)
    # Hex
    { # return first of ($typeUINT $typeLONG $typeULONG) in which the number fits
      return $typeUINT; }
  elsif ($int =~ /^0/)
    { return $typeINT; }	# was unsigned int in non-ANSI C.
  else
    { # return first of ($typeINT $typeLONG $typeULONG) in which the number fits
      return $typeINT; }
}

sub type_integral_p ($)
{ my ($type) = check_args(1, @_);
  return (($type eq $typeBOOL)
	  || ($type eq $typeCHAR) || ($type eq $typeUCHAR) || ($type eq $typeSCHAR)
	  || ($type eq $typeSHORT) || ($type eq $typeUSHORT)
	  || ($type eq $typeINT) || ($type eq $typeUINT)
	  || ($type eq $typeLONG) || ($type eq $typeULONG));
}

### Type manipulation: arrays, pointers, functions

sub type_dereference ($)
{ my ($type) = check_args(1, @_);
  if ($type eq $typeSTRING)
    { return $typeCHAR; }
  if ($type =~ /(\*|\[\])\s*$/)
    { return $PREMATCH; }
  return $typeUNKNOWN;
}

# A function type looks like ( ),( ),( )->( )
# The full parentheses are necessary (but I don't think they are sufficient)
# to avoid misparsing nested function types.  Maybe that doesn't happen...

# sub type_apply ...

# FIX: this is completely wrong.
sub construct_function_type($@)
{ my ($return_type, @arg_types) = check_args_at_least(1, @_);
  return $return_type;
}

# FIX: this is completely wrong.
sub construct_array_type($;$)
{ my ($elt_type, $size) = check_args_range(1, 2, @_);
  return $elt_type;
}


### Type conversions

# Perhaps these should be arrays instead.

sub type_unsignify ($)
{
  my ($type) = check_args(1, @_);
  if (($type eq $typeCHAR) || ($type eq $typeSCHAR))
    { return $typeUCHAR; }
  elsif ($type eq $typeSHORT)
    { return $typeUSHORT; }
  elsif ($type eq $typeINT)
    { return $typeUINT; }
  elsif ($type eq $typeLONG)
    { return $typeULONG; }
  else
    { return $type; }
}

sub type_signed ($)
{
  my ($type) = check_args(1, @_);
  if (($type eq $typeCHAR) || ($type eq $typeUCHAR))
    { return $typeSCHAR; }
  elsif ($type eq $typeUSHORT)
    { return $typeSHORT; }
  elsif ($type eq $typeUINT)
    { return $typeINT; }
  elsif ($type eq $typeULONG)
    { return $typeLONG; }
  else
    { return $type; }
}

sub type_longify ($)
{
  my ($type) = check_args(1, @_);
  # print "type_longify $type (", type_name($type), ")\n";
  if ($type eq $typeCHAR)
    { return $typeLONG; }
  elsif ($type eq $typeUCHAR)
    { return $typeULONG; }
  elsif ($type eq $typeSCHAR)
    { return $typeLONG; }
  elsif ($type eq $typeSHORT)
    { return $typeLONG; }
  elsif ($type eq $typeUSHORT)
    { return $typeULONG; }
  elsif ($type eq $typeINT)
    { return $typeLONG; }
  elsif ($type eq $typeUINT)
    { return $typeULONG; }
  elsif ($type eq $typeLONG)
    { return $typeLONG; }
  elsif ($type eq $typeULONG)
    { return $typeULONG; }
  else
    { return $type; }
}

# The "usual binary conversions"; H&S p. 176
# except that if types are identical, it returns them.
# Can also return short, ushort.
sub type_lub ($$)
{ my ($t1, $t2) = check_args(2, @_);
  # This test works whether $t1, $t2 are numbers or strings
  if ($t1 eq $t2)
    { return $t1; }
  if (!is_number($t1))
    { $t1 = $typeUNKNOWN; }
  if (!is_number($t2))
    { $t2 = $typeUNKNOWN; }
  if ($t1 > $t2)
    { ($t1, $t2) = ($t2, $t1); }
  # If either $t1 or $t2 is a string, its numeric equivalent is zero
  if ($t1 == 0)			# 0 == $typeFAIL
    { return $typeFAIL; }
  if ($t2 == $typeUNKNOWN)
    { return $typeUNKNOWN; }
  if (($t2 == $typeLDOUBLE) || ($t2 == $typeDOUBLE) || ($t2 == $typeFLOAT)
      || ($t2 = $typeULONG) || ($t2 = $typeLONG)
      || ($t2 == $typeUINT) || ($t2 == $typeINT)
      || ($t2 == $typeUSHORT)  || ($t2 == $typeSHORT))
    { return $t2; }
  # Otherwise, differing char types.
  return $typeSHORT;
}

### Parsing types

# FIX: GJB
# Given a basetype and declarator string, return a type and an identifier.
sub parse_declarator ($$)
{ my ($basetype, $declarator) = check_args(2, @_);
  if ($declarator !~ /$identifier_re/o)
    { parse_error("parse_declarator($basetype, $declarator): no word in declarator");
      return ("$basetype $declarator", "no identifier"); }
  my $id = $MATCH;
  my $prefix = $PREMATCH;
  my $suffix = $POSTMATCH;
  while ($id =~ /^$type_qualifier_re$/o)
    { if ($suffix !~ /$identifier_re/o)
	{ parse_error("parse_declarator($basetype, $declarator): no non-type-qualifier word in declarator");
	  return ("$basetype $declarator", "no identifier"); }
      $id = $MATCH;
      $prefix .= $PREMATCH;
      $suffix = $POSTMATCH; }
  if (($suffix =~ /$identifier_re/o) && ($PREMATCH !~ /\[/))
    { parse_error("multiple words in declarator $declarator");
      # Fix: Don't know how to deal with this yet.
      mdie("multiple words in declarator $declarator"); }
  return ("$prefix($basetype)$suffix", $id);
}

# FIX: GJB
# Given a type string, return a type
sub parse_type ($)
{ my ($type) = check_args(1, @_);
  return $type;
}


###########################################################################
### Variables
###

## Integers:

## Five different kinds of line counts that we care about are:
# (physical,ncnb_phys,cpp_phys,cpp_phys_ncnb)
# We care about these five line counts, %cppcmdcount, $cpp_cmds
# in each of the 8 possible kinds of file-types
# Dimension 1: header file vs code file (use regexp-s)
# Dimension 2: method of inclusion: (input,arg,#include<>,#include"")
#              Maybe only care about first 2 kinds vs. last 2 kinds.
#	       Currently the former are distinguished because we can do
#              so easily, and it might come in handy some day, to generate
#              separate statistics for arbitrary subset of files.
# Note: #include"" or <> is only our filetype if the file was included
# from another file we parsed and it was not given as an input/arg file.
# Generalize the variables for each of these to be lists of eight values.

# This enumeration gives indices into the lists

# 2 (1st dim) times 4 (2nd dim) file types
my $c_ftype = 2 * 4;

my @ftype_ALL = (0..$c_ftype-1);

my ($ftype_HEADER_INPUT, $ftype_HEADER_ARG, $ftype_HEADER_INCB, $ftype_HEADER_INCQ,
    $ftype_NONHEADER_INPUT, $ftype_NONHEADER_ARG, $ftype_NONHEADER_INCB, $ftype_NONHEADER_INCQ) = @ftype_ALL;

my %InclusionMethod_to_Index =
  ("FromCmdLine" => $ftype_HEADER_ARG,
   "FromStdin" => $ftype_HEADER_INPUT,
   "FromInclude<>" => $ftype_HEADER_INCB,
   "FromInclude\"\"" => $ftype_HEADER_INCQ);

my $ftype_HEADER_Start = $ftype_HEADER_INPUT;
my $ftype_NONHEADER_Start = $ftype_NONHEADER_INPUT;

# make slices for common uses
my @ftype_CODE = ($ftype_HEADER_INPUT..$ftype_HEADER_INCQ);
my @ftype_HEAD = ($ftype_NONHEADER_INPUT..$ftype_NONHEADER_INCQ);
my @ftype_NOT_INCLUDED = ($ftype_HEADER_INPUT,$ftype_HEADER_ARG,$ftype_NONHEADER_INPUT,$ftype_NONHEADER_ARG);
my @ftype_INCLUDED = ($ftype_HEADER_INCB,$ftype_HEADER_INCQ,$ftype_NONHEADER_INCB,$ftype_NONHEADER_INCQ);
my @ftype_NONHEADER_NOT_INCLUDED = ($ftype_NONHEADER_INPUT,$ftype_NONHEADER_ARG);
my @ftype_NONHEADER_INCLUDED = ($ftype_NONHEADER_INCB,$ftype_NONHEADER_INCQ);
my @ftype_HEADER_NOT_INCLUDED = ($ftype_HEADER_INPUT,$ftype_HEADER_ARG);
my @ftype_HEADER_INCLUDED = ($ftype_HEADER_INCB,$ftype_HEADER_INCQ);

my @rg_physical_lines = (0) x $c_ftype;
my @rg_ncnb_lines = (0) x $c_ftype;
my @rg_cpp_phys_lines = (0) x $c_ftype;
my @rg_cpp_phys_ncnb_lines = (0) x $c_ftype;

my @rg_cpp_cmds = (0) x $c_ftype;

# ${$rg_category_counts[$ft_index]}{"uncategorized"} ==
# the number of times a macro definition was categorized as uncategorized
# for files of type $ft_index
# (much like @rg_cpp_cmds list of hashes)
my @rg_category_counts;

# These get computed using ft_ slices
my %category_counts_ni = ();
my %category_counts_c_ni = ();
my %category_counts_hdr_ni = ();

my @rg_cppcmdcounts;

#my $physical_lines = 0;		# as they appear to tools
#my $ncnb_physical_lines = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines = 0;	# cpp physical lines
#my $cpp_physical_ncnb_lines = 0; # cpp physical lines
#
## Not-include file version of the above
#my $physical_lines_ni = 0;	# as they appear to tools
#my $ncnb_physical_lines_ni = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines_ni = 0;	# cpp physical lines
#my $cpp_physical_ncnb_lines_ni = 0; # cpp physical lines


### These variables (cppBLAH) now get summed
# from the rg_XXX variables, above.
# See compute_global_cpp_sums

my $cpp_cmds;			# total preprocessor commands
my $cpp_cmds_ni;		# total preprocessor commands
my $cpp_cmds_hdr;
my $cpp_cmds_hdr_ni;
my $cpp_cmds_c;
my $cpp_cmds_c_ni;

# Initialize cppcmdcount{"define"} to avoid uninitialized values
# when processing the macros (in case there were no macros).
my %cppcmdcount = (
   "define" => 0,
   "elif" => 0,
   "else" => 0,
   "endif" => 0,
   "error" => 0,
   "ident" => 0,
   "if" => 0,
   "ifdef" => 0,
   "ifndef" => 0,
   "import" => 0,
   "include" => 0,
   "include_next" => 0,
   "line" => 0,
   "pragma" => 0,
   "undef" => 0,
   "%OTHER%" => 0,
); # number of uses of each cpp command
# cppcmdcount_ni is like cppcmdcount, but only for files listed on cmd line
# ni == "not includes"
my %cppcmdcount_ni = (); # number of uses of each cpp command, NI
my %cppcmdcount_hdr_ni = (); # number of uses of each cpp command, header NI
my %cppcmdcount_c_ni = (); # number of uses of each cpp command, code NI


my $symtab_scopes = 0;	# the number of enclosing scopes, less the global scope
## Strings:
my $line = "";			# current line

# Number of macros defined before parsing -- don't reuse the first
# $cBuiltinMacros elements of @mdef_XXXXX arrays
my $cBuiltinMacros = 0;
# Total number of entries in @mdef_XXXX arrays; rename $c_mdef?
my $cMacrosInTables = 0;
# Highly unlikely filename, used for $mdef_file[$i] for builtin macros
my $built_in_fake_file = "%Built In%";

# %files_lines is a hash from filename to an in-order list of elements like:
# (start_line, function_name, end_line)
my %files_lines;

# %function_to_locs is a hash from function name to a list of lists of
#   (file,start,end), one per definition of that function.
my %function_to_locs;

# hashes "file:function name" to a list of macro names that it uses
my %function_name_to_macros_it_uses = ();

# If remove "current" from these names, look for other vars of those names.
my $current_file;		# the current file name
my $current_ftype_index;		# the index of the @ftype_'s for the current file

# current_line_no is now a function
#my $current_line_no;		# the current line number
my $current_function;		# the current function
my $current_function_start_line; # the first line of the current function
				# (sometimes function headers span lines)

my $current_macro_line_number;	# Used by current_line_no when categorizing macros

# @files contains the list of files we want to process
# %file_inclusion_method, a string like "#include<>", tells where file got added
my @files;
my %file_inclusion_method = ("%Built In%" => "BuiltIn");

# files that are included should be pushed onto both @files and
# @files_included -- the latter is used only to prevent multiple inclusion
my @files_included;

# Output field separator
my $outOFS;

# @include_path is a list of places to look for included files
use vars '@include_path';


## Note that the %macrosXXX are annotations per macro,
## whereas @mdef_XXXX arrays are annotations per macro *definition*.

# perhaps make %macros proper just index into other arrays.

# FIX: this data structure is especially HACKY.  Fix after paper deadline...
my %macros = ();	  # for each macro, list of indexes for info about it
			  # (first list element is number of following elements)

my %macros_c_undefs = ();	# hashes macro names to the number of times they
				# are #undef-d

# enumeration for the macros_uses indices
my ($i_usage_code, $i_usage_macro, $i_usage_cond) = (0..2);

my %macros_uses = ();		# hashes macro names to an array
                                # listing the number of times they are
                                # used in (code,cpp_directives)

# count of uses is half the number of keys in %macros_file_line_uses
my %macros_file_line_uses = ();	# hashes macro names to an array
				# where consecutive elements
                                # list the filename and physical line
				# on which it appears

# can compute the number of uses at global scope with macros_uses and
# the length of the list in macros_used_in_functions
my %macros_used_in_functions = (); # hashes macro names to list of
				# file/functions that use it.  Will
				# contain same function name
				# repeatedly if the macro is used more
				# than once in that function.

# Also want to have summary info true about all definitions...
# FIX: This data structure of parallel arrays needs to be improved
my @mdef_name;
my @mdef_args;
my @mdef_body;			# with comments; for user output
my @mdef_body_noc;		# no comments; for processing
my @mdef_file;
my @mdef_line;
my @mdef_physical_lines;
my @mdef_physical_ncnb_lines;
my %mdef_freevars;
my @mdef_freefuns;
my @mdef_dependenton;
my @mdef_expansion_uses;
my @mdef_type;
my @mdef_category;
my @mdef_evilness;

# These are for aggregate information -- that is, information about a macro
# gleaned by combining information about all its definitions.
# fix: "mn" stands for "macro name".
my %mntype;
my %mncategory;

# This is a hack.
# Macros which expand to their argument or the empty list, for function arg decls.
my %fun_decl_arg_macros;
my %semi_fun_decl_arg_macros;
my %void_macros;

## Debugging; should add more
my $fDebugCmdProcessing = $false;
my $fDebugCommentRemoval = $false;
my $debug_scopes = $false;
my $debug_type_match = $false;
my $debug_parse_function = $false;
my $debug_parse_expression = $false;
my $debug_merge_branches = $false;
my $debug_parse_array_init = $false;
my $debug_peek = $false;
my $debug_getline = $false;	# a LOT of output; use only on small inputs
my $debug_categorize_macro = $false;
my $debug_cpp_if_comments = $false;

## Command-line processing
# Are these in any order?
use vars qw($opt_i $opt_I $opt_h $opt_v $opt_t $opt_d $opt_l
	    $opt_D $opt_M $opt_S $opt_F $opt_L $opt_C $opt_E $opt_P $opt_p
	    $opt_u $opt_1 $opt_A $opt_a $opt_g $opt_T);
my $fIgnoreIncludes = $false;


###########################################################################
### Pass 1: collect information about preprocessor use
###

# These indicate the pass, for getline_handle_preprocessor_command.
# Since they're dynamically bound with "local", can't declare them with "my".
use vars qw($finding_macro_defs $finding_macro_uses $categorizing_macros $merge_cpp_if_branches);
$finding_macro_defs = $false;
$finding_macro_uses = $false;
$categorizing_macros = $false;
$merge_cpp_if_branches = $false;

# For get_fulltoken_line():
# These can't be declared with "my" because they're dynamically bound
use vars qw($getline_simplify $getline_nocpp $getline_peeking
	    $getline_physical_lines $getline_physical_ncnb_lines);
$getline_simplify = $false;
$getline_nocpp = $false;
$getline_peeking = $false;
my @getline_ungot_raw_lines = ();
my @getline_ungot_simple_lines = ();

# List of #if conditions for the current line.
my @dependenton = ();


### Read files, save info about macros
sub find_macro_definitions ()
{
  check_args(0, @_);
  if ($finding_macro_defs)
    { mdie("Called find_macro_definitions, but already finding macrodefs"); }
  local $finding_macro_defs = $true;
# Do not use a foreach, since we're pushing on to the end of @files,
#   and the list foreach uses does not get updated
#  foreach $this_file (@files)
  my $ifiles;
  for ($ifiles = 0; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      $current_ftype_index = compute_ftype_index($current_file);

      print STDERR "file: \"$current_file\"" if $opt_v;
      if (!open(INPUT,$current_file)) {
	# fix: Add quiet option; then this will occur unless that is set.
	print STDERR " -- failed open\n" if $opt_v;
	next; # skip to next file if open fails
      } else {
	print STDERR "\n" if $opt_v;
      }

      check_file_boundary();
      while ($line = get_fulltoken_line())
	{
	  # Amazingly enough, all the work is done by get_fulltoken_line, which
	  # calls process_macro_definition.
	}
      check_file_boundary();
      close(INPUT);
    }
}

# Given a macro definition (everything after "#define", with no leading or
# trailing space), enter it into the appropriate global arrays.
sub process_macro_definition ($$$$)
{
  my ($def,$def_noc,$macro_physical_lines,$macro_physical_ncnb_lines)
    = check_args(4, @_);
  # print "process_macro_definition <<$def>>\n";
  my ($name_ignore, $args_ignore, $body) = macrosplit($def);
  my ($name, $args, $body_noc) = macrosplit($def_noc);
  # print "process_macro_definition $name $macro_physical_lines $macro_physical_ncnb_lines\n";
  # print STDERR "PARSED: $name\n";
  if (!defined($args)) { $args = ""; }
  # print "parsed: |$name|$args|$body|\n";
  # Do not just use $cppcmdcount{"define"}, since our builtins require
  # some space in the @mdef_XXXXX arrays
  my $this_macro_index = $cMacrosInTables;
  $cMacrosInTables++;

  # initialize all the parallel arrays here,
  # so that we don't have to check the defined-ness later
  if (!defined($macros{$name}[0])) {
    $macros{$name}[0] = 0;
    $macros_uses{$name} = [0,0,0];
    $macros_c_undefs{$name} = 0;
    $macros_used_in_functions{$name} = [];
    $macros_file_line_uses{$name} = [];
  }


  $macros{$name}[0] += 1;
  $macros{$name}[$macros{$name}[0]] = $this_macro_index;
  # print "def number $macros{$name}[0]:";
  # for ($i = 1; $i <= $macros{$name}[0]; $i++)
  #   { print " $macros{$name}[$i]"; }
  # print "\n";
  $mdef_name[$this_macro_index] = $name;
  $mdef_args[$this_macro_index] = $args;
  $mdef_body[$this_macro_index] = $body;
  $mdef_body_noc[$this_macro_index] = $body_noc;

  # We track both the physical lines in a macro definition
  # (mdef_physical_lines) which is the extent of the macro (where it appears
  # in the file) and the physical code lines (mdef_physical_ncnb_lines)
  # which does not count comment only lines in a macro definition
  # eg.
  # --begin, non-inclusive--
  # #define BOOL int /* we do not
  #                     have a built
  #                     in type so we
  #                     use bool */
  # --end, non-inclusive--
  # would count as 4 physical lines, 1 ncnb (non-comment,non-blank)
  # line, 1 cpp_physical_code_line, and 4 cpp_physical_lines

  $mdef_physical_lines[$this_macro_index] = $macro_physical_lines;
  $mdef_physical_ncnb_lines[$this_macro_index] = $macro_physical_ncnb_lines;
  @{$mdef_dependenton[$this_macro_index]} = @dependenton;
  # Old way to copy array, replaced by teh above
  #   # @mdef_dependenton[$this_macro_index] = @dependenton;
  #   { my $i;
  #     $mdef_dependenton[$this_macro_index][0] = @dependenton;
  #     for $i (0..$#dependenton)
  #       { $mdef_dependenton[$this_macro_index][$i] = $dependenton[$i]; } }
  if (!defined($current_file))
    { mdie("undefined current_file while processing $name"); }
  $mdef_file[$this_macro_index] = $current_file;
  $mdef_line[$this_macro_index] = current_line_no();
  # PERLNOTE: be careful not to do
  # $mdef_expansion_uses[$this_macro_index] = ();  ##WRONG
  # you'll get a wierd error message at the point of use
  @{$mdef_expansion_uses[$this_macro_index]} = ();
}


# process_macro_undefinition handles #undef-s
sub process_macro_undefinition ($$) {
  my ($cpp_cmd_arg, $cpp_cmd_arg_noc) = check_args(2, @_);

  # Pull out first word
  if ($cpp_cmd_arg_noc !~ /^$identifier_re/o)
    { mdie("No macro name follows #undef: $cpp_cmd_arg"); }
  my $macro_name  = $MATCH;

  $macros_c_undefs{$macro_name}++;
}


###########################################################################
### Dependenton processing
###

# Given a macro name, try to merge the dependentons for all its definitions,
# and return a single dependenton or $false.
# Hack: optionally takes an additional @dependenton to merge with the macros.
sub macro_dependenton ($@)
{
  my ($macro_name, @dependenton) = check_args_at_least(1, @_);
  # FIX: This seems wrong, but other retlated uses fail if it
  # is changed to @{$macros{$macro_name}}, like it probably should be
  my @indices = @macros{$macro_name};
  shift(@indices);		# eliminate the count of size
  my @result = ($false);
  # scratch indices, since I must pass in at least one index.
  # (I don't yet know how to pass two arrays.)
  # ***** problem: this increments the global count.  Probably get rid of
  # this function and just use that global variable.
  my $extraindexmin = $cMacrosInTables + 10;
  my $extraindexmax = $extraindexmin-1;
  if (@dependenton > 0)
    { $extraindexmax++;
      @{$mdef_dependenton[$extraindexmax]} = @dependenton;
      # Old way to copy array, replaced by the above
      # # @mdef_dependenton[$extraindexmax] = @dependenton;
      # { my $i;
      #   $mdef_dependenton[$extraindexmax][0] = @dependenton;
      #   for $i (0..$#dependenton)
      #    { $mdef_dependenton[$extraindexmax][$i] = $dependenton[$i]; } }
      push(@indices, $extraindexmax); }
  # Perhaps use a named loop instead of the gotos.
MDLOOP:
  if (@indices == 1)
    { @result = @mdef_dependenton[$indices[0]]; # protect from undef below
      goto MDDONE; }
  ## ***** This can't work at all!
  ## If failure, should try next pair, not fail completely.  Test this!
  # Try to find two definitions that can be merged.
  my $index1;
  for $index1 (0..$#indices-1)
    { my $index2;
      for $index2 ($index1+1..$#indices)
	{ my @merged = merge_dependenton($index1, $index2);
	  if ((@merged == 1) && !$merged[0])
	    { goto MDDONE; }
	  else
	    { $extraindexmax++;
	      @{$mdef_dependenton[$extraindexmax]} = @merged;
	      # Old way to copy array, replaced by the above
	      # # @mdef_dependenton[$extraindexmax] = @merged;
	      # { my $i;
	      #   $mdef_dependenton[$extraindexmax][0] = @merged;
	      #     for $i (0..$#dependenton)
	      #     { $mdef_dependenton[$extraindexmax][$i] = $merged[$i]; } }
	      goto MDLOOP; } } }

MDDONE:
 { my $i;
   for $i ($extraindexmin..$extraindexmax)
     { undef $mdef_dependenton[$i][0];
       # Is the above necessary, given this?
       undef $mdef_dependenton[$i]; } }

  # This does not work, because I sometimes call this in scalar context to
  # determine compatibility, not what the dependenton would be.
  # # If failure, the result is a list of $false.
  # return @result;

  # In list context, there's no point to this.  In scalar context, these
  # results really are different.
  if ((@result == 1) && !$result[0])
    { return $false; }
  else
    { return @result; }
}


# Takes an index and a dependenton array.
# If the dependentons are the same for all but the last element, return all
# but that last element.  Otherwise return $false.
sub merge_dependenton ($@)
{ my ($index, @do2) = check_args_at_least(1, @_);
  if (!dependenton_single_difference($index, @do2))
    { return $false; }
  return @{$mdef_dependenton[$index]};
  #   # Return @do1.
  #   my @do1;
  #   @do1 = @{$mdef_dependenton[$index]};
  #   # Old way to copy array, replaced by the above
  #   # # @do1 = @mdef_dependenton[$index];
  #   # { my $i;
  #   #   for $i (0..$mdef_dependenton[$index][0])
  #   #     { $do1[$i] = $mdef_dependenton[$index][$i]; } }
  #   pop(@do1);
  #   return @do1;
}


sub dependenton_single_difference ($@)
{ my($index, @do2) = check_args_at_least(1, @_);
  my @do1;
  @do1 = @{$mdef_dependenton[$index]};
  # Old way to copy array, replaced by the above
  #   # @do1 = @mdef_dependenton[$index];
  #   { my $i;
  #     for $i (0..$mdef_dependenton[$index][0])
  #       { $do1[$i] = $mdef_dependenton[$index][$i]; } }
  if ((@do2 == 1) && is_num($do2[0]))
    { @do2 = @mdef_dependenton[$do2[0]]; }

  if ($#do1 != $#do2)
    { return $false; }
  { my $i;
    for $i (0..$#do1-1)
      { if ($do1[$i] ne $do2[$i])
	  { return $false; } } }
  if ($do1[$index] ne negate_cpp_if_condition($do2[$index]))
    { return $false; }
  return $true;
}


# These dependenton functions take a macro name and a dependenton array and
# compare the macro's dependenton to the one passed in.  Perhaps also permit
# the passed in array to instead itself be a macro name.

## This isn't really enough; we need to canonicalize macro dependence
## information, perhaps even make it order-independent.
sub dependenton_identical ($@)
{
  my ($macro_name, @depend) = check_args_at_least(1, @_);
  my @macro_depend = macro_dependenton($macro_name);
  if ($#depend != $#macro_depend)
    { return $false; }
  { my $i;
    for $i (0..$#depend)
      { if ($depend[$i] ne $macro_depend[$i])
	  { return $false; } } }
  return $true;
}




# potential problem:  if arg == "!(!(...))", then  (nif(nif($arg)) ne $arg)
sub negate_cpp_if_condition ($)
{
  my ($cond) = check_args(1, @_);
  if ($cond =~ /^!\((.*)\)$/)
    # Problem: what if those parens weren't balanced??  Need to check here.
    { return $MATCH; }
  else
    { return "!($cond)"; }
}


sub cpp_trivially_false_condition ($)
{ my ($cond) = check_args(1, @_);
  if ($cond =~ /^(0|\(\s*0\s*\))$/)
    { return $true; }
  elsif ($cond =~ /^(!1|!\s*\(\s*1\s*\)|!\s*\(\s*\(\s*1\s*\)\s*\))$/)
    { return $true; }
  else
    { return $false; }
}


# Just like the above, with 0 and 1 reversed
sub cpp_trivially_true_condition ($)
{ my ($cond) = check_args(1, @_);
  if ($cond =~ /^(1|\(\s*1\s*\))$/)
    { return $true; }
  elsif ($cond =~ /^(!0|!\s*\(\s*0\s*\)|!\s*\(\s*\(\s*0\s*\)\s*\))$/)
    { return $true; }
  else
    { return $false; }
}


###########################################################################
### Print output statistics
###

# FIX: these sub-parts might better be broken up into functions
# FIX: use "select" instead of print FILEHANDLE repeatedly
sub output_stats ()
{
  check_args(0, @_);

  local $OFS = (defined($outOFS) ? $outOFS : " ");
  #   if (defined($outOFS)) {
  #     $OFS = $outOFS;
  #   } else {
  #     $OFS = " ";
  #   }
  # Use ".", not ",", here, because $OFS has been set!
  # print "OFS: " . (defined($OFS) ? "'$OFS'" : "undef") . ", outOFS: " . (defined($outOFS) ? "'$outOFS'" : "undef") . "\n";

  my $physical_lines = sum_array(@rg_physical_lines);
  my $ncnb_physical_lines = sum_array(@rg_ncnb_lines);
  my $cpp_physical_lines = sum_array(@rg_cpp_phys_lines);
  my $cpp_physical_ncnb_lines = sum_array(@rg_cpp_phys_ncnb_lines);

  my $physical_lines_ni =
    sum_array(@rg_physical_lines[@ftype_NOT_INCLUDED]);
  my $ncnb_physical_lines_ni =
    sum_array(@rg_ncnb_lines[@ftype_NOT_INCLUDED]);
  my $cpp_physical_lines_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_NOT_INCLUDED]);

  my $physical_lines_hdr_ni =
    sum_array(@rg_physical_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $ncnb_physical_lines_hdr_ni =
    sum_array(@rg_ncnb_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $cpp_physical_lines_hdr_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_hdr_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_HEADER_NOT_INCLUDED]);

  my $physical_lines_c_ni =
    sum_array(@rg_physical_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $ncnb_physical_lines_c_ni =
    sum_array(@rg_ncnb_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $cpp_physical_lines_c_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_c_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_NONHEADER_NOT_INCLUDED]);

  if ($physical_lines == 0) {
    print STDERR "No lines read! Perhaps you meant to use the -i option?\n";
    return;
  }

  if ($opt_S) {
    my ($h, $v);
    # Dump statistics on frequencies of directives
    select STATS;

    print "#LINES#: physical ncnb_phys cpp_phys cpp_phys_ncnb\n";
    print "$physical_lines $ncnb_physical_lines $cpp_physical_lines $cpp_physical_ncnb_lines\n";
    print "#LINESNI#: physical ncnb_phys cpp_phys cpp_phys_ncnb\n";
    print "$physical_lines_ni $ncnb_physical_lines_ni $cpp_physical_lines_ni $cpp_physical_ncnb_lines_ni\n";

    print "\n";

    OutputHistogram("DIRECTIVES_ALL",\%cppcmdcount,1,$true);

    OutputHistogram("DIRECTIVES_NI",\%cppcmdcount_ni,1);
    OutputHistogram("DIRECTIVES_NI%NCNB",\%cppcmdcount_ni,$ncnb_physical_lines_ni);
    OutputHistogram("DIRECTIVES_NI%PHYS",\%cppcmdcount_ni,$physical_lines_ni);

    OutputHistogram("DIRECTIVES_HNI",\%cppcmdcount_hdr_ni,1);
    OutputHistogram("DIRECTIVES_HNI%NCNB",\%cppcmdcount_hdr_ni,$ncnb_physical_lines_hdr_ni);
    OutputHistogram("DIRECTIVES_HNI%PHYS",\%cppcmdcount_hdr_ni,$physical_lines_hdr_ni);

    OutputHistogram("DIRECTIVES_CNI",\%cppcmdcount_c_ni,1);
    OutputHistogram("DIRECTIVES_CNI%NCNB",\%cppcmdcount_c_ni,$ncnb_physical_lines_c_ni);
    OutputHistogram("DIRECTIVES_CNI%PHYS",\%cppcmdcount_c_ni,$physical_lines_c_ni);

    print "\n";


    OutputHistogram("CATEGORIES_NI",\%category_counts_ni,1,$true);
    OutputHistogram("CATEGORIES_HNI",\%category_counts_hdr_ni,1);
    OutputHistogram("CATEGORIES_CNI",\%category_counts_c_ni,1);

    print "\n";

#    OutputHistogram("FAILED_CATEG",\%failed_categorization_type_count,1,$true);
#    print "\n";
  }

  # -M = dump the macro stats
  if ($opt_M) {
    my $name;
    select MACROS;
    # FIX: compute a category for all definitions of the macro, if possible
    # or give list of categories
    print "#MACROS#: name cDefs cUndefs cCodeUses cMacroUses cCondUses cTotalUses HowUsed Categories InclusionMethods (%functionsThatUseIt)\n";
    foreach $name (sort keys %macros) {
      #print STDERR "MNAME=$name, @{$macros{$name}}\n";
      my $i = $macros{$name}[1];
      die "i not defined for $name" if (!defined($i));

      #next if ($mdef_file[$i] eq $built_in_fake_file);

      die if (!defined($macros_uses{$name}));
      die if (!defined($macros_c_undefs{$name}));
      die if (!defined($macros_used_in_functions{$name}));

      # FIXPERL: cperl mode doesn't count , as a statement continuer
      # in a print

      my $cCodeUses = $macros_uses{$name}[$i_usage_code];
      my $cMacroUses = $macros_uses{$name}[$i_usage_macro];
      my $cCondUses = $macros_uses{$name}[$i_usage_cond];
      my $cTotalUses = $cCodeUses + $cMacroUses + $cCondUses;

      print "$name", $macros{$name}[0], $macros_c_undefs{$name},
      $cCodeUses, $cMacroUses, $cCondUses, $cTotalUses,
      how_used_from_code_cpp_uses($cCodeUses, $cMacroUses, $cCondUses),
      join(",",CategoriesForMacroName($name)),
      join(",",InclusionMethodsForMacroName($name)),
      "\n%" . join("\n%",@{$macros_used_in_functions{$name}}),
      "\n";
    }
  }

  if ($opt_D) {
    select DEFINES;
    my $name;
# don't want extra lines-- harder for postprocessing tools
#    print  "\n";
    print "#DEFINITIONS#: name iDef inclusion_method filename line args plines p_ncnb_lines categorization (%macrosUsedInExpansion)\n";
    foreach $name (sort keys %macros) {
      # Could also print number of times it's defined.
      my $iDef;
      for ( $iDef = 1; $iDef <= $macros{$name}[0]; $iDef++ ) {
	my $i = $macros{$name}[$iDef];
	if ($mdef_file[$i] ne $built_in_fake_file) {
	  #print STDERR "NAME=$name,", join(", ",@{$macros{$name}}),"\n";
	  # Used to output $i third here, but it's irrelevant.
	  print "$name", $iDef, $file_inclusion_method{$mdef_file[$i]},
	  $mdef_file[$i], $mdef_line[$i], count_macro_args($mdef_args[$i]),
	  $mdef_physical_lines[$i], $mdef_physical_ncnb_lines[$i],
	  $categoryname[$mdef_category[$i]],
	  # FIX: add type name back in when we get that working
	  #$type_name_array[$mdef_type[$i]],
	  "\n%" . join("\n%",@{$mdef_expansion_uses[$i]}), "\n";
	}
      }
    }
  }

  # -F = dump the function information
  # Want a histogram of this info?  try something like:
  # awk '$0 !~ /^[%#]/ {print $2}' < gzip.func | sort -n | uniq -c
  if ($opt_F) {
    select FUNCTIONS;
    print "#functionId cMacroExpansions (%the macros)\n";
    my $function_name_id;
    foreach $function_name_id (sort keys %function_name_to_macros_it_uses) {
      print $function_name_id,scalar(@{$function_name_to_macros_it_uses{$function_name_id}}),"\n%",
      join(",",@{$function_name_to_macros_it_uses{$function_name_id}}), "\n";
    }
  }

  if ($opt_L) {
    my $filename;
    select FUNCLINES;
    foreach $filename (sort keys %files_lines) {
      print "file: $filename\n", join("\n ",@{$files_lines{$filename}}), "\n";
    }
    my $function;
    foreach $function (sort keys %function_to_locs) {
      my $info;
      print "function: $function ";
      my @infos = @{$function_to_locs{$function}};
      if ($#infos == 0)
	{ print join(', ',@{$infos[0]}); }
      else {
	# avoid extra semicolon at end of line
	my @one_file_results = (); # each elt describes one file
	foreach $info (@infos) {
	  # Don't really need semicolon at end of last entry
	  push(@one_file_results, join(', ',@$info));
	}
	print join('; ',@one_file_results);
      }
      print "\n";
    }

    # Use "local" instead; it seems to work.
    # FIXPERL: Why does this give me an unitialized variable warning?
    # undef $OFS if (defined($OFS));
  }

  if ($opt_C) {
    my $name;
    foreach $name (sort keys %macros) {
      my $iDef;
      for ($iDef = 1 ; $iDef <= $macros{$name}[0]; $iDef++ ) {
	my $index = $macros{$name}[$iDef];
	my $category = $mdef_category[$index];
	my $type = $mdef_type[$index];
	if (!defined($mdef_file[$index])) {
	  print STDERR "mdef_file[$index] not defined\n"
	}
	if (!defined($mdef_line[$index])) {
	  print STDERR "mdef_line[$index] not defined\n"
	}
	if (!defined($categoryname[$category])) {
	  print STDERR "categoryname[$category] not defined\n";
	}
	print CATEG "$mdef_file[$index]:$mdef_line[$index]: "
	  . ($mdef_args[$index] ? "function, " : "") . $categoryname[$category];
	if (($category == $catEXP)
	    || ($category == $catEXPFREE)
	    || ($category == $catLITERAL)
	    || ($category == $catCONSTANT)
	    || ($category == $catSOMECONSTANT))
	  { print CATEG "(", type_name($type), ")"; }
	print CATEG ": $mdef_name[$index]$mdef_args[$index] $mdef_body[$index]\n";
      }
    }
  }
}


# Returns a categorization string describing how the macro was used
# (one of eight (was four)); in alphabetical order:
#   Code CodeCond CodeMacro CodeMacroCond Cond Macro MacroCond NoUses
sub how_used_from_code_cpp_uses ($$$) {
  my ($cCodeUses, $cMacroUses, $cCondUses) = check_args(3,@_);
  my $result = (($cCodeUses > 0) ? "Code" : "")
    . (($cMacroUses > 0) ? "Macro" : "")
      . (($cCondUses > 0) ? "Cond" : "");
  if ($result eq "")
    { return "NoUses"; }
  else
    { return $result; }
}


# Return a sorted version of the list
# passed in, with duplicates removed
sub UniquifyAndSortList (@) {
  my (@list) = check_args_at_least(0, @_);
  if (!wantarray) {
    die "UniquifyAndSortList should return to an array context.";
  }
  my %seen = ();
  foreach (@list) {
    $seen{$_} = $true;
  }
  return sort (keys %seen);
}

# Returns a list of the categories for the various definitions
# of the macro with a given name
sub CategoriesForMacroName ($) {
  my ($name) = check_args(1,@_);
  my $iDef;
  my @list = ();
  for ($iDef = 1 ; $iDef <= $macros{$name}[0]; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    die if !defined($macros{$name});
    die if !defined($macros{$name}[$iDef]);
    die if !defined($mdef_category[$index]);
    push @list, $categoryname[$mdef_category[$index]];
  }
  #print STDERR "CFMN\n";
  return UniquifyAndSortList(@list);
}

# Returns a list of the inclusion methods of the various
# files in which the macro with a given name is defined
sub InclusionMethodsForMacroName ($) {
  my ($name) = check_args(1,@_);
  my $iDef;
  my @list = ();
  for ($iDef = 1 ; $iDef <= $macros{$name}[0]; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    die if !defined($macros{$name});
    die if !defined($macros{$name}[$iDef]);
    die if !defined($mdef_file[$index]);
    my $filename = $mdef_file[$index];
    die "$filename has no inclusion method" if !defined($file_inclusion_method{$filename});
    push @list, $file_inclusion_method{$filename};
  }
  #print STDERR "IMFMN\n";
  return UniquifyAndSortList(@list);
}

sub OutputHistogram ($$$;$) {
  my ($heading,$hashref,$divisor,$fPrintHeading) = check_args_range(3,4,@_);
  my @headings_list = ();
  my @values_list = ();
  my $h;
  foreach $h (sort keys %$hashref) {
    push @headings_list, $h;
    my $v = $ {$hashref}{$h};
    if ($divisor == 0) {
      if ($v != 0)
	{ die "How can divisor be 0 but numerator be $v?"; }
      push @values_list, $v;
    } elsif ($divisor == 1) {
      # This case feels gratuitous
      push @values_list, $v;
    } else {
      push @values_list, sprintf "%2.2f",pct2($v,$divisor);
    }
  }
  if (defined($fPrintHeading)) { print "#${heading}#: ", join($OFS,@headings_list) . "\n"; }
  print "$heading: ", join($OFS,@values_list) . "\n";
}


###########################################################################
### Read lines
###

my $incomment = $false;		# in /* */ style comment
my $instring = $false;

use vars '$current_raw_fulltoken_line';	# not "my" because dynamically bound
$current_raw_fulltoken_line = "";

# Shouldn't be in a character constant across lines.
# my $incharconst = $false;
use vars '$commaop';		# not "my" because dynamically bound
$commaop = $true;		# whether commas should be operators or not
				# (they shouldn't in arglists, initializers)


# Returns the simplified line.  Maybe should also return info about ncnb,
# etc.; currently global variables are set in this function, which seems
# fine.

# Uses global $getline_simplify.
#   Comments are always stripped from result.
#   If $getline_simplify is set, then character and string literals are
#     replaced by 'a' and "" respectively.  That lets us do a simple
#     syntactic check for parens, braces, commas, etc., obviating the need
#     for has_token, which redoes all this work anyway.
# If calls to peek_fulltoken_line have been made, those strings are returned (uses
#   global @getline_ungot_{raw,simple}_lines), without any processing of
#   comments or literals (which was done by peek_fulltoken_line), but with macro
#   preprocessor command processing.  peek_fulltoken_line avoids macro preprocessor
#   command processing by setting $getline_nocpp.
# To simplify an arbitrary string, use updateinvars.

# Read the next line from <INPUT>, until no continuation char
#   and not in string or comment.  The result will never end in mid-token.
# Result ends with newline.
#
# Constructing simplified values are a bit wasteful on the first pass, when we
# only care about macro definitions; special-case that?
sub get_fulltoken_line (;$)
{ my ($continuation) = check_args_range(0, 1, @_);
  if (!defined($continuation))
    { $continuation = $false; }
  if ($instring || $incomment)
    { mdie("Bad instring $instring or incomment $incomment"); }

  # print "Called get_fulltoken_line\n";

  $getline_physical_lines = 0;
  $getline_physical_ncnb_lines = 0;

  my $simple_result;
  my $raw_result;
  if ((@getline_ungot_raw_lines > 0) && !$getline_peeking)
    { # print "popping getline_ungot_raw_lines $getline_ungot_raw_lines[$#getline_ungot_raw_lines]  getline_ungot_simple_lines $getline_ungot_simple_lines[$#getline_ungot_simple_lines]"; # no newline: it ends with one
      # print "all ungot_raw_lines: <<", join(">><<", @getline_ungot_raw_lines), ">>\n";
      # print "all ungot_simple_lines: <<", join(">><<", @getline_ungot_simple_lines), ">>\n";
      $raw_result = shift(@getline_ungot_raw_lines);
      $simple_result = shift(@getline_ungot_simple_lines);
      # Don't just return here; do more work.  But be careful not to do it
      # twice, so guard much after the else clause with $getline_peeking.
    }
  else
    { ($raw_result, $simple_result, $getline_physical_lines, $getline_physical_ncnb_lines)
	= get_spliced_line();
      # don't check $simple_result, which might be simplified to "" (= false)
      if (not ($raw_result))
	{ return $raw_result; }
      # This screws something up really badly.
      # if (not ($simple_result))
      #  { return $simple_result; }

      # perhaps check for $mdef_name and mention it in message if it's set
      while ($incomment || $instring)
	{
	  my ($next_raw, $next_simple, $next_phys, $next_ncnb) = get_spliced_line();
	  if ($next_raw)
	    # Strict ANSI C does not permit newlines in string constants;
	    # perhaps warn.  On the other hand, most compilers permit it.
	    # Don't bother avoiding append_lines if in string,
	    # because get_spliced_line doesn't bother either.
	    { $getline_physical_lines += $next_phys;
	      $getline_physical_ncnb_lines += $next_ncnb;
	      $raw_result = append_lines($raw_result, $next_raw);
	      $simple_result = append_lines($simple_result, $next_simple); }
	  elsif ($incomment)
	    { evilprint("dangerous: file ends in comment:\n    $raw_result");
	      $incomment = $false; }
	  elsif ($instring)
	    { evilprint("dangerous: file ends in string:\n    $raw_result\n");
	      $instring = $false; }
	  else
	    { die "incomment $incomment or instring $instring must be set"; } } }
  # Save the raw line for the convenience of error messages; don't return
  # it, for the convenience of callers.
  # ***** peekline will have to cope with this.
  if ($continuation)
    { $current_raw_fulltoken_line
	= append_lines($current_raw_fulltoken_line, $raw_result); }
  else
    { $current_raw_fulltoken_line = $raw_result; }

  if ($debug_getline)
    { print STDERR "get_fulltoken_line $getline_physical_lines, $finding_macro_defs: >>$simple_result>>$raw_result"; }

  if (!$getline_nocpp)
    {

      # First pass
      if ($finding_macro_defs) {
	$rg_physical_lines[$current_ftype_index] += $getline_physical_lines;
	$rg_ncnb_lines[$current_ftype_index] += $getline_physical_ncnb_lines;
      }

      # Look for uses only on the second pass.
      if ($finding_macro_uses) {
	# and also only if -a is set or this is a project file
	# don't do it if -u is set (user want to ignore usage)
	if (!$opt_u && ($opt_a || !file_was_included($current_file))) {
	  if (defined($simple_result))
	    # fix: How could $simple_result not be defined??
	    { analyze_for_macro_use($simple_result); }
	}
      }

      if (defined($simple_result) && ($simple_result =~ /^\s*\#/))
	{			# Preprocessor line; usually just return "\n";
	  if ($finding_macro_defs) {
	    $rg_cpp_phys_lines[$current_ftype_index] +=
	      $getline_physical_lines;
	    $rg_cpp_phys_ncnb_lines[$current_ftype_index] +=
	      $getline_physical_ncnb_lines;
	  }
	  return getline_handle_preprocessor_line($raw_result, $simple_result);
	}
    }

  if (!defined($simple_result))
    {    $simple_result = " ";}
  elsif ($simple_result eq "")
    { mdie("empty get_fulltoken_line result"); }
  # print "get_fulltoken_line returning <<$simple_result>>\n"; # $result ends in newline
  return ($simple_result);
}

# Two arguments: token, line, line limit.
# Two result values: success, lines.
sub get_fulltoken_lines_to ($$$)
{ my ($regexp, $line, $limit) = check_args(3, @_);
  if ($line =~ /$regexp/)
    { return($true, $line); }
  my $nextline;
  while (($limit > 0) && ($nextline = get_fulltoken_line($true)))
    { my $success = ($nextline =~ /$regexp/);
      $line = append_lines($line, $nextline);
      if ($success)
	{ return ($true, $line); } }
  parse_error("Didn't match regexp '$regexp' after $limit lines: $line");
  return($false, $line)
}


# ***** Need to keep track of number of physical and ncnb lines, for each
# element of @getline_ungot_raw_lines; or just don't reprocess next time
# around (remember whether it was popped), though that could make the
# values wrong.
sub peek_fulltoken_line ($)
{
  my ($arg) = check_args(1, @_);
  if ($arg < 1)
    { mdie ("bad argument $arg to peekline", caller); }
  if ($debug_peek)
    { print "called peek_fulltoken_line($arg)\n";
      print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
      print "ungot simple: ", join("  >>", @getline_ungot_simple_lines); }

  if (@getline_ungot_raw_lines != @getline_ungot_simple_lines)
    { die ("Unequal ungot_{raw,simple} sizes ",
	   scalar(@getline_ungot_raw_lines), " ",
	   scalar(@getline_ungot_simple_lines)); }

  if ($arg <= @getline_ungot_raw_lines)
    { # We have previously peeked at the line in question
      # Was @getline_ungot_raw_lines-$arg; how did that work at all?
      my $index = $arg-1;
      return($getline_ungot_simple_lines[$index]); }
  else
    { if ($arg < (@getline_ungot_raw_lines + 1))
	{
	  # This should never happen:  why would one look two
	  # lines ahead before checking the next line?
	  mdie("Why look far ahead when you haven't looked near?  $arg " . scalar(@getline_ungot_raw_lines));
	  # Old implementation.
	  # # Recursively fill up the arrays
	  # peek_fulltoken_line($arg-1);
	}
      if ($arg != (@getline_ungot_raw_lines + 1))
	{ die "arg $arg != getline_ungot_raw_lines+1 ", (@getline_ungot_raw_lines + 1); }

      # Do the real work.
      my $nextline;
      { local $getline_peeking = $true;
	# Perhaps $getline_peeking can replace this use of $getline_nocpp??
	local $getline_nocpp = $true;
	local $current_raw_fulltoken_line;
	# print "peeking about to call get_fulltoken_line\n";
	$nextline = get_fulltoken_line();
	# print "peeking found $nextline";
	push (@getline_ungot_simple_lines, $nextline);
	push (@getline_ungot_raw_lines, $current_raw_fulltoken_line);
      }
      if ($debug_peek) { print "peek_fulltoken_line($arg) returning $nextline"; }
      return($nextline); }
}


# Takes a simplified line as its argument; returns a string containing the
# unbalanced braces (empty string if all braces are balanced).
sub brace_change ($)
{ my ($line) = check_args(1, @_);
  # print "brace_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\{\}]/)
    { $result_chars .= $MATCH;
      if ($MATCH eq "\{")
	{ $result_num++; }
      elsif ($MATCH eq "\}")
	{ $result_num--; }
      else
	{ mdie("What match? $MATCH"); }
      $line = $POSTMATCH; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Takes a simplified line as its argument; returns a string containing the
# unbalanced parens (empty string if all parens are balanced).
# Perhaps this should also check for braces (and complain or err if any are
# found before parens balance).
sub paren_change ($)
{ my ($line) = check_args(1, @_);
  # print "paren_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\(\)]/)
    { $result_chars .= $MATCH;
      if ($MATCH eq "\(")
	{ $result_num++; }
      elsif ($MATCH eq "\)")
	{ $result_num--; }
      else
	{ mdie("What match? $MATCH"); }
      $line = $POSTMATCH; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Return index of first close paren which doesn't match a preceding open paren
# in the argument string, and the argument string.  Ignores strings, braces, etc.
# Optional second argument says where to start (right after the open, usually).
# Optional third argument says whether to read lines to try to balance (in
# which case the second return value can differ from the first input value).
sub find_close_paren ($;$$)
{ my ($exp, $pos, $read) = check_args_range(1, 3, @_);
  if (!defined($pos))
    { $pos = 0; }
  if (!defined($read))
    { $read = $false; }
  # print "find_close_paren: $exp\n";
  my $opens = 1;
  my $brace_pos;			# undefined if no brace found
  { my $open_pos = index($exp, "\{", $pos);
    my $close_pos = index($exp, "\}", $pos);
    $brace_pos = ($open_pos == -1) ? $close_pos
      : ($close_pos == -1) ? $open_pos
	# min($open_pos, $close_pos)
	: ($open_pos < $close_pos) ? $open_pos : $close_pos;
    if ($brace_pos == -1)
      { undef($brace_pos); } }

  while ($opens > 0)
    { my $next_open = index($exp, "\(", $pos);
      my $next_close = index($exp, "\)", $pos);
      # print "next_open $next_open next_close $next_close\n";
      if (($next_close != -1)
	  && (($next_open == -1) || ($next_close < $next_open)))
	{ if (defined($brace_pos) && ($next_close > $brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  $opens--;
	  $pos = $next_close+1; }
      elsif (($next_open != -1)
	     && (($next_close == -1) || ($next_open < $next_close)))
	{ if (defined($brace_pos) && ($next_open > $brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  $opens++;
	  $pos = $next_open+1;
	  # print "open paren at $next_open, opens = $opens, pos = $pos\n";
	}
      else
	# Didn't find an open or close parenthesis.
	{ if (!(($next_open == -1) && ($next_close == -1)))
	    { mdie("bad values for next_open $next_open and next_close $next_close"); }
	  # print "didn't find next paren, opens = $opens\n";
	  if (!$read)
	    { mdie("insufficient closing parens in $exp"); }
	  if (defined($brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  my $nextline = get_fulltoken_line($true);
	  # print "*** read in find_close_paren: $nextline";
	  if ($nextline =~ /[\{\}]/)
	    { if (!defined($brace_pos))
		{ $brace_pos = length($exp); }
	      $brace_pos += length($PREMATCH);
	      if (substr($exp . $nextline, $brace_pos, 1) !~ /[\{\}]/)
		{ die("I just found a brace at position $brace_pos of $exp$nextline"); } }
	  # print "find_close_paren appending $nextline";
	  $exp .= $nextline; } }
  return ($pos - 1, $exp);
}

## FIX:  throttle this after a certain number of lines have been read.
## Also, I could perhaps better implement this recursively than as a loop.
# Return index of first close brace which doesn't match a preceding open brace
# in the argument string, and the argument string.  Ignores strings, parens, etc.
# Optional second argument says where to start (right after the open, usually).
# Optional third argument says whether to read lines to try to balance (in
# which case the second return value can differ from the first input value).
sub find_close_brace ($;$$)
{ my ($exp, $pos_init, $read) = check_args_range(1, 3, @_);
  if (!defined($pos_init))
    { $pos_init = 0; }
  if (!defined($read))
    { $read = $false; }
  # print "find_close_brace: $exp\n";
  my $opens = 1;
  my $pos = $pos_init;

  while ($opens > 0)
    { my $next_open = index($exp, "\{", $pos);
      my $next_close = index($exp, "\}", $pos);
      # print "next_open $next_open next_close $next_close\n";
      if (($next_close != -1)
	  && (($next_open == -1) || ($next_close < $next_open)))
	{ $opens--;
	  $pos = $next_close+1; }
      elsif (($next_open != -1)
	     && (($next_close == -1) || ($next_open < $next_close)))
	{ $opens++;
	  $pos = $next_open+1;
	  # print "open brace at $next_open, opens = $opens, pos = $pos\n";
	}
      else
	{ if (!(($next_open == -1) && ($next_close == -1)))
	    { mdie("bad values for next_open $next_open and next_close $next_close"); }
	  # print "didn't find next brace, opens = $opens\n";
	  if (!$read)
	    { mdie("insufficient closing braces in $exp"); }
	  my $nextline = get_fulltoken_line($true);
	  # This is a fairly serious problem: may have read the remaining file.
	  if (!defined($nextline))
	    { parse_error("Never found close brace in $exp");
	      return ($pos_init, $exp); }
	  # print "find_close_brace appending $nextline";
	  $exp .= $nextline; } }
  return ($pos - 1, $exp);
}

# Returns (raw_line, simplified_line, num_phys_lines, num_ncnb_lines)
# Always reads directly from input, never from ungotlines.
sub get_spliced_line (;$)
{
  check_args_range(0, 1, @_);
  my ($cpp_comment) = check_args_range(0, 1, @_);
  if (!defined($cpp_comment))
    { $cpp_comment = $false; }

  my $raw_line = <INPUT>;
  if (not ($raw_line))
    { return ($raw_line, $raw_line, 0, 0); }
  my $num_physical_lines = 1;
  my ($simple_line, $num_ncnb_lines)
    = ($cpp_comment ? ($raw_line, 0) : updateinvars($raw_line));

  if ($debug_getline)
    { print "initial simple: $simple_line\ninitial raw: $raw_line"; }
  while ($raw_line =~ m/\\$/)	# could test against either raw or simple here
    { # Remove backslash and possibly newline.
      # Could use $raw_line = $PREMATCH, but would need to use substr or
      #   do a match against $simple_line anyway.
      if (substr($raw_line, -1) eq "\\")
	{ evilprint("evil: file ends with backslash (no newline)\n");
	  $raw_line = substr($raw_line, 0, length($raw_line)-1);
	  if (!($incomment || ($instring && $getline_simplify)))
	    { if (substr($simple_line, -1) ne "\\")
		{ die "Didn't find backslash-nonewline where there must be one: '$simple_line'\n"; }
	      $simple_line = substr($simple_line, 0, length($simple_line)-1); }
	  elsif ((length($simple_line) >= 1) && (substr($simple_line, -1) eq "\\"))
	    { die "Found backslash-nonewline where there mustn't be one: '$simple_line'\n"; } }
      else
	{ if (substr($raw_line, -2) ne "\\\n")
	    { die "Didn't find backslash-newline where there must be one: '$raw_line'\n"; }
	  $raw_line = substr($raw_line, 0, length($raw_line)-2);
	  if (!($incomment || ($instring && $getline_simplify)))
	    { if (substr($simple_line, -2) ne "\\\n")
		{ die "Didn't find backslash-nonewline where there must be one: '$simple_line'\n"; }
	      $simple_line = substr($simple_line, 0, length($simple_line)-2); }
	  elsif ((length($simple_line) >= 2) && (substr($simple_line, -1) eq "\\\n"))
	    { die "Found backslash-nonewline where there mustn't be one: '$simple_line'\n"; } }
      my $next_raw_line = <INPUT>;
      if (! $next_raw_line)
	# Already removed backslash and newline from result.
	{ evilprint("dangerous: file ends with continuation character:\n    $raw_line\n"); }
      else
	{ $num_physical_lines++;
	  my ($next_simple_line, $next_ncnb_lines) =
	    ($cpp_comment ? ($next_raw_line, 0) : updateinvars($next_raw_line));
	  $num_ncnb_lines += $next_ncnb_lines;
	  # append_lines trims spaces (if any), prettying the message (but
	  #   maybe changing string contents).
	  $raw_line = append_lines($raw_line, $next_raw_line);
	  if ($debug_getline)
	    { print "appending '$simple_line' '$next_simple_line'\n"; }
	  $simple_line = append_lines($simple_line, $next_simple_line);
	  if ($next_raw_line =~ m/^\s*$/)
	    { # $next_raw_line is blank.  $raw_line has no newline.
	      evilprint("dangerous: blank line follows continuation character:\n    $raw_line\n"); }
	} }

  # Remove the filename in #include <foo.h>, which act like quotes.
  if ($getline_simplify && ($simple_line =~ /^(\s*\#\s*include\s+<).*>\s*$/))
    { $simple_line = $1 . ">\n"; }

  # $raw_line and $simple_line end in newline
  if ($debug_getline)
    { print "get_spliced_line returning with incomment $incomment instring $instring:\n >>$raw_line >>$simple_line"; }
  return ($raw_line, $simple_line, $num_physical_lines, $num_ncnb_lines);
}

# Like get_spliced_line, but tries the ungotlines cache first and never calls
# updateinvars.
# This is a bit of a hack.
sub get_spliced_line_maybe_ungot ()
{
  check_args(0, @_);

  if (@getline_ungot_raw_lines > 0)
    { # print "popping getline_ungot_raw_lines $getline_ungot_raw_lines[$#getline_ungot_raw_lines]  getline_ungot_simple_lines $getline_ungot_simple_lines[$#getline_ungot_simple_lines]"; # no newline: it ends with one
      # print "all ungot_raw_lines: <<", join(">><<", @getline_ungot_raw_lines), ">>\n";
      # print "all ungot_simple_lines: <<", join(">><<", @getline_ungot_simple_lines), ">>\n";
      my $raw_result = shift(@getline_ungot_raw_lines);
      my $simple_result = shift(@getline_ungot_simple_lines);

      # What are the right values for the last two return values?
      return ($raw_result, $simple_result, 1, 1);
    }
  else
    { return get_spliced_line($true); }
}



###########################################################################

sub resetinvars ()
{
  check_args(0, @_);
  $instring = $false;
  $incomment = $false;
}

# updateinvars is called on a *physical* line;
#   backslash line continuations have not been processed.

# updateinvars is called only by get_spliced_line at present, but could
#   conceivably be called by others, particularly to aid in removing comments
#   or string/character literals.
# Obeys global variable $getline_simplify; see get_fulltoken_line documentation.
# Returns: (simplified string, num_ncnb_lines)
# I hope that always simplifying isn't terribly inefficient...
sub updateinvars ($)
{
  my ($remaining) = check_args(1, @_);
  my $result = "";
  my $seen_ncnb = 0;		# not a boolean, but 0 or 1 (like a boolean)

  if ($debug_getline)
    { print "updateinvars ($getline_simplify): $remaining\n"; }

  while ($remaining)
    { if ($incomment)
	{ if ($remaining =~ /\*\//)
	    { $remaining = $POSTMATCH;
	      $incomment = $false; }
	  else
	    { goto UIV_RETURN; } }
      elsif ($instring)
	{ $seen_ncnb = 1;
	  # print "in string, processing $remaining";
	  if ($remaining =~ m/$non_escaped_double_quote_re/o)
	    # Found a non-escaped double quote
	    { # print "non-escaped double quote: $result|$remaining|$PREMATCH|$MATCH|$POSTMATCH\n";
	      if ($getline_simplify)
		{ $result .= "\""; }
	      else
		{ $result .= $PREMATCH . $MATCH; }
	      if ($debug_getline)
		{ print "post-nonescdquote: '$result' '$remaining'\n"; }
	      $remaining = $POSTMATCH;
	      $instring = $false; }
	  else
	    { # print "$current_file:", current_line_no(), ": in string after line $_[0]";
	      if (!$getline_simplify)
		{ if ($debug_getline)
		    { print "not simplifying; appending '$remaining'\n"; }
		  $result .= $remaining; }
	      goto UIV_RETURN; } }
      # If not instring, \" suffices instead of the more complicated
      # regexp that checks for leading backslashes.
      elsif ($remaining =~ m/\/[\*\/]|[\'\"]/)
	{ my $match = $MATCH;
	  my $postmatch = $POSTMATCH;
	  $result .= $PREMATCH;
	  if ($match eq "\'")
	    { if ($postmatch =~ m/^$char_literal_contents_re\'/o)
		{ if ($getline_simplify)
		    { $result .= "'a'"; }
		  else
		    { $result .= "'" . $MATCH; }
		  $remaining = $POSTMATCH; }
	      else
                # No newline, since $_[0] has one.
		{ evilprint("illegal: bad character constant $match" . add_newline($postmatch) . "    in $_[0]");
		  if ($postmatch =~ /\'/)
		    { if ($getline_simplify)
			{ $result .= "'a'"; }
		      else
			{ $result .= "'" . $MATCH; }
		      $remaining = $POSTMATCH; }
		  else
		    { $remaining = $postmatch; } } }
	  elsif ($match eq "\"")
	    { $result .= $match;
	      if ($debug_getline)
		{ print "Added double quotes to result: '$result'\n"; }
	      $remaining = $POSTMATCH;
	      $instring = $true; }
	  elsif ($match eq "//")
	    { if ($PREMATCH !~ /^\s*$/)
		{ $seen_ncnb = 1; }
	      $result .= "\n";	# so we don't return an empty line, which
				# looks like failure or end of file
	      goto UIV_RETURN; }
	  elsif ($match eq "/*")
	    { $remaining = $POSTMATCH;
	      if ($PREMATCH !~ /^\s*$/)
		{ $seen_ncnb = 1; }
	      $incomment = $true; }
	  else
	    { mdie("updateinvars: what match?  $match in $_[0]"); } }
      else
	{ if ($remaining !~ /^\s*$/)
	    { $seen_ncnb = 1; }
	  $result .= $remaining;
	  goto UIV_RETURN; }
    }

  UIV_RETURN:
  # Code that used to be here has been moved into callers.
  if ($debug_getline)
    { print "updateinvars returning ($instring, $incomment) '$result'\n"; }

  # Second return value is either 0 or 1
  return ($result, $seen_ncnb);
}


# This isn't needed any longer, because a simplified string has no
# comments, strings, or character literals to confuse a simplistic check.
# (Don't remove it yet, though, just in case we need it later.)
# # Assumes no comments
# sub has_token
# {
#   my ($token, $line) = @_;
#   check_args(1, @_);
#   if (!defined($token)) { mdie("undefined token, line $line"); }
#   if (!defined($line)) { mdie("undefined line, token $token"); }
# 
#   # Check for character constants to avoid processing " in one.
# 
#   # If not instring, I think \" suffices instead of the more complicated
#   # regexp that checks for leading backslashes.
#   while (($line =~ m/[\"\']/)
# 	 # should regexp-quote $token
# 	 || ($line =~ m/\Q$token\E/))
#     { my $match = $MATCH;
#       $line = $POSTMATCH;
#       print "has_token($token) matched $match before $line\n";
#       if ($match eq $token)
# 	{ return $true; }
#       elsif ($match eq "\"")
# 	{ if ($line =~ /$non_escaped_double_quote_re/o)
# 	    { $line = $POSTMATCH; }
# 	  else
# 	    { mdie("Didn't find end of string literal $line."); } }
#       elsif ($match eq "'")
# 	{ if ($line =~ /^$char_literal_contents_re\'/o)
# 	    { $line = $POSTMATCH; }
# 	  else
# 	    { mdie("Didn't find end of character literal $line."); } }
#       else
# 	{ mdie("What match $match in $line"); } }
#   return $false;
# }


# Argument is a simplified line.
# Returns the line that should be the get_fulltoken_line result, usually "\n";
sub getline_handle_preprocessor_line ($$)
{
  my ($line, $line_noc) = check_args(2, @_);
  # print "getline_handle_preprocessor_line: $line == $line_noc"; # $line ends with newline
  if ($line_noc =~ /^\s*\#\s*$/)
    { # null preprocessor command; do nothing
      return "\n";
    }
  elsif ($line_noc =~ m/^\s*\#\s*($identifier_re)\s*/o)
    { # Found a real preprocessor command
      my $cpp_cmd = $1;
      $line_noc = $POSTMATCH;
      # Don't just look for $MATCH -- it may contain a trailing newline
      if ($line !~ s/^\s*\#\s*$cpp_cmd\s*//) # no /o
	{ die "Should have seen '$MATCH' in '$line' -- was at head of '$MATCH $line_noc'\n"; }
      $line = $POSTMATCH;
      $line_noc =~ s/^\s+//;	# remove leading whitespace
      $line_noc =~ s/\s+$//;	# remove trailing whitespace
      return getline_handle_preprocessor_command($cpp_cmd, $line, $line_noc); }
  elsif ($line =~ m/^\s*\#\s*\d+\s*\".*\"\s*$/)
    { #FIX: should we count these
      evilprint("File might be preprocessor's output--line marker found at $current_file:" . current_line_no() . "\n");
    }
  else
    { mdie("Strange preprocessor line |$line|"); }
}


# This is a catchall for everything that has to be done to a preprocessor line.
# It's a bit gross to do it this way, but it seems most expedient.
# Always do:
#  * set @dependenton
# Sometimes do:
#  * if $finding_macro_defs, then in first pass:
#      * for each use of the preprocessor, set $cppcmdcount
#      * for each #define, call process_macro_definition
#  * if $finding_macro_uses, then in second pass:
#      * at present, do no extra work
#  * if $merge_cpp_ if_branches, then try to merge #if ... #else ... #endif
#
# Control the action via the following variables: ...
sub getline_handle_preprocessor_command ($$$)
{
  # $cpp_cmd and $cpp_cmd_arg contain no leading or trailing space.
  my ($cpp_cmd, $cpp_cmd_arg, $cpp_cmd_arg_noc) = check_args(3, @_);

  # print "getline_handle_preprocessor_command (", scalar(@dependenton), "): $cpp_cmd $cpp_cmd_arg == $cpp_cmd_arg_noc\n";

  if ($finding_macro_defs) {
    # handle @rg_cpp_cmds and @%rg_cppcmdcounts
    update_cpp_directive_counts($cpp_cmd);
  }

  if ($cpp_cmd eq "if")
    { if (cpp_trivially_false_condition($cpp_cmd_arg_noc))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $getline_physical_ncnb_lines; }
	  my $cond = discard_to_endif_or_else();
	  if ($cond)
	    { return getline_handle_preprocessor_command("if", $cond, $cond); } }
      else
	# Not trivially false #if.  (If trivially true, do the usual thing here.)
	{ push(@dependenton, $cpp_cmd_arg_noc);
	  # print "if ", current_line_no(), " $cpp_cmd_arg; now dependent on @dependenton\n";
	  if ($merge_cpp_if_branches
	      && !cpp_trivially_true_condition($cpp_cmd_arg_noc))
	    { my $merged = cpp_merged_branches();
	      if (defined($merged))
		{ return $merged; } }
	} }
  elsif ($cpp_cmd eq "ifdef")
    { push(@dependenton, "defined($cpp_cmd_arg_noc)");
      # print "ifdef ", current_line_no(), " $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifndef")
    { push(@dependenton, "!defined($cpp_cmd_arg_noc)");
      # print "ifndef ", current_line_no(), " $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "endif")
    { if (@dependenton == 0)
	{ mdie("extra \#endif"); }
      # print "endif ", current_line_no(), " $dependenton[$#dependenton]; ";
      my $last = pop(@dependenton);
      if (cpp_trivially_false_condition($last)
	  # I think this test is never necessary.
	  || cpp_trivially_true_condition($last))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $getline_physical_ncnb_lines; } }
      # print "now dependent on @dependenton.\n";
    }
  elsif ($cpp_cmd eq "else")
    { if (@dependenton == 0)
	{ mdie("improperly nested \#else"); }
      my $last = pop(@dependenton);
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": #else testing '$last' for triviality: ", cpp_trivially_true_condition($last), "\n"; }
      if (cpp_trivially_true_condition($last))
	{ if ($finding_macro_defs)
	    # Count this as a comment, not NCNB, line.
	    { $rg_ncnb_lines[$current_ftype_index] -= $getline_physical_ncnb_lines; }
	  discard_to_endif(); }
      else
	# Not trivially true condition
	{ push(@dependenton, negate_cpp_if_condition($last)); } }
  elsif ($cpp_cmd eq "elif")
    { if (@dependenton == 0)
	{ mdie("improperly nested \#elif"); }
      my $last = pop(@dependenton);
      if (cpp_trivially_true_condition($last))
	{ discard_to_endif(); }
      else
	# Not trivially true condition
	{ push(@dependenton,
	       "(" . negate_cpp_if_condition($last) . ") && $cpp_cmd_arg_noc");
	} }
  elsif ($cpp_cmd eq "define")
    { if ($finding_macro_defs)
	{ process_macro_definition($cpp_cmd_arg, $cpp_cmd_arg_noc,$getline_physical_lines,$getline_physical_ncnb_lines); }
    }
  elsif ($cpp_cmd eq "include")
    {
      # Only want to handle #include directives on the pass
      # where we're looking for macro definitions--
      # when we're finding_macro_uses, #include "ctype.h" becomes
      # #include "" in updateinvars, so we can't do it there again, anyway
      if ($finding_macro_defs && !$fIgnoreIncludes) {
	# print "Got include '$cpp_cmd_arg_noc'\n";
	# For now, hack for gnuchess-4.0.pl77/src/binsort.c
	if ($cpp_cmd_arg_noc =~ /^(errno|std(io|lib)|time)$/)
	  { $cpp_cmd_arg_noc = "<$cpp_cmd_arg_noc.h>"; }
	if ($cpp_cmd_arg_noc !~ /^(?:<(.*)>|\"(.*)\")$/) {
	  # FIX: actually, this is legal, if it's a CPP name that expands to "..." or <...>.
	  # For now, hack for gnuchess-4.0.pl77/src/binsort.c
	  if ($cpp_cmd_arg_noc !~ /^(descrip|processes|unixio)$/)
	    { mdie('#include not followed by file name in "" or <>: ', $cpp_cmd_arg_noc, " == ", $cpp_cmd_arg_noc); }
	  parse_error("Ignoring VAX include $cpp_cmd_arg\n");
	  # Just fall through if one of the OK-to-ignore includes
	} else {
	  my $angled_include = $false;
	  my $include_file;
	  if ($1 ne "") {
	    $angled_include = $true;
	    $include_file = $1;
	  } else {
	    $include_file = $2;
	  }
	  my $complete_filename = complete_include_pathname($include_file, $angled_include);
	  if (!defined($complete_filename))
	    { # FIX:  make complete_include_pathname work when $angled_include
	      # is false, and then restore this (and eliminate the "else"...)
	      # mdie("Can't resolve include file $include_file");
	    }
	  else {
	    # Check to see if we're already reading this file anyway
	    # if we resolved the filename to a real file,
	    # and we've not already added the file to our list we need to parse
	    if (scalar(grep($_ eq $complete_filename, @files_included)) == 0) {
	      # FIX: may want to insert this where we are
	      # or do some sort of recursive reading of *all* included files
	      # WEIRD: Why does this cause a problem in parsing a macro argument
	      #      when I use @files instead of @files_included
	      if (!forbidden_file($complete_filename))
		{ push @files, $complete_filename;
		  push @files_included, $complete_filename;
		  $file_inclusion_method{$complete_filename} = "FromInclude" .
		    ($angled_include? "<>" : '""');
		  # print STDERR "Adding \"$complete_filename\" as $file_inclusion_method{$complete_filename}\n";
		}
	    }
	  }
	}
      }
    }
  elsif ($cpp_cmd eq "undef")
    { process_macro_undefinition($cpp_cmd_arg, $cpp_cmd_arg_noc)
    }
  else
    { # Some other cpp command
      # print "unhandled cpp command \#$cpp_cmd $cpp_cmd_arg\n";
    }
  return "\n";
}


# Read and discard lines until we find the matching #endif
# No return value.
sub discard_to_endif ()
{
  check_args(0, @_);
  if ($incomment || $instring)
    { mdie("Can't be incomment $incomment or instring $instring\n"); }
  my $if0depth = 1;
  my $line;
  while ($if0depth > 0)
    # Don't use get_spliced_line(); the getline lookahead cache might not be empty.
    { my ($raw_line, $simple_line, $phys, $ncnb) = get_spliced_line_maybe_ungot();
      if (not $raw_line)
	{ mdie("File ends in \#if 0"); }
      resetinvars();		# Abandon changes by get_spliced_line
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": discarding (to endif @dependenton) $raw_line"; }
      # I'll trust that no comment or string contains anything that looks
      # like a preprocessor command.  Strictly speaking, I should use
      # get_fulltoken_line and/or updateinvars, because anything in an
      # #if is supposed to be a sequence of valid tokens, but #if 0
      # often contains non-syntactic constructs.  (Maybe eventually use
      # get_fulltoken_line/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($simple_line =~ m/^\s*\#\s*if(n?def)?\b/o)
	{ $if0depth++; }
      elsif ($simple_line =~ m/^\s*\#\s*endif\b/o)
	{ $if0depth--; } }
  return;
}

# If #endif, return $false.
# If #else or #elseif, return a fake #if condition for re-processing.
sub discard_to_endif_or_else ()
{
  check_args(0, @_);
  if ($incomment || $instring)
    { mdie("Can't be incomment $incomment or instring $instring\n"); }
  my $if0depth = 1;
  while ($if0depth > 0)
    # Don't use get_spliced_line(); the getline lookahead cache might not be empty.
    { my ($raw_line, $simple_line, $phys, $ncnb) = get_spliced_line_maybe_ungot();
      if (not $raw_line)
	{ mdie("File ends in \#if 0"); }
      resetinvars();		# Abandon changes by get_spliced_line
      if ($debug_cpp_if_comments)
	{ print input_file_and_line(), ": discarding (to endif or else; dependenton @dependenton) $raw_line"; }
      # I'll trust that no comment or string contains anything that looks
      # like a preprocessor command.  Strictly speaking, I should use
      # get_fulltoken_line and/or updateinvars, because anything in an
      # #if is supposed to be a sequence of valid tokens, but #if 0
      # often contains non-syntactic constructs.  (Maybe eventually use
      # get_fulltoken_line/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($simple_line =~ m/^\s*\#\s*if(n?def)?\b/o)
	{ $if0depth++; }
      elsif (($if0depth == 1) && ($simple_line =~ m/^\s*\#\s*else\b/))
	{ if ($debug_cpp_if_comments)
	    { print input_file_and_line(), ": returning !0 from discard_to_endif_or_else (dependenton @dependenton)\n"; }
	  return "!0"; }
      elsif (($if0depth == 1) && ($simple_line =~ m/^\s*\#\s*elif\s+/))
	{ my $cond = $POSTMATCH;
	  $cond =~ s/\s+$//;
	  if ($debug_cpp_if_comments)
	    { print input_file_and_line(), ": returning $cond from discard_to_endif_or_else (dependenton @dependenton)\n"; }
	  return $cond; }
      elsif ($simple_line =~ m/^\s*\#\s*endif\b/o)
	{ $if0depth--; } }
  return $false;
}

# This handles
#     #if...
#     #elsif ...
#     #else
#     #if...
#     #endif
#     #endif
# and returns, instead, a single merged string when possible.
# It does not handle other types of nesting, such as
#     #if...
#     #if...
#     #else
#     #endif
#     #if
#     #else
#     #endif
#     #endif
# should it be able to do the latter?


# Returns the sum of all the previous sizes (including the final #endif)
# and a list of the parts.
# First return value is undefined if failure (?).
sub cpp_merge_candidates ($)
{
  # sum of all previous sizes; 0 on initial call.
  my ($prev_sizes) = check_args(1, @_);
  if ($debug_merge_branches) { print "cpp_merge_candidates @dependenton\n"; }

  my @parts = ();

  my $size_limit = 10;
  my $num_endifs = 0;		# number of extra #endif commands
  my $next_line;

  # This should be a loop rather than a goto.
THENPART:
  # At this point we are already past the initial #if
  $next_line = peek_fulltoken_line($prev_sizes+1);
  if (!defined($next_line)) {
    return;
  }
  if ($debug_peek)
    { my $peeked_at = $prev_sizes+1;
      print "Just peeked at $peeked_at (ungot 1+$#getline_ungot_raw_lines): $next_line";
      print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
      print "ungot simple: ", join("  >>", @getline_ungot_simple_lines);
    }
  if ($next_line =~ /^\s*\#\s*if(n?def)?\b/)
    { if ($debug_merge_branches)
	{ print "cpp_merge_candidates making recursive call from then\n"; }
      my @sub_parts;
      ($prev_sizes, @sub_parts) = cpp_merge_candidates($prev_sizes+1);
      if ($debug_merge_branches)
	{ print "cpp_merge_candidates recursive call from then "
	    . (defined($prev_sizes) ? "succeeded:  " : "failed\n");
	  if (defined($prev_sizes))
	    { print join(" >>", @sub_parts); } }
      if (!defined($prev_sizes))
	{ return; }
      $next_line = peek_fulltoken_line($prev_sizes+1);
      if (!defined($next_line)) {
	return;
      }
      if ($next_line !~ /^\s*\#\s*els(e|if)\b/)
	{ return; }
      $prev_sizes++;
      # Would push have worked equally well here?
      @parts = (@parts, @sub_parts);
    }
  else
    { my $then_clause;
      if ($debug_peek)
	{ print "not if at head of then clause; peek $prev_sizes, ungot 1+$#getline_ungot_raw_lines\n";
	  print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
	  print "ungot simple: ", join("  >>", @getline_ungot_simple_lines); }
      ($then_clause, $prev_sizes) = peek_to_cpp_command('els(e|if)', $prev_sizes, $size_limit);
      if (!defined($then_clause))
	{ return; }
      push(@parts, $then_clause);
      $next_line = peek_fulltoken_line($prev_sizes); # not $prev_sizes+1
      if (!defined($next_line)) {
	return;
      }
    }

  if ($debug_merge_branches) { print "cpp_merge_branches: thenpart $parts[$#parts]"; }
  if ($next_line =~ /^\s*\#\s*elsif/)
    { goto THENPART; }
  if ($next_line !~ /^\s*\#\s*else/)
    { $next_line =~ s/\n$//;	# remove newline so we get better die output
      # Unconditional prints, because we are about to die.
      print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
      print "ungot simple: ", join("  >>", @getline_ungot_simple_lines);
      die "Just saw else or elsif (peekahead $prev_sizes): $next_line"; }

ELSEPART:
  $next_line = peek_fulltoken_line($prev_sizes+1);
  if (!defined($next_line)) {
    return;
  }
  if ($next_line =~ /^\s*\#\s*if(n?def)?\b/)
    # This was else ... if; treat it like elsif and go back to then part
    { if ($debug_merge_branches)
	{ print "cpp_merge_candidates making recursive call from else\n"; }
      my ($sub_prev_sizes, @sub_parts) = cpp_merge_candidates($prev_sizes+1);
      if ($debug_merge_branches)
	{ print "cpp_merge_candidates recursive call from else "
	    . (defined($sub_prev_sizes) ? "succeeded\n" : "failed\n"); }
      if (!defined($sub_prev_sizes))
	{ return; }
      $next_line = peek_fulltoken_line($sub_prev_sizes+1);
      if (!defined($next_line)) {
	return;
      }
      if ($next_line !~ /^\s*\#\s*endif\b/)
	{ return; }
      $prev_sizes = $sub_prev_sizes+1;
      # Would push have worked equally well here?
      @parts = (@parts, @sub_parts);
    }
  else
    { my $else_clause;
      ($else_clause, $prev_sizes) = peek_to_cpp_command('endif', $prev_sizes, $size_limit);
      if (!defined($else_clause))
	{ return; }
      push(@parts, $else_clause);
      $next_line = peek_fulltoken_line($prev_sizes); # not prev_sizes+1
      if (!defined($next_line)) {
	return;
      }
    }
  if ($debug_merge_branches) { print "cpp_merge_branches: elsepart $parts[$#parts]"; }
  if ($next_line !~ /^\s*\#\s*endif/)
    { die "Just saw endif: $next_line"; }

  # @parts holds the desired values; maybe merge them.
  return ($prev_sizes, @parts);
}

# If the next cpp command after $peekahead lines from here matches
# $cpp_cmd_re and is within $size_limit lines of here, then return the
# the peekahead of the matching command, plus all the text between.
# Otherwise return the undefined value.
sub peek_to_cpp_command ($$$)
{ my ($cpp_cmd_re, $peekahead, $size_limit) = check_args(3, @_);
  if ($debug_peek)
    { print "entering peek_to_cpp_command(peekahead = $peekahead; ungot $#getline_ungot_raw_lines): $cpp_cmd_re\n";
      print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
      print "ungot simple: ", join("  >>", @getline_ungot_simple_lines); }
  my $this_result = "";
  my $this_size = 0;
  my $next_line = peek_fulltoken_line($peekahead+1);
  while ($next_line !~ /^\s*\#\s*$cpp_cmd_re\b/)
    { if ($debug_peek)
	{ print "didn't find $cpp_cmd_re, offset $this_size: $next_line"; }
      if (($this_size > $size_limit) || ($next_line =~ /^\s*\#/))
	{ return; }
      # was $this_result .= $next_line;
      $this_result = append_lines($this_result, $next_line);
      $this_size++;
      $next_line = peek_fulltoken_line($peekahead+$this_size+1); }
  $peekahead += $this_size+1;
  if ($debug_peek)
    { print "peek_to_cpp_command returning (peek = $peekahead; $#getline_ungot_raw_lines ungot lines) <<$this_result>>\n";
      print "ungot raw: ", join("  >>", @getline_ungot_raw_lines);
      print "ungot simple: ", join("  >>", @getline_ungot_simple_lines); }
  return ($this_result, $peekahead);
}



# Returns a merged string.
# Returns the undefined value if
#  * cpp commands are too far separated
#  * series of cpp commands not one of those handled
#  * parts are different, not brace-unbalanced, or differently brace-unbalanced
# We have already read a #if line, which is reflected in @dependenton.
# @dependenton will be magically updated by a series of calls to
# get_fulltoken_line, if this function is successful.


sub cpp_merged_branches ()
{
  check_args(0, @_);
  if ($debug_merge_branches) { print "cpp_merged_branches @dependenton\n"; }

  # $parts_size = sum of sizes of all parts (and preprocessor glue like "#else")
  my ($parts_size, @parts) = cpp_merge_candidates(0);
  #   if (peek_fulltoken_line($parts_size+1) !~ /^\s*\#\s*endif/)
  #     { die "Should have seen an endif: ", peek_fulltoken_line($parts_size+1); }
  #   $parts_size++;		# account for the final #endif

  if ((!defined($parts_size)) || ($parts_size < 2))
    { return; }

  # Variable @parts holds the desired values; merge them if possible.

  # Check whether all the parts are the same (modulo whitespace, maybe)
  # This can happen because of string simplification.
  { my $first_part = $parts[0];
    if ($getline_simplify) { $first_part =~ s/\s+/ /; }
    my $all_same = $true;
    my $index = 1;
    while ($all_same && ($index <= $#parts))
      { my $other_part = $parts[$index];
	if ($getline_simplify) { $other_part =~ s/\s+/ /; }
	$all_same = ($first_part eq $other_part);
	$index++; }
    if ($all_same)
      { my $i;
	for $i (1..$parts_size)
	  { # put it in a variable for the convenience of the print below
	    my $discarded = get_fulltoken_line();
	    # print "discarding $discarded";
	  }
	if ($debug_merge_branches) { print "returning one of ", scalar(@parts), " identical parts: $first_part"; }
	return $first_part; } }

  # Check whether the parts are all equally brace_unbalanced.
  # (If none are brace_unbalanced, no need to merge.)
  { my $firstbrace_change = brace_change($parts[0]);
    if ($firstbrace_change ne "")
      { my $all_same = $true;
	{ my $index = 1;
	  while ($all_same && ($index <= $#parts))
	    { $all_same = ($firstbrace_change eq brace_change($parts[$index]));
	      $index++; } }
	if ($all_same)
	  { my $i;
	    for $i (1..$parts_size)
	      { # put it in a variable for the convenience of the print below
		my $discarded = get_fulltoken_line();
		# print "discarding $discarded";
	      }
	    if ($debug_merge_branches) { print "merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n"; }
	    return merge_brace_unbalanced_lines($firstbrace_change, @parts); } } }

  # None of them are brace-unbalanced.  Check another special case:  multiple
  # declarations at the front of a function body.

  { # print "peeking for function body at ", peek_fulltoken_line($parts_size+1), "\n";
    my $ln = peek_fulltoken_line($parts_size+1);
    if (!defined($ln)) {
      return;
    }
    if ($ln =~ /^\s*\{/)
      { # print "found an open brace\n";
	if ($parts[0] =~ /^\s*$type_declarator_re\s*\(/o)
	  { my $rettype = $1;
	    my $fname = $2;	# actually a declarator
	    # print "found a function declarator '$rettype' '$fname'(\n";
	    if ($fname =~ /^$identifier_re$/)
	      { my $index = 1;
		while ($fname && ($index <= $#parts))
		  # This test is a hack.
		  # Ought not insist that return type be identical, maybe?
		  # Ought not insist on identical spacing in rettype.
		  { if ($parts[$index] !~ /^\s*$rettype\s*$fname\s*\(/)
		      { # print "part $index didn't match: $parts[$index]\n";
			$fname = $false; }
		    $index++; }
		if ($fname)
		  # FIX: This is a hack, done for expediency.
		  { # print "Arbitrarily returning first of ", scalar(@parts), " function definition headers for $fname\n";
		    # print " >>", join(" >>", @parts);
		    my $i;
		    for $i (1..$parts_size)
		      { # put it in a variable for the convenience of the print below
			my $discarded = get_fulltoken_line();
			# print "discarding $discarded";
		      }
		    if (peek_fulltoken_line(1) !~ /^\s*\{/)
		      { die "Must have seen an open brace following brances: ", peek_fulltoken_line(1); }
		    return($parts[0]); } } } } }

  if ($debug_merge_branches) { print "cpp_merged_branches: no sense merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n"; }

  return;
 }


# All of the lines are identically brace-unbalanced
sub merge_brace_unbalanced_lines ($@)
{ my ($braces, @lines) = check_args_at_least(3, @_);

  my $pieces = length($braces)+1;

  my @split_lines = ();
  { my $i;
    for $i (0..$#lines)
      { my @this_pieces = split(/[\{\}]/, $lines[$i]);
	if ($pieces != @this_pieces)
	  { mdie("should have $pieces, not ", scalar(@this_pieces), ", pieces: $lines[$i]"); }

	@{$split_lines[$i]} = @this_pieces;
	# # Does this work?  Don't risk it...
	# # $split_lines[$i] = @this_pieces;
	## Old version, replaced by the above
	# { my $piece;
	#   for $piece (0..$#this_pieces)
	#     { $split_lines[$i][$piece] = $this_pieces[$piece]; } }
      } }

  my $result = "";
  { my $piece;
    for $piece (0..$pieces-1)
      { { my $i;
	  for $i (0..$#lines)
	    { if (!defined($split_lines[$i][$piece]))
		{ my $p;
		  for $p (0..$pieces)
		    { my $i;
		      for $i (0..$#lines)
			{ print "$p $i <<$split_lines[$i][$p]>>\n"; } }
		  mdie("piece $piece, index $i not defined"); }
	      $result = append_lines($result, $split_lines[$i][$piece]); } }
	if ($piece != $pieces)
	  { $result .= substr($braces, $piece, $piece+1); } } }
  $result;
}



sub is_cpp_command ($)
{ my ($line) = check_args(1, @_);
  return ($line =~ /^\s*\#/);
}

## According to the Perl FAQ, this is fastest for small strings, but for
## big ones or worst cases, it's quite slow.
## In any event, it isn't used right now.
# # Watch out: this removes the trailing newline.
# sub trim_whitespace ($)
# {
#   my ($result) = check_args(1, @_);
#   $result =~ s/^\s+//;
#   $result =~ s/\s+$//;
#   # if ($result =~ /^\s+(.*)$/) { $result = $1; }
#   # # (.*)\s+ only gets rid of last space
#   # if ($result =~ /^(.*[^\s])\s+$/) { $result = $1; }
#   return $result;
# }


# This pretties things up but changes contents of line-spanning strings,
# so don't call it if ARG1 ends inside a string.
sub append_lines ($$)
{
  my ($arg1, $arg2) = check_args(2, @_);
  # "+" instead of "*" wouldn't introduce spaces where there were none before;
  # but we want to make sure the two lines don't just run together.
  $arg1 =~ s/[ \t\n]*$/ /;
  $arg2 =~ s/^[ \t\n]*/ /;
  return ($arg1 . $arg2);
}

# Return an array of three elements: name, args, def.
# None have leading or trailing whitespace
sub macrosplit ($)
{ my ($line) = check_args(1, @_);
  # print "macrosplit $line\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($line =~ m/^($identifier_re)(\([^\)]*\))?\s*(.*?)\s*$/o);
  if ($#result != 2)		# ($# == 2) => 3 elements
    { mdie("Problem parsing macro `$line'"); }
  @result;
}


###########################################################################
### Parse expressions
###

# This is currently called when categorizing macro bodies; will also be
# used to parse function calls and macro arguments, to determine what is
# passed to the macro and what context the macro is being called in.

# I'm not completely clear on when types should be ignored and when not.
# Quite possibly that should be a global rather than passed around everywhere.

# This should also return an actual value, when that is known, or some
# information about the value.  When failure is returned, that return value
# indicates the reason for failure.

# Lists of all the variables, functions, types encountered during the parse.
my %parsevars = ();
my %parsefuns = ();
my %parsetypes = ();
my $parse_exp_saw_equals = $false;

# Should check @parsexxxs for reserved words; if we find any, I misparsed.
sub reset_parse_vars ()
{
  # Could use undef instead...
  %parsevars = ();
  %parsefuns = ();
  %parsetypes = ();
  $parse_exp_saw_equals = $false;
}

# Returns a type and the remaining string.
# Side-effects: %parsevars, %parsefuns, %parsetypes.  (It would be way too
# much trouble to pass these around and return them everywhere.)
sub parse_expression ($)
{
  my ($exp) = check_args(1, @_);
  reset_parse_vars();
  # print "parse_expression $exp\n";
  # Should be no comments when this is called, so no need to do this.
  # my ($type, $remaining) = parse_exp(remove_comments($exp));
  return parse_exp($exp);
}


sub parse_exp_nocommaop ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $false;
  return parse_exp($exp, $ignoretypes);
}

sub parse_exp_commaop ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $true;
  return parse_exp($exp, $ignoretypes);
}


# Like parse_expression, but doesn't reset @parsexxxs.
# Returns two values:  the expression's type and the remaining string.
# Every call should be followed by   "if (!$type) { return($typeFAIL,$exp); }"
# See H&S p. 181.
sub parse_exp ($;$)
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  if ($debug_parse_expression)
    { print "parse_exp", ($ignoretypes ? " (ignore types)" : ""), ": '$exp'\n"; }
  # If ignoretypes is set, then we don't try to infer types, look up types
  # of unknown functions, or set symbol tables.  We do still compute types
  # for literals and return a type, I think.

  # Perhaps remember length of @parsexxxs, so we can restore them if failure.
  # But right now we never fail unless everything fails, so never mind...

  $exp =~ s/^\s+//;		# remove leading space

  # First, cope with open parens

  # Cast
  if ($exp =~ /^\(\s*($builtin_type_re)\s*\)/)
    { # print "Found cast $1\n";
      my $casttype = parse_type($1);
      my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      my $casttypenum = type_to_num($casttype);
      # print "built-in cast type num = $casttypenum for cast type = $casttype\n";
      if (!is_number($casttypenum))
	{ $parsetypes{$casttypenum} = $true; }
      return parse_exp_follower($casttypenum, $remaining); }
  # Type in parens followed by (what looks like) paren, number, identifier, or
  # unary operator (without a binary counterpart: no +-!&*)
  if (($exp =~ /^\(\s*($type_re)\s*\)\s*([0-9a-zA-Z_\(~])/)
      || ($exp =~ /^\(\s*($type_re\s*$type_suffix_re+)\s*\)\s*(.)/o) # ends with *: pointer
      # identifier ending with _t: type
      || ($exp =~ /^\(\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*\)\s*(.)/)
      # identifier which expands to reserved word: type
      || (($exp =~ /^\(\s*($identifier_re)\s*\)\s*(.)/)
	  && defined($mncategory{$1})
	  && (($mncategory{$1} eq $catTYPE)
	      # Is this latter really necessary?
	      || ($mncategory{$1} eq $catRESDWORD)))
      )
    { my $casttype = parse_type($1);
      my $nextchar = $LAST_PAREN_MATCH;
      # print "non-built-in cast type $casttype (follower $nextchar)\n";
      $parsetypes{$casttype} = $true;
      my ($type, $remaining) = parse_exp($nextchar . $POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($casttype,$remaining); }
  # print "not a cast: $exp\n";

  # Parens as grouping
  if ($exp =~ m/^\(/)
    { my ($type, $remaining) = parse_exp_commaop($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      if ($remaining =~ m/^\s*\)/)
	{ return parse_exp_follower($type, $POSTMATCH); }
      else
	{ return($typeFAIL,$exp); } }

  # Unary prefix operators
  if ($exp =~ /^(\+\+|--|[-~!+&*])/)
    { my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      # This isn't right -- eg, & result type differs from argument type
      return parse_exp_follower($type,$remaining); }
  # [^\)] was [ \ta-zA-Z0-9*]
  if ($exp =~ /^sizeof\s*/)
    { # Two possibilities:  sizeof(TYPE) or sizeof EXP.
      # If no parens, we know it's an expression.
      # If parens, it might be an expression or a type; have to guess.
      my $sizeof_follower = $POSTMATCH;
      my $sizeof_arg_type;
      my $remaining;
      if (($sizeof_follower =~ /\(\s*([^\)]+?)\s*\)/)
	  && (($remaining = $POSTMATCH) || $true) # execute for side effect
	  && (($sizeof_arg_type = $1) =~ /^$type_re$/o))
	{ # $remaining is already set
	  # fix: add this type to the list of those seen.
	  # (It might be an expression that looks like a type; what to do?
	  # Can check $reserved_type_word_re...
	}
      else
	{ ($sizeof_arg_type, $remaining) = parse_exp($sizeof_follower, $ignoretypes);
	  if (!$sizeof_arg_type)
	    { return($typeFAIL,$exp); }
	}
      # actually "size_t", but "int" is understood and that isn't yet.
      return parse_exp_follower($typeINT, $remaining); }

  # Literals

  # Literal string
  # This regular expression is perhaps expensive; split into two tests?
  # By this point, the literal value might be "" due to simplification.
  if ($exp =~ /^$string_literal_re/o)
    # String contains no non-escaped double-quote
    # Should look for a following string, to concatenate the two.
    # Perhaps special-case:  look for symbol (which is macro with typeSTRING)
    # or literal string.
    { return parse_exp_follower($typeSTRING, $POSTMATCH); }

  # Literal character
  if ($exp =~ /^$char_literal_re/o)
    { return parse_exp_follower($typeCHAR, $POSTMATCH); }

  # Literal floating-point
  # This precedes integer because an integer matches the first part of a float
  if (($exp =~ /^$float_literal_whole_re/o)
      || ($exp =~ /^$float_literal_frac_re/o)
      || ($exp =~ /^$float_literal_exp_re/o)
      || ($exp =~ /^$float_literal_noexp_re/o))
    { my $type = $typeDOUBLE;
      if (($2 eq "f") || ($2 eq "F"))
	{ $type = $typeFLOAT; }
      elsif (($2 eq "l") || ($2 eq "L"))
	{ $type = $typeLDOUBLE; }
      return parse_exp_follower($type,$POSTMATCH); }

  # Literal integer (octal)
  # Don't need leading [-+]? because they are always unary operators, never
  # part of the literal itself.
  if (($exp =~ /^$hex_literal_re/o)  # hex
      # hex precedes octal/decimal because the "0" looks like a leading integer.
      # (Actually, that's irrelevant here since infer_int_type does the work.
      || ($exp =~ /^$dec_oct_literal_re/o)) # octal or decimal
    { my $int_literal = $1;
      my $int_modifiers = $2;
      my $remaining = $POSTMATCH;
      if ($debug_parse_expression)
	{ print "Found integer $int_literal (modifiers $int_modifiers)\n"; }
      my $type = infer_int_type($int_literal);
      if ($debug_parse_expression) { print "inferred type ", type_name($type), "\n"; }
      if ($int_modifiers =~ /[uU]/)
	{ $type = type_unsignify($type); }
      if ($int_modifiers =~ /[lL]/)
	{ $type = type_longify($type);
	  if ($int_modifiers =~ /[lL][lL]/)
	    { $type = type_longify($type); } }
      # return parse_exp_follower($type,$remaining);
      my @result = parse_exp_follower($type,$remaining);
      if ($debug_parse_expression)
	{ print "parse_exp_follower(", type_name($type), ",$remaining) => ", join("||", @result), "\n"; }
      return @result;
    }

  # Array initializer
  elsif ($exp =~ /^\{/)
    { my ($array_init_type, $post_array_init) = parse_array_initializer($POSTMATCH);
      if (!$array_init_type)
	{ return($typeFAIL, $exp); }
      return ($array_init_type, $post_array_init);
    }

  # Variable
  elsif (($exp =~ /^$identifier_re/o)
	 # Hack for identifiers with leading $
	 || ($exp =~ /^\$+$identifier_re/o))
    { my $var = $MATCH;
      my $remaining = $POSTMATCH;
      # Fix: don't do this if the identifier is a macro argument.
      # Otherwise the definition of A in /sysdeps/mach/hurd/i386/__sigret.c
      # fouls up glibc:/malloc/realloc.c:96:  min(A, B) ((A) < (B) ? (A) : (B))
      # See if this is a macro, and if so try to categorize it now.
      # (This assumes that parse_exp isn't called until all macros bodies
      # have been discovered; I think this is reasonable, as the first pass
      # does no parsing.)
      categorize_macro_name($var);
      my $vartype = $mntype{$var};
      my $is_macro = defined($vartype);
      if ($is_macro)
	{ # This is kind of a hack; is it the right thing to do?
	  if ((!$vartype) && defined($mncategory{$var}) && $mncategory{$var})
	    { $vartype = "category: $mncategory{$var}"; }
	  if ($debug_parse_expression)
	    { print "macro $var as variable of type '", type_name($vartype), "'\n"; } }
      else
	# This isn't a macro.
	# Need to do a MUCH better job here; in particular, infer a type.
	# Perhaps return a negative number, an index into a list of things
	# whose types need to be inferred.
	# Also try looking up in global symbol table.
	{ $vartype = $typeUNKNOWN; }

      # Perhaps do something different if the categorization was successful.
      # Not sure what this means: "Perhaps get info back here, so we can stash
      # it in calls to macros.  Make sure that agrees with Greg's data structures."
      if ($remaining =~ /^\s*\(/)
	{ if (!$is_macro) { $parsefuns{$var} = $true; }
	  return parse_arglist($vartype, $POSTMATCH);
	}
      else
	{ if (!$is_macro) { $parsevars{$var} = $true; }
	  return parse_exp_follower($vartype, $remaining); }
    }
  else
    { if ($debug_parse_expression) { print "Couldn't match $exp\n"; }
      return ($typeFAIL, $exp); }
}


# $ftype should be a function type; this will return only the return type.
# $arglist already has leading paren stripped.
sub parse_arglist ($$)
{
  my ($return_type, $arglist_orig) = check_args(2, @_);
  if ($debug_parse_expression) { print "parse_arglist: '$return_type' '$arglist_orig'\n"; }
  my $arglist = $arglist_orig;
  my @argtypes = ();

  # Need a notation for function types; maybe just -> in front.
  while ($arglist !~ /^\s*\)/)
    { my ($thisargtype, $comma) = parse_exp_nocommaop($arglist);
      if (!$thisargtype) { return($typeFAIL, $arglist); }
      push(@argtypes, $thisargtype);
      if ($comma =~ /^\s*,/)
	{ $arglist = $POSTMATCH; }
      elsif ($comma =~ /^\s*\)/)
	{ $arglist = $comma; }
      else
	{ my ($file, $line, $sub) = (caller(0))[1,2,3];
	  parse_error("parse_arglist called from $sub: no comma or close paren after well-formed arg '$arglist_orig', remaining = '$arglist'\n");
	  return($typeFAIL, $arglist); } }
  if ($arglist !~ /^\s*\)/)
    { die "Impossible; just saw a close paren"; }
  return parse_exp_follower(construct_function_type($return_type, @argtypes), $POSTMATCH);
}

# $initializer already has leading brace stripped
sub parse_array_initializer ($)
{
  my ($initlist) = check_args(1, @_);

  if ($debug_parse_array_init)
    { print "parse_array_initializer $initlist"; } # $initlist ends in newline

  # C allows an extra comma at the end of the initializer list.
  if ($initlist =~ /^\s*(,\s*)?\}/)
    { return (construct_array_type($typeUNKNOWN, 0), $POSTMATCH); }

  my $elttype;
  while ($true)
    { my ($thisinittype, $comma);
      if ($debug_parse_array_init)
	{ print "current initlist = $initlist"; } # $initlist ends in newline
      if ($initlist =~ /^\s*\{/)
	{ if ($debug_parse_array_init)
	    { print "recursive call to parse_array_initializer\n"; }
	  ($thisinittype, $comma) = parse_array_initializer($POSTMATCH);
	  # transform subinittype from array to scalar type
	  if ($debug_parse_array_init)
	    { print "after recursive call to parse_array_initializer: $comma\n"; }
	}
      else
	{ ($thisinittype, $comma) = parse_exp_nocommaop($initlist);
	  if ($debug_parse_array_init)
	    { print "parse_exp_nocommaop returned (", type_name($thisinittype), ") $comma\n"; }
	}
      if (!$thisinittype) { return($typeFAIL, $initlist); }
      if (!defined($elttype))
	{ $elttype = $thisinittype; }
      else
	{ # FIX: do this
	  # $elttype = merge_somehow($elttype, $thisinittype);
	}

      # push $thisinittype somewhere
      if ($comma =~ /^\s*(,\s*)?\}/)
	# FIX: should remember length and return it, too.
	{ return (construct_array_type($elttype), $POSTMATCH); }
      elsif ($comma =~ /^\s*,/)
	{ $initlist = $POSTMATCH; }
      else
	{ parse_error("Neither comma nor close brace followed well-formed init $initlist\n");
	  return($typeFAIL, $initlist); } }
  mdie("Can't get to here.");
}

# Returns a success boolean, the post-closeparen string, and the declarations.
# These might be:
#   * identifiers or type decls (if in definition)
#   * types or type decls (if in declaration)
# so don't try to distinguish; just return them literally.
sub parse_function_decl_args ($)
{
  my ($text) = check_args(1, @_);
  # print "parsing arg decls in $text\n";

  my @arg_decls = ();

  if (($text =~ /^\s*\)/) || ($text =~ /^\s*void\s*\)/)
      || (($text =~ /^\s*($identifier_re)\s*\)/)
	  && exists($macros{$1}) && exists($void_macros{$1})))
    # No arguments
    { return ($true, $POSTMATCH, @arg_decls); }

  # I have no way of preferring to parse as a typedecl vs. as
  # a type vs as a bare identifier (won't know until reading ";" or "{" after
  # the arglist whether this is a function definition or declaration).
  # Disambiguate later.
  # print "looking for type or type declarator in $text\n";
  while (
	 # Gross special case.  I'm sorry.
	 ($text =~ /^\s*($type_re_special)\s*([,\(\)])/o)
	 || ($text =~ /^\s*(($type_declarator_re)|($type_re))\s*([,\(\)])/o)
	 || ($text =~ /^\s*(\.\.\.)\s*(\))/o))
    { my $arg_decl = $1;
      my $nextchar = $LAST_PAREN_MATCH;
      $text = $POSTMATCH;
      if ($nextchar eq "\(")
	{ # This function argument declarator declares a function.
	  my ($success, $remaining, @sub_arg_decls) = parse_function_decl_args($text);
	  if ((!$success) || ($remaining !~ m/^\s*([,\)])/))
	    { parse_error("Couldn't parse sub-function arg declaration $text");
	      return ($false, $text, ()); }
	  $nextchar = $1;
	  $text = $POSTMATCH;
	  # For now, put it back together and make someone else re-parse it.
	  $arg_decl .= "(" . join(", ", @sub_arg_decls) . ")";
	}
      push(@arg_decls, $arg_decl);
      if ($nextchar eq "\)")
	{ # print "parse_function_decl_args returning ", join(', ', @arg_decls), "\n";
	  return ($true, $text, @arg_decls); }
      if ($nextchar ne ",")
	{ die "Must be at comma: '$nextchar' '$text' '@arg_decls'\n"; }
      # print "new text $text\n";
    }
  parse_error("Couldn't parse function arg declaration $text");
  return ($false, $text, ());
}

# Side effects global %argnametype;
# Return an associative array of names to types and the remaining string
# after the open brace.
# Don't bother sharing code with argument declarator parsing; too much work.
sub parse_KandR_function_arg_decls ($)
{
  my ($argdecls) = check_args(1, @_);
  my %argnametype = ();
  while ($argdecls !~ /^\s*\{/)
    { # print "parsing K&R function arg decls $argdecls\n";
      if ($argdecls !~ /^\s*$type_declarator_re\s*([,;\(])/o)
	{ parse_error("Couldn't parse K&R-style type declarator $argdecls");
	  if ($argdecls !~ /\{/)
	    { mdie("parse_KandR_function_arg_decls: no open brace in '$argdecls'"); }
	  return (%argnametype, $POSTMATCH); }
      my $typespec = $1;
      my $declarator = $2;
      my $nextchar = $LAST_PAREN_MATCH;
      $argdecls = $POSTMATCH;
      my ($type, $identifier) = parse_declarator($typespec, $declarator);
      if ($nextchar eq "\(")
	{ # This function argument declarator declares a function.
	  my ($success, $remaining, @sub_arg_decls) = parse_function_decl_args($argdecls);
	  if ((!$success) || ($remaining !~ m/^\s*(;)/))
	    { parse_error("Couldn't parse sub-function arg declaration $argdecls");
	      if ($argdecls !~ /\{/)
		{ mdie("parse_KandR_function_arg_decls: no open brace in '$argdecls'"); }
	      return (%argnametype, $POSTMATCH); }
	  $nextchar = $1;
	  $argdecls = $POSTMATCH;
	  # For now, put it back together and make someone else re-parse it.
	  $type .= "(" . join(", ", @sub_arg_decls) . ")";
	}
      $argnametype{$identifier} = $type;
      while ($nextchar eq ",")
	{ if ($argdecls !~ /^\s*$declarator_re\s*([,;])/)
	    { parse_error("Couldn't parse declarator following comma after '$typespec $declarator $nextchar': $argdecls\n");
	      if ($argdecls !~ /\{/)
		{ mdie("parse_KandR_function_arg_decls: no open brace in '$argdecls'"); }
	      return (%argnametype, $POSTMATCH); }
	  $declarator = $1;
	  $nextchar = $LAST_PAREN_MATCH;
	  $argdecls = $POSTMATCH;
	  ($type, $identifier) = parse_declarator($typespec, $declarator);
	  $argnametype{$identifier} = $type; } }

  # This doesn't work; rematch the open brace instead
  # print "after K&R, remainder $POSTMATCH\n";
  # return $POSTMATCH;
  if ($argdecls !~ /^\s*\{/)
    { die "parse_KandR_function_arg_decls: didn't find open brace previously found in $argdecls"; }
  return (%argnametype, $POSTMATCH);
}


# This needs to take a value as an argument, too, so it can return that.

# Parse what follows an expression, such as "+3" or "->foo".
sub parse_exp_follower ($$)
{
  my ($type, $follow) = check_args(2, @_);

  if ($debug_parse_expression)
    { print "parse_exp_follower: '", type_name($type), "' '$follow'\n"; }

## Enable when the other bug is squashed.
#  if ($follow =~ /^\s*$/)
#    { return ($type, $follow); }

  # Perhaps this can happen because it's easier to hand off to
  # parse_exp_follower unconditionally than to perform a check.
  if ($type eq $typeFAIL)
    # This isn't quite right since the failure occurred earlier.
    { return($type, $follow); }

  $follow =~ s/^\s+//;		# remove leading space

  # Array subscript
  if ($follow =~ /^\[/)
    { my $subscript = $POSTMATCH;
      my ($subscrtype, $closebracket) = parse_exp($subscript);
      if (!$subscrtype) { return($typeFAIL,$subscript); }
      if (!(type_integral_p($subscrtype) || ($subscrtype eq $typeUNKNOWN)))
	{ parse_error("parse_exp_follower: non-integral type ", type_name($subscrtype), " in subscript in '$follow'\n");
	  return ($typeFAIL, $follow); }
      if ($closebracket =~ /\s*\]/)
	{ my $remaining = $POSTMATCH;
	  return parse_exp_follower(type_dereference($type), $remaining); }
      else
	{ return ($typeFAIL, $follow); } }

  # Function call (might this be some other use of parens??)
  if ($follow =~ /^\(/)
    { return parse_arglist($type, $POSTMATCH); }

  # Unary postfix operators
  if ($follow =~ /^(\+\+|--)/)
    { return parse_exp_follower($type, $POSTMATCH); }
  # Structure selectors
  if ($follow =~ /^\s*(\.|->)\s*$identifier_re/o)
    # Shouldn't give up so easily here; should have record types and try to
    # do the selection.
    { return parse_exp_follower($typeUNKNOWN, $POSTMATCH); }

  # Binary operators:  multi-char operators must precede single-char ones
  if (($follow =~ /^($binop_regexp)/o)
      || ($commaop && ($follow =~ /^(,)/)))
    { my $op = $1;
      my $arg2 = $POSTMATCH;
      if ($debug_parse_expression)
	{ print "parse_exp_follower found binary operator '$op' '$arg2'\n"; }
      if ($op eq ",")
	{ # print "found a comma operator, commaop = $commaop\n";
	}
      if (($op eq "=") || ($op =~ /^[<>][<>]=$/) || ($op =~ /^[^<>=]=$/))
	{ $parse_exp_saw_equals = $true; }
      my ($type2, $post_arg2) = parse_exp($arg2);
      if (!$type2) { return ($typeFAIL, $arg2); }
      # parse_exp_follower is certain to do nothing here, because parse_exp
      # has already gobbled all it can.  Right?  (Unless commaop has changed,
      # or I start to use precedence.)
      if (is_bool_binop($op))
	{ return parse_exp_follower($typeBOOL, $post_arg2); }
      elsif (($op eq ",") || ($op eq "="))
	{ return parse_exp_follower($type2, $post_arg2); }
      else
	{ my $result_type = type_lub($type, $type2);
	  if (($type eq $typeUNKNOWN) && (is_numeric_binop($op)))
	    { $type = $typeNUMBER; }
	  return parse_exp_follower($result_type, $post_arg2); } }

  # Ternary operator ?:
  if ($follow =~ /^\?/)
    { my $then = $POSTMATCH;
      my ($thentype, $colon) = parse_exp($then);
      if (!$thentype) { return ($typeFAIL, $then); }
      if ($colon !~ /^\s*:/) { return ($typeFAIL, $colon); }
      my ($elsetype, $remaining) = parse_exp($POSTMATCH);
      if (!$elsetype) { return ($typeFAIL, $colon); }
      # print "ternary operator: lub($thentype, $elsetype) = ", type_lub($thentype, $elsetype), "\n";
      return (type_lub($thentype, $elsetype), $remaining); }

  # print "Checking for contatenated strings: ", type_name($type), ": $follow\n";
  if (($type eq $typeSTRING)
      && (($follow =~ /^\"/)
	  || (($follow =~ /^$identifier_re/)
	      # Call categorize_macro_name here for side effect.
	      && (categorize_macro_name($MATCH) || $true)
	      && defined($mntype{$MATCH})
	      && ($mntype{$MATCH} eq $typeSTRING))))
    { my ($followtype, $followfollow) = parse_exp($follow);
      if ((!$followtype) || ($followtype ne $typeSTRING))
	{ return ($typeFAIL, $follow); }
      else
	{ return ($typeSTRING, $followfollow); } }

  if ($debug_parse_expression)
    { print "parse_exp_follower returning ", type_name($type), "; found no follower in '$follow'\n"; }
  return ($type, $follow);
}

sub is_bool_binop ($)
{
  my ($op) = check_args(1, @_);
  return ($op =~ /^($bool_binop_regexp)$/o);
}

sub is_numeric_binop ($)
{
  my ($op) = check_args(1, @_);
  return ($op =~ /^($numeric_binop_regexp)$/o);
}


###########################################################################
### Process macro calls
###

### Get types for macro calls

# This is a bit disappointing because it's so heuristic; my inclination is
# really to get it right rather than approximate.

# Find all uses of a macro, to determine types of its arguments.
# (If it isn't used, it can be eliminated -- this will be true of many in
# standard header files, perhaps.)
# Do a rough parse of each file:
#  recognize binding forms:
#     variable declarations, function definitions, function declarations
#     Can use etags to find function defintiions, but it doesn't find
#	global variables.
#  recognize function calls, check whether they are macros
# Cope with macro definitions like "#define local static" and with
#    typedefs like "typedef unsigned long  ulg;" (the latter not to use
#    the raw type, but to permit type_lub to do a better job, maybe).

# Dies if some condition that shouldn't happen at a file boundary is true.
sub check_file_boundary ()
{
  check_args(0, @_);
  my ($package, $filename, $line) = caller;
  if (@dependenton > 0)
    { parse_error("$filename:$line: in \#if at beginning or end of file: @dependenton");
      @dependenton = (); }
  if ((@getline_ungot_raw_lines > 0) || (@getline_ungot_simple_lines > 0))
    { die "$filename:$line: ungot lines at file boundary:\n raw:  >>",
           join("   >>", @getline_ungot_raw_lines),
           " simple:  >>", join("   >>", @getline_ungot_simple_lines), "\n"; }
  if ($symtab_scopes != 0)
    { parse_error("$filename:$line: bad brace depth $symtab_scopes at file boundary.\n");
      while ($symtab_scopes > 0)
	{ exit_scope(); } }
}


sub process_macro_calls ()
{
  check_args(0, @_);
  local $finding_macro_uses = $true;
  local $getline_simplify = $true;
  local $merge_cpp_if_branches = $true;
  # Not foreach because @files can change, I think.
  my $ifiles;
  for ($ifiles = 0; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      # shouldn't have already set this value
      if (defined($files_lines{$current_file}))
	{ mdie("Reprocessing file $current_file?"); }
      @{$files_lines{$current_file}} = ();
      $current_ftype_index = compute_ftype_index($current_file);
      if ($opt_v) {
	print STDERR "file: \"$current_file\" ($file_inclusion_method{$current_file})";
      }
      # do not do the second pass on included files
      if ( file_was_included($current_file) && !$opt_A) {
	print STDERR " -- skipping (use -A option to not skip)\n" if $opt_v;
	next;
      } elsif (!open(INPUT,$current_file)) {
	# fix: Shouldn't we print to STDERR unconditionally?
	# fix: Add quiet option; then this will occur unless that is set.
	print STDERR " -- open failed\n" if $opt_v;
	next;
      } else {
	print STDERR "\n" if $opt_v;
      }

      check_file_boundary();
      # Perhaps I should use a variant of get_fulltoken_line that insists
      # that parens are balanced, too; that might let me more reasonably
      # cope with breaks across lines.
      # Perhaps make global so check_file_boundary can check it.
      my $in_extern_C = 0;
      my $line;
      while ($line = get_fulltoken_line())
	{
	  # print "GOTLINE (indented = $indented) <<$line>>\n";
	  # The line number $. isn't quite right, as we may have peeked ahead
	  # print "line ", current_line_no(), ": $line"; # no newline, since $line contains one
	  if ($line =~ /^\s*$/)
	    { # empty line; possibly was originally a preprocessor command
	    }
	  elsif ($line =~ m/^\s*\#/o)
	    { mdie("get_fulltoken_line shouldn't return preprocessor lines: $line"); }
	  else
	    {			# not empty or a preprocessor line
	      # print "not empty or a preprocessor line $line"; # $line has newline
	      # Are we guaranteed there will be a trailing newline?
	      chop($line);	# remove trailing newline
	      # In a scope, must be indented or: close brace, comment, label

	      # Alternative to variable $indented is making sure that loops
	      #   back to PROCESSLINE append a space to the front of lines
	      #   that were oringally indented, but a portion of which must
	      #   be reprocessed.  (Actually, that wouldn't even be enough,
	      #   since we want to treat bar as unindented in unindented
	      #   "foo; bar;".)
	      my $indented = ($line =~ /^[ \t]/);

	      # Exceptions to indentation checking; a bit hackish.
	      # Perhaps should strip labels here rather than just overlook them.
	      if ((!$indented)
		  && (($line =~ m/^($identifier_re\s*:)/o)
		      || (($symtab_scopes == 1)
			  && ($line =~ m/^(\}|\"|0\};)/))))
		{ # print "setting line to indented: $line\n";
		  $indented = $true; }
	      # Checks for any improperly unindented line.  Later, we
	      # make sure that every properly unindented line was processed.
	      if ((!$indented) && ($symtab_scopes != 0)
		  # Hack!
		  && ($current_file !~ /\by\.tab\.c$/))
		{ parse_error("process_macro_calls: bracedepth $symtab_scopes non-indented line $line "); }

	      # Check for improper indentation later, complaining only
	      # about lines containing definitions/declarations.  (Maybe
	      # should do more checking?)

	      # Look for:
	      #   typedef,
	      #   function definition/declaration (only at symtab_scopes == 0),
	      #   variable definition/declaration,
	      #   function call (of a macro),
	      #   brackets (to keep track of scopes),
	      #   not string/char literals (already simplified).
	      # These can span multiple lines, especially function definitions.

PROCESSLINE:
	      if (!defined($line))
		{ mdie("PROCESSLINE: line undefined."); }
	      # print "PROCESSLINE $line\n";
	      $line = simple_macro_substitute($line);
	      if ($line =~ /^\s*$/)
		{		# do nothing; maybe this was a preprocessor directive
		  # print "empty line ", current_line_no(), ":\n";
		}
	      elsif ($line =~ /^\s*typedef\s+/)
		{		# process typedefs
		  # print "typedef line ", current_line_no(), ": $line\n";
		  $line = $POSTMATCH;
# This is wrong because typedefs can have semicolons inside braces.
#		  my $semi_pos;
# 		  # use index(), because ($line =~ /;/) gave trouble here
# 		  while (-1 == ($semi_pos = index($line, ";")))
# 		    {		# print "no semicolon, so appending a line to $remaining\n";
# 		      $line = append_lines($line, get_fulltoken_line($true)); }
# 		  my $typedef = substr($line, 0, $semi_pos-1); # omits "typedef", ";"
# 		  # process_typedef($typedef);
# 		  $line = substr($line, $semi_pos+1);
# 		  print "after typedef $PREMATCH, set line to $line\n";
		  goto PROCESSLINE;
		}
	      # not $type_specifier_re, because want to catch trailing *
	      elsif (($line =~ /^$type_re\s*$/o)
		     # Dispense with this test, and instead check indentedness.
		     # If unindented, matches type, and next line nonblank,
		     # what else could it be?
# 		     && (($line =~ /$reserved_type_word_re/o) # no anchoring
# 			 ||
#                        # Note peek_fulltoken_line doesn't update @dependenton
#                        # or do branch merging, so this isn't perfect in many
#                        # cases, such as
#                        #  int \n #if (X) \n const \n #endif foo(...)
# 			 # This fails if the second line is "fname MACRO((...))"
# 			 (peek_fulltoken_line(1) =~ /^$declarator_re\s*\(/o))
		     # && ((print "found lone typespec, indented=$indented, line=$line\n") ? $true : $true)
		     && ((!$indented)
			 && (peek_fulltoken_line(1) !~ /^\s*$/))
		     )
		{ # Definition or declaration (probably of a function)
		  # split over multiple lines
		  # print "combining function definition split over multiple lines\n";
		  # Used to be "...-1" (why?), but that gave a too-small answer.
		  $current_function_start_line = current_line_no();
		  my $nextline = get_fulltoken_line($true);
		  if (defined($nextline))
		    { $line = append_lines($line, $nextline);
		      # Don't jump forward, which confuses the loop; start over.
		      goto PROCESSLINE; }
		  else
		    { parse_error("Couldn't combine function def split over lines: $line");
		      # Fall through.
		    } }
	      # The negative lookahead assertion is to avoid matching
	      # "JOBSTATE (previous_job) == JSTOPPED", bash-1.14.7/jobs.c:1697.
	      elsif (($line =~ /^\s*($type_declarator_re)\s*([,=;\(])(?!=)/o)
		     # must check this second, to get "int (*foo) (arg1, arg2)"
		     || ($line =~ /^($identifier_re)\s*(\()/o))
		{
		  # We don't know whether we matched $type_declarator_re or
		  # $identifier_re, so rematch, which is wasteful.
		  my $nextchar = $LAST_PAREN_MATCH;
		  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";") || ($nextchar eq "\(")))
		    { mdie("what nextchar? '$nextchar'"); }
		  my $remaining = $POSTMATCH;
		  my $typespec;
		  my $declarator;
		  { my $identifier_or_typedecl = $1;
		    # Do the easy case first here; order doesn't matter.
		    if ($identifier_or_typedecl =~ /^$identifier_re$/)
		      { # fix: should warn about implicit return type for function.
			$typespec = "((int))";
			$declarator = $identifier_or_typedecl; }
		    elsif ($identifier_or_typedecl =~ /^$type_declarator_re$/o)
		      { $typespec = $1;
			$declarator = $2; }
		    else
		      { mdie("must be identifier or type declarator: $identifier_or_typedecl"); } }
		  if ($debug_type_match)
		    { print "matched type declarator <$typespec><$declarator>\n"; }
		  # print "maybe matched type declarator <$1><$2><$3><$4><$5><$6><$7><$8><$9> <<", defined($macros{$6}[0]), (defined($macros{$6}[0]) ? (">><<$macros{$6}[0] $macros{$6}[1] |$mdef_name[$macros{$6}[1]]|$mdef_args[$macros{$6}[1]]|$mdef_body[$macros{$6}[1]]|$mdef_file[$macros{$6}[1]]|$mdef_line[$macros{$6}[1]]|") : ""), ">>\n";

		  # Fallthroughs below depend on the fact that this is the last
		  # clause in the elsif chain: there's nothing else we would
		  # try to do here if we didn't see a type declarator.

		  if (($typespec eq "Call") && ($declarator eq "UPDATE_HASH"))
		    { # In a #if comment in gzip-1.2.4/deflate.c line 633.
		      # (I don't want to give up on complete parsing yet, but
		      # don't want to mdie here).
		      # print "rejected special case";
		    }
		  elsif ($typespec =~ /$reserved_nontype_word_re/o)
		    { # "else if (...)", "return foo;", "sizeof(buf)", etc.
		      # print "rejected typespec $typespec\n";
		    }
		  elsif ($declarator =~ /$reserved_nontype_word_re/o)
		    {
		      # print "rejected declarator $declarator\n";
		    }
		  elsif (($nextchar eq "(")
			 # Implied by "defined($macros{$declarator}[0])"
			 # && ($declarator =~ /^$identifier_re$/o)
			 && exists($macros{$declarator})
			 # This test is intended to skip over macros that
			 # can't be active right now.
			 && (!macro_dependenton($declarator, @dependenton))
			 )
		    ## FIX: all this belongs in simple_macro_substitute.
		    { # The function being defined is actually a macro.
		      # Try to expand it, else fall through.
		      # print "macro masquerading as declarator $declarator\n";

		      my $identifier = $declarator;

		      my $close_paren_pos;
		      # if parens aren't balanced, read enough text to balance them.
		      ($close_paren_pos, $remaining) = find_close_paren($remaining, 0, $true);

		      # Case 1:
		      # There is only one expansion for the macro.  Expand it.
		      # This isn't quite right if the dependentons aren't
		      # compatible.
		      if (exists($macros{$identifier})
			  && ($macros{$identifier}[0] == 1))
			{ # ... expand macro ...;
			  # goto PROCESSLINE;
			}

		      # Case 2: macro that takes a single arg and either
		      # returns it or returns nothing, which can be used to
		      # construct either a K&R or ANSI function declaration
		      # by passing in a parenthesized list as the argument.
		      # "if (is_fun_decl_arg_macro($identifier))" redoes work.
		      if (defined($fun_decl_arg_macros{$identifier}))
			{
			  mdie("shouldn't find fun_decl_arg_macro $identifier");
			  # ... expand macro ...;
			  # For now, hack it.
			  if ($declarator !~ /^$identifier_re$/o)
			    { mdie("can't have pointer or array declarators"); }
			  # print "expanding empty-paren macro from $line";
			  $line = $typespec . " " . $nextchar
			    . substr($remaining, 0, $close_paren_pos-1)
			      . substr($remaining, $close_paren_pos+1);
			  # print "expanded empty-paren macro to $line";
			  goto PROCESSLINE;
			}

		      # If the macro expands to a symbol plus an open paren
		      # (or uses an open paren in its arg or following it):
		      #  * function declaration, or
		      #  * function definition
		      # If the macro expands to an identifier sans open paren:
		      #  * variable definition or declaration
		      # Let's trust that no one would be so perverse as to
		      # do the latter.

		      # We could fall through and consider this a call or
		      # process arguments, etc.

		      # However, if this was really a function definition,
		      # then that makes us to miss the function name, so we
		      # don't know which function we are in, its argument
		      # types, get errors about entering a scope, etc.

		      # If the type specifier itself parses as a type+declarator
		      # and
		      #  * the macro expands to an open paren, or
		      #  * the macro expands to itself, and the arg start with open paren
		      # then

		      # The relevant variables are $typespec $identifier

		      # print "semi=", defined($semi_fun_decl_arg_macros{$identifier}), ", typespec='$typespec', remaining='$remaining'\n";

		      if (defined($semi_fun_decl_arg_macros{$identifier})
			  && ($remaining =~ /^\s*\(/)
			  && ($typespec =~ /^$type_declarator_re$/o))
			{ # Read up to the open brace and replace it all by
			  # a function declaration with no arguments.
			  # Could do a better job here.
			  # We'd better hope this is really a function
			  # definition and not a function declaration!
			  my $success;
			  ($success, $remaining) = get_fulltoken_lines_to('\{', $remaining, 5);
			  if (!$success)
			    { parse_error("Didn't find an open brace in time in $remaining"); }
			  else
			    { $line = $typespec . '(){' . $POSTMATCH;
			      # print "replaced masquerading macro: '$line' for '$remaining'\n";
			      goto PROCESSLINE;
			    }
			}
		      # print "rejected macro masquerading as function $identifier\n";
		    }
		  else
		    { # This actually is a valid type specifier and declarator
		      my ($type, $identifier) = parse_declarator($typespec, $declarator);

		      # Check indentation.
		      if ($indented
			  && ($symtab_scopes == 0)
			  # accept indented declaration/definition in #if at top scope
			  # (want to reject function defs but not decls; how to do?)
			  && (@dependenton == 0))
			{
			  # print "potential indentation problem; nextchar '$nextchar', line $line\n";
			  # If a few improperly indented lines containing no braces
			  # are followed by a property unindented line, don't mdie.
			  my $proper_follows = $false;
			  { my $follow;
			    for $follow (1..7)
			      { my $next = peek_fulltoken_line($follow);
				# What if this is a preprocessor directive or comment?
				if (!defined($next))
				  { last; }
				if ($next =~ /^[^\s]/)
				  { $proper_follows = $true;
				    last; }
				if ($next =~ /[\{\}]/)
				  { last; } } }
			  if (!$proper_follows)
			    { parse_error("Indented line at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line"); }
			  # print "Overlooked indented line ", current_line_no(), " at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line";
			}	# Done checking indentation.

		      # print "found typespec '$typespec' declarator '$declarator' nextchar '$nextchar' remaining '$remaining' on line ", current_line_no(), "\n";

		      # Get the complete declarator, which might span lines.
		      # $nextchar is in [,=;\(]
		      if ($nextchar eq "(")
			{ # print "no semi or brace, so appending a line to $remaining\n";
			  my $success;
			  ($success, $remaining) = get_fulltoken_lines_to('[;\{=]', $remaining, 5);
			  if (!$success)
			    # FIX: I have no idea which loop is being nexted.
			    # But it's better than failing later on...
			    { parse_error("Didn't find '[;\{=]' in $remaining");
			      next; }
			  if ($remaining !~ /[;\{=]/) # MUST succeed
			    { mdie("Just succeeded with get_fulltoken_lines_to '[;\{=]': $remaining"); }
			  if ($MATCH eq "=")
			    { # This declares not a function but a variable
			      # (say, a pointer to a function).
			      $nextchar = $MATCH;
			      $remaining = $POSTMATCH;
			      $type .= '(' . $PREMATCH; # is this right?
			    } }
		      my $initializer_contains_include = $false;
		      if (($nextchar eq ",") || ($nextchar eq "="))
			# Only need to check the new stuff, not the whole thing.
			{ while ($remaining !~ /;/)
			    {	# print "no semicolon, so appending a line to $remaining\n";
			      # Intentionally not get_fulltoken_lines_to
			      my $nextline = get_fulltoken_line($true);
			      if (!$nextline)
				# This could be really bad: I'm sending
				# control somewhere strange.
				{ parse_error("Didn't find semicolon in $remaining");
				  last; }
			      $remaining = append_lines($remaining, $nextline);
			      # Hack: bc-1.03/global.c line 39 does
			      #   CONST char libmath[] =
			      #   #include "libmath.h"
			      #   ;
			      # DO NOT anchor the regexp with ^, because we are
			      # reading a continuation line, so the whole exp
			      # is in $current_raw_fulltoken_line, not just the
			      # bit we just read.  Not sure whether we can
			      # anchor with \n.  Maybe we ought to be able to.
			      if ($current_raw_fulltoken_line =~ /\#\s*include/)
				{ $initializer_contains_include = $true; } } }
		      # print "found complete declarator in $remaining\n";

		      if (($nextchar eq "(")
			  && ($remaining =~ /[;\{=]/) # MUST succeed
			  && ($1 ne "="))
			{ $line = process_function_definition_or_declaration($type, $identifier, $remaining);
			  goto PROCESSLINE;
			}
		      else
			{
PROCESSVARDEF:
			  # variable definition or declaration
			  # print "variable definition or declaration <<$identifier>> $type\n";
			  # $nextchar = "," or "=" or ";"
			  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";")))
			    { die "what nextchar? '$nextchar'"; }

			  # "symtab_add($identifier, $type)" should
			  # logically happen here, but hold off in case we
			  # find that we are actually not in a variable
			  # definitiion or declaration, but accidentally
			  # processing the argument list of a function
			  # definition or delcaration.  Unfortunately, this
			  # lookahead only busy avoid one incorrect entry.
			  # Should perhaps mdie in this case.

			  if ($nextchar eq ";")
			    { symtab_add($identifier, $type);
			      $line = $remaining;
			      goto PROCESSLINE; }
			  elsif ($nextchar eq ",")
			    {
ATCOMMA:
			      # $remaining is everything after $nextchar
			      if ($remaining =~ /^\s*$declarator_re\s*([,=;])/o)
				{ # Following this variable declaration is
				  # another variable definition or declarator.
				  # First, add the previous thing.
				  symtab_add($identifier, $type);
				  # Now cope with this one.
				  $declarator = $1;
				  $nextchar = $LAST_PAREN_MATCH;
				  $remaining = $POSTMATCH;
				  ($type, $identifier) = parse_declarator($typespec, $declarator);
				  goto PROCESSVARDEF; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*\(/o)
				# This is a function declaration following
				# a variable declaration or definition.
				# I think this code works; does it?
				{ $line = process_function_definition_or_declaration($type, $identifier, $remaining);
				  goto PROCESSLINE; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*([,\)])/o)
				{ # We're accidentally in the argument list of
				  # a function declarator.
				  # Skip to next brace or semicolon.
				  # fix: need to double-check this.
				  $remaining = $POSTMATCH;
				  if ($remaining =~ /[\{;]/)
				    { if ($MATCH eq ";")
					{ $remaining = $POSTMATCH; }
				      else
					{ $remaining = $MATCH . $POSTMATCH; } }
				  elsif ($remaining =~ /\)/)
				    { $remaining = $POSTMATCH; }
				  else
				    { mdie("No semicolon or brace after function declarator?  It can't be!"); }
				  $line = $remaining;
				  goto PROCESSLINE; }
			      else
				{ # FIX: ghostview-1.5/Draw.c:69 fails this.
				  parse_error("Found '$typespec $declarator' ($nextchar) but no following var in $remaining\n");
				  # Fall through; do no more processing of this
				  # line.
				} }
			  elsif ($nextchar eq "=")
			    {	# Skip over an expression and continue processing from there.
			      # print "skipping expression $remaining\n";
			      if ($initializer_contains_include
				  && ($remaining =~ /^\s*;/))
				# Hack for initializer in #included file.
				# Maybe return something of the appropriate type.
				{ $remaining = "0" . $remaining; }
			      my $postexp = skip_expression_nocommaop($remaining);
			      # print "After skip_expression_nocommaop, postexp $postexp\n";

			      if ($postexp eq "")
				{ # do nothing; done with this line, because
				  # parsing of the expression failed
				  parse_error("Failed to parse initializer ",
					      ($initializer_contains_include
					       ? "(has include )" : ""),
					      "$remaining\n"); }
			      elsif ($postexp =~ /^\s*;/)
				{ $line = $POSTMATCH;
				  goto PROCESSLINE; }
			      elsif ($postexp =~ /^\s*,/)
				{ $remaining = $POSTMATCH;
				  $nextchar = ","; # gratuitous, I think.
				  goto ATCOMMA; }
			      else
				# Don't die.  (Eg, flex-2.5.3/FlexLexer.h:70)
				{ parse_error("No comma or semicolon after initializer: '$postexp'"); } }
			  else
			    { mdie("Bad nextchar $nextchar."); } }
		    } }

	      if ((!$indented)
		  && ($line !~ /^\s*$/)
		  # Hack.   Should really expand it and try again.
		  && (($line !~ /^($identifier_re)\s*\(/) && defined($macros{$1})))
		{ parse_error("properly unindented line was never processed: $line"); }

	      # Beginning of line didn't match $type_declarator_re.
	      # Parse it looking for:
	      #  * open and close braces to keep track of scopes
	      #  * open parens, because maybe they indicate a function call
	      #  * semicolon: try over from that point

	      # See r.7.4; extern linkage specifications must be at
	      # file scope but may nest.
	      if ($line =~ /^\s*extern\s*\"\"\s*\{/)
		{ if ($symtab_scopes != 0)
		    { parse_error("extern \"C\" not at top level"); }
		  if ($in_extern_C != 0)
		    { parse_error("extern \"C\" inside extern \"C\""); }
		  $line = $POSTMATCH;
		  $in_extern_C++;
		}
	      elsif ($line =~ /^\s*extern\s*\"\"\s*$/)
		{
		  # extern "C" split over multiple lines
		  my $nextline = get_fulltoken_line($true);
		  if (defined($nextline))
		    { $line = append_lines($line, $nextline);
		      goto PROCESSLINE; }
		}
	      # elsif ($line =~ /^\s*extern\b/)
	      #  { parse_error("found extern, what's up in $line"); }

	      while ($line =~ m/[\({}\"\';]/) #'HACKCOLOR
		# Found brace, open paren, quote, comment, or semicolon
		{		# print "Found brace, open paren, quote, comment, or semicolon: $MATCH$POSTMATCH\n";
		  my $match = $MATCH;
		  $line = $POSTMATCH;
		  if ($match eq "{")
		    { enter_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq "}")
		    { if (($symtab_scopes == 0) && $in_extern_C)
			{ $in_extern_C--; }
		      else {
			# Maybe abstract this into a subroutine.
			# If we were in a function, we need to save some info.
			if ($symtab_scopes == 1 && defined($current_function)) {
			  # FIX: Here, I would really prefer the ending physical
			  # line, though elsewhere I want the first one.
			  # Need to supply both functions.
			  my $end_line = current_line_no();
			  # update our per-file list of function locations
			  push(@{$files_lines{$current_file}},
			       ($current_function_start_line,"$current_function",
				$end_line));
			  #print STDERR "FN: $current_function $current_file [$current_function_start_line,", current_line_no(), "]\n";
			  # update our per-function list of [file,startline,endline]
			  push(@{$function_to_locs{$current_function}},
			       [$current_file, $current_function_start_line,
				current_line_no() ] );
			}
			# This comes after the code above because it
			# undefines $current_function.
			exit_scope();
		      }
		      goto PROCESSLINE; }
		  elsif ($match eq ";")
		    { goto PROCESSLINE; }
		  elsif ($match eq "(")
		    { if ($PREMATCH =~ /($identifier_re)\s*$/o)
			{ if (defined($macros{$1}))
			    { # found something that looks like a macro call
			      # process it
			    }
			  else
			    { # found something that looks like a macro call
			      # process it
			    }
			}
		      else
			{ # This paren doesn't represent a function call;
			  # look for another brace, open paren, quote, comment
			}
		    }
		  elsif ($match eq "\"")
		    { if ($line =~ /$non_escaped_double_quote_re/o)
			{ $line = $POSTMATCH; }
		      else
			{ parse_error("Didn't find end of string literal '$line' after '$PREMATCH' in '$current_raw_fulltoken_line'");
			  $line = ""; # fall through
			} }
		  elsif ($match eq "'")
		    { if ($line =~ /^$char_literal_contents_re\'/o)
			{ $line = $POSTMATCH; }
		      else
			{ parse_error("Didn't find end of character literal $line.\n");
			  $line = ""; # fall through
			} }
		  else
		    { mdie("What match '$match' '$line'?"); } }
	    }
	  # done with this line; get another
	}
      if ($in_extern_C != 0)
	{ parse_error("In extern C at end of file.");
	  $in_extern_C = 0; }

      # done with this file; read another
      check_file_boundary();
      # print "closing file $current_file\n";
      close(INPUT);
    }
}


# This should perhaps do more:  substitute for macros with only one definition,
# or those that expand to either nothing or a keyword like const, etc.
sub simple_macro_substitute ($)
{ my ($text) = check_args(1, @_);

  my $fdmacro;
  # Using "for" instead of foreach gives me 'Use of "" without parens is ambiguous'!
  foreach $fdmacro (keys %fun_decl_arg_macros)
    { if ($text =~ /\b$fdmacro\s*\(/)	# no /o here, as $fdmacro varies
	{ my $prematch = $PREMATCH;
	  my $postmatch = $POSTMATCH;
	  my $close_paren_pos;
	  ($close_paren_pos, $postmatch) = find_close_paren($postmatch, 0, $true);
	  # print "close paren at $close_paren_pos in $postmatch\n";
	  my $result = $prematch . substr($postmatch, 0, $close_paren_pos)
	    . substr($postmatch, $close_paren_pos+1);
	  # print "simple_macro_substitute $text\n ===> $result\n";
	  return $result; } }
  return $text;
}


# Returns the remaining line to reprocess.  (Is that enough?)
sub process_function_definition_or_declaration ($$$)
{
  my ($type, $identifier, $remaining) = check_args(3, @_);
  # print "process_fun_def_or_decl $type $identifier (", exists($macros{$identifier}), ") $remaining\n";

  # found (start of) function definition or prototype
  # Only need to check the new stuff, not the whole thing.

  my $success;
  # Should this really be find_matching_paren?  Probably...
  # Also stop at brace.
  ($success, $remaining) = get_fulltoken_lines_to('\)', $remaining, 5);
  if (!$success)
    { parse_error("Didn't find close paren in $remaining");
      return ""; }
  # print "found function $identifier; remaining $remaining\n";
  # Process the args:  create the scope, eat the following open brace, etc.
  # $remaining includes everything after the original open paren.
  # Three possibilities:
  #   function declaration (K&R or ANSI)
  #   K&R-style function definition
  #   ANSI-style function definition
  my @arg_decls;
  { my $success;
    ($success, $remaining, @arg_decls) = parse_function_decl_args($remaining);
    # print "parse_function_decl_args => ", join(', ', @arg_decls), "; remaining = $remaining\n";
    if (!defined($remaining))
      { mdie("parse_function_decl_args result 2 undefined ", $#arg_decls+1, "args => @arg_decls"); }
    # Do something here before returning?
    if (!$success)
      # What is getting returned?  The whole original thing?
      { return $remaining; } }
  # $remaining is what follows the close paren
  if ($remaining !~ /[;\{=]/)
    { # print "no semi or brace, so appending a line to $remaining\n";
      parse_error("Shouldn't have to read more lines in process_fun_def_or_decl: $remaining");
      return ""; }

  # @arg_{names,types} will be set from arg_decls when we know whether this
  # was a def or decl.  They're used only to enter information in the
  # symbol table and are not returned.
  my @arg_names;
  my @arg_types;
  # $remaining is nonempty; if first character is
  # semicolon or comma, then this is a declaration, else a definition
  if ($remaining =~ /^\s*[;,]/)
    {				# declaration
      # gzip-1.2.4/sample/sub.c line 51 puts a prototype in scope 1.
      if ($symtab_scopes != 0)
	{ # Print to EVIL, maybe.
	  # print "Function definition or prototype $MATCH at bracedepth $symtab_scopes.\n";
	}

      # FIX: enter this in the global symbol table.  (Defer?)
      # set @arg_{names,types}; arg_decls is a list of
      # strings, each a type or a type declarator
      { my $i;
	for $i (0..$#arg_decls)
	  { my $decl = $arg_decls[$i];
	    if ($decl =~ /^$type_re_special$/)
	      { # Like $type_re, but this must precede $type_declarator_re
		# and $type_re must follow it.
		$arg_types[$i] = parse_type($decl);
		# leave $arg_names[$i] undefined
	      }
	    elsif ($decl =~ /^$type_declarator_re$/)
	      { my $type_specifier = $1;
		my $declarator = $2;
		($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
	    elsif ($decl =~ /^$type_declarator_re\s*\(/)
	      { my $type_specifier = $1;
		my $declarator = $2;
		my $args = '(' . $POSTMATCH;
		# FIX: HACK! Need parse_declarator_function, maybe, or just
		# make parse_declarator able to cope.
		($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator);
		$arg_types[$i] .= '(' . $args; }
	    elsif ($decl =~ /^$type_re$/)
	      { $arg_types[$i] = parse_type($decl);
		# leave $arg_names[$i] undefined
	      }
	    elsif ($decl =~ /^\.\.\.$/)
	      { $arg_types[$i] = $decl;
		$arg_names[$i] = "UNNAMED_REST_ARG"; }
	    else
	      { # We add to @arg_decls only things parsed as one of the above.
		parse_error("Can't parse as type or type declarator: '$decl'\n  special = $type_re_special");
		$arg_types[$i] = $typeINT;
		$arg_names[$i] = "Couldn't parse";
	      } } }
      if ($remaining =~ /^\s*;/)
	{ $remaining = $POSTMATCH; }
      elsif ($remaining =~ /^\s*,/)
	{ $remaining = $type . " " . $POSTMATCH; }
      else
	{ mdie("Couldn't find semicolon or comma I just found in $remaining"); }
    }
  # function definition
  elsif (defined($current_function))
    { parse_error("Function definition for $identifier in function $current_function starting at line $current_function_start_line");
      # Now just return $remaining and hope for the best.
    }
  else
    {
      # print "found function definition $identifier; remaining $remaining\n";

      # exit_scope makes these undefined.
      # $current_function_start_line may get set earlier, if we see a split
      # declaration/definition (that's a bit gross).
      # Perhaps check that it is already set.

      $current_function = $identifier;
      # FIX: Why subtract 1 here?  Is this right??
      if (!defined($current_function_start_line))
	{ $current_function_start_line = current_line_no() - 1; }
      if ($symtab_scopes != 0)
	{ parse_error("Function definition at bracedepth $symtab_scopes.\n");
	  # Is this the right thing to do?
	  return $remaining;
	}
      elsif ($remaining =~ /^\s*\{/)
	{			# ANSI-style definition
	  $remaining = $POSTMATCH;

	  # print "ANSI-style function definition for $identifier: ", scalar(@arg_decls), " args", (@arg_decls > 0 ? ": @arg_decls" : ""), "\n";

	  # set @arg_{names,types}; arg_decls is a list of identifiers
	  { my $i;
	    for $i (0..$#arg_decls)
	      { my $decl = $arg_decls[$i];
		if ($decl =~ /^$identifier_re$/)
		  { $arg_names[$i] = $decl;
		    # Is this at all the right thing to do???
		    # Leave $arg_types[$i] undefined; will be filled in later.
		  }
		elsif ($decl =~ /^$type_declarator_re$/)
		  { my $type_specifier = $1;
		    my $declarator = $2;
		    ($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
		# A function, with arguments
		elsif ($decl =~ /^$type_declarator_arglist_re$/)
		  { my $type_specifier = $1;
		    my $declarator = $2;
		    my $arglist = $3;
		    my ($type, $name) = parse_declarator($type_specifier, $declarator);
		    $arg_types[$i] = $type . $arglist;
		    $arg_names[$i] = $name;
		  }
		elsif ($decl eq "...")
		  { if ($i != $#arg_decls)
		      { parse_error("Should only find '...' as last declarator");
			$arg_types[$i] = $typeFAIL;
			$arg_names[$i] = "early ellipsis"; }
		    # FIX.
		    # Don't do anything; arg_{names,types} will be smaller
		    # than @arg_decls, for we are ignoring the rest argument(s).
		  }
		else
		  { # FIX: BAD BAD BAD!  Need to deal with this!
		    # eg, Python-1.4/Modules/socketmodule.c:307
		    # mdie("Can't parse as identifier or type declarator: '$decl'");
		    parse_error("Can't parse as identifier or type declarator: '$decl'");
		    # Just set the argument name.
		    # Is this at all the right thing to do???
		    $arg_names[$i] = $decl;  } } }
	}
      elsif ($remaining =~ /^\s*=/)
	{ # This wasn't a function definition at all!  It was a declaration of
	  # a variable of type pointer to function (or some such).
	  # fix: this isn't the whole remaining.  Save the original argument
	  # in a different variable, so it can be referred to later.
	  parse_error("Parsed pointer to function as function: $type $identifier $remaining");
	  return $remaining;
	}
      else
	{			# K&R-style definition
	  # Must have an argument: zero arguments => parsed as ANSI-style.
	  if (!($remaining =~ /^\s*$type_declarator_re\s*([,;])/))
	    { if (($remaining =~ /^\s*($identifier_re)/)
		  && exists($macros{$1}))
		{ parse_error("Skipping macro $1 masquerading as K&R argument declarator");
		  $remaining = $POSTMATCH; }
	      else
		{ parse_error("Didn't find first type+declarator in K&R-style $remaining");
		  # Something went wrong; I have no idea what.
		}
	      # Now fall through; below looks for open brace.
	      # Or maybe find the open brace here...
	    }

	  # set @arg_{names,types}; arg_decls is a list of
	  # strings, each an identifier or a type declarator
	  { my $i;
	    for $i (0..$#arg_decls)
	      { my $decl = $arg_decls[$i];
		if ($decl !~ /^$identifier_re$/)
		  { parse_error("K&R-style function definition ('$type' '$identifier'), but non-identifier arg declarator $decl");
		    return $remaining; }
		$arg_names[$i] = $decl;
		# leave $arg_types[$i] undefined
	      } }

	  # Ought to make sure we don't see anything we really shouldn't;
	  # for instance, don't read all the way to some random open brace.
	  # Maybe only read while $remaining is empty....

	  # Only need to check the new stuff, not the whole thing.
	  my $success;
	  ($success, $remaining) = get_fulltoken_lines_to('\{', $remaining, 5);
	  if (!$success)
	    { parse_error("Didn't find open brace: $remaining");
	      return(""); }
	  my %argnametype;
	  (%argnametype, $remaining) = parse_KandR_function_arg_decls($remaining);
	  # Make sure that the argument list matches the declarators

	  if ($debug_parse_function)
	    { print "parse_KandR_function_arg_decls returned\n";
	      my $key;
	      my $value;
	      while (($key, $value) = each %argnametype)
		{ print "  $key=$value\n"; }
	      print " remaining $remaining\n"; }

	  { { my $i;
	      foreach $i (0..$#arg_names)
		{		# print "arg names: ", @arg_names, "\narg types: ", @arg_types, "\n";
		  my $thistype = $argnametype{$arg_names[$i]};
		  if (!defined($thistype))
		    { parse_error("No K&R-style declarator for $arg_names[$i]\n");
		      $thistype = $typeFAIL; }
		  $arg_types[$i] = $thistype;
		  delete $argnametype{$arg_names[$i]};
		} }
	    # argnametype should be empty now
	    { my $name;
	      for $name (keys %argnametype)
		{ parse_error("K&R-style declarator, but no argument, for $name $argnametype{$name}"); } }
	  }
	}
      # print "Done parsing function definition to open brace\n";

      # function definition: $remaining is everything after
      # the open brace, and @arg_names and @arg_types are set.
      # Two things to do:
      #  1. add function's type to the global symbol table
      #  2. enter a scope

      # 1. Add function's type to the global symbol table.  Actually, this
      # should be easy since we are at global scope now.  Perhaps have
      # separate tables for guesses and for what we know for sure.  We'll
      # have declarations for everything but macros.  Watch out that it
      # isn't already in the global symbol table (make sure it is
      # compatible if so).

      # FIX: to be done.  (Write a function to do all that, and call it for
      # declarations, too.)

      # 2. enter a scope
      enter_scope();
      { my $i;
	for $i (0..$#arg_names)
	  { my $name = $arg_names[$i];
	    my $type = $arg_types[$i];
	    # FIX: This happens at Python-1.4/Modules/socketmodule.c:228.
	    # Why isn't it getting caught as a macro masquerading as a function?
	    if (!defined($name))
	      { parse_error("Undefined arg $i name in $identifier"); }
	    if (!defined($type))
	      { parse_error("Undefined type for "
			    . (defined($name) ? "$name (arg $i)" : "arg $i")
			    . " in $identifier, using int");
		$type = $typeINT;
	      }
	    if (defined($name) && defined($type))
	      { symtab_add($name, $type); } } }

      # Done with function definition
    }

  # We just coped with a function definition or declaration.
  # Process the rest of the line (if def, this is anything
  # after the open brace).
  return $remaining;
}


# Returns the remaining string, or the empty string if failure.
# This is actually for skipping initializers.
sub skip_expression_nocommaop ($)
{
  my ($input) = check_args(1, @_);
  my ($type, $remaining);

  # print "skipping expression $input\n";

  if ($input =~ /^\s*\{/)
    { my $post_open_brace = $POSTMATCH;
      ($type, $remaining) = parse_array_initializer($post_open_brace);
      if ($debug_parse_array_init)
	{ print "parse_array_initializer('$post_open_brace') => '" . type_name($type) . "' '$remaining'\n"; }
      if ($type eq $typeFAIL)
	{ parse_error("skip_expression_nocommaop: parse_array_initializer failed, remaining = $remaining\n");
	  # just skip it -- don't use $input, which has an open that
	  # find_close_paren doesn't expect.
	  $type = $typeUNKNOWN;
	  my ($close_brace_pos, $expanded_input) = find_close_brace($post_open_brace, 0, $true);
	  $remaining = substr($expanded_input, $close_brace_pos+1);
	  if ($debug_parse_array_init)
	    { print "failed to parse array init, found close brace before $remaining\n"; }
	}
      # print "parse_array_initializer returned $type $remaining\n";
    }
  else
    { ($type, $remaining) = parse_exp_nocommaop($input, "ignore types"); }

  if (!$type)
    { parse_error("No type for initializer $remaining");
      return "";
    }
  else
    { # Don't return the empty string; that indicates failure
      if ($remaining eq "")
	{ $remaining = " "; }
      return $remaining; }
}


###########################################################################
### Symbol table
###

# FIX: Improve the representation of the symbol table
# The symbol table is two parallel arrays:
my @symtab_identifiers = ();
my @symtab_types = ();
# $scopemarker in the @identifiers array indicates a scope boundary
my $scopemarker = "scope marker";	# contains space, as no real variable can

# Perhaps have a different structure (an associative array?) for the global
# level and only use this for nested scopes.


sub show_symtab ($)
{
  my ($text) = check_args(1, @_);
  if ($#symtab_identifiers != $#symtab_types)
    { mdie("symtab_identifiers and symtab_types arrays have different lengths ($#symtab_identifiers != $#symtab_types)"); }
  print "{SYMBOL TABLE $text at line ", current_line_no(), ":\n";
  # perhaps print out in opposite direction
  { my $i;
    for ($i = $#symtab_identifiers; $i >= 0; $i--)
      { if ($symtab_identifiers[$i] eq $scopemarker)
	  { print " --------\n"; }
	else
	  { print " ", $symtab_identifiers[$i], "\t", type_name($symtab_types[$i]), "\n"; } } }
  print "}\n";
}

sub enter_scope ()
{
  check_args(0, @_);
  push(@symtab_identifiers, $scopemarker);
  push(@symtab_types, 0);
  $symtab_scopes++;
  if ($debug_scopes) { show_symtab("entered scope $symtab_scopes"); }
}

sub exit_scope ()
{
  check_args(0, @_);
  if ($debug_scopes) { show_symtab("exiting scope $symtab_scopes"); }
  if (@symtab_identifiers == 0)
    { parse_error("exit_scope: not in scope (empty symtab_identifiers array)");
      return; }
  while ($scopemarker ne pop(@symtab_identifiers))
    { pop(@symtab_types);
      if (@symtab_identifiers == 0)
	{ parse_error("exit_scope: not in scope (no scopemarker)");
	  return; } }
  pop(@symtab_types);
  # It's possible that ($#symtab_identifiers == -1), if global scope is empty.
  if ($debug_scopes) { show_symtab("exited scope $symtab_scopes"); }
  $symtab_scopes--;
  if ($symtab_scopes == 0) {
    undef $current_function;
    undef $current_function_start_line;
  }
}

# sub symtab_scopes
# {
#   check_args(0, @_);
#   my $result = 1;
#   my $id;
#   for $id (@symtab_identifiers)
#     { if ($id eq $scopemarker)
# 	{ $result++; } }
#   return $result;
# }

sub symtab_add ($$)
{
  my ($identifier, $type) = check_args(2, @_);
  push (@symtab_identifiers, $identifier);
  push (@symtab_types, $type);
}

sub symtab_lookup ($)
{
  my ($var) = check_args(1, @_);
  { my $i;
    for ($i = $#symtab_identifiers; $i >= 0; $i--)
      { if ($var eq $symtab_identifiers[$i])
	  { return $symtab_types[$i]; } } }
  return $typeFAIL;
}



###########################################################################
### Check and categorize macros
###

# Need a routine that assigns a type to a literal.
# (Useful for turning macros into const variables.)

# # FIsNumConst(string)  returns 1 iff string matches a numeric const regexp
# sub FIsNumConst {
#   my ($str) = @_;
#   check_args(1, @_);
#   if ($str =~ /^\(?-?\d+\.?\d*\)?$/ || # decimal 2.
#       $str =~ /^\(?-?\d*\.?\d+\)?$/ || # fraction .2
#       $str =~ /^0x[\d|a-f|A-F]+$/ ||   # hex
#       $str =~ /^-?\d+[ulUL]$/) {       # trailing L for long, U for unsigned
#     return 1;
#   } else {
#     return 0;
#   }
# }


# Takes macro name as argument; categorizes each of the macro's definitions
sub categorize_macro_name ($)
{ my ($name) = check_args(1, @_);
  if (defined($mntype{$name}))
    { return; }
  if (!defined($macros{$name}))
    { # We called this on a non-macro (we try for every name in a macro body).
      # Note that accessing $macros{$name}[0] ends up adding $name to the
      # hash %macros, even though the value is undefined.
      return; }
  my $numdefs = $macros{$name}[0];
  # if the assertion below gets tripped, it's likely that
  # somewhere we're mistakenly adding to %macros unintentionally
  die "numdefs not defined for $name" if !defined($numdefs);
  # Use this block instead to help debug the above problem
  #if (!defined($numdefs)) {
  #  print STDERR "numdefs not defined for $name\n";
  #  delete $macros{$name};
  #  return;
  #}

  # Fix: should also get value here.

  # Categorize each definition body.
  { my $i;
    for ($i = 1; $i <= $numdefs; $i++)
      { my $mdef_index = $macros{$name}[$i];
	if (!defined($mdef_category[$mdef_index]))
	  { categorize_macro_def($mdef_index); }
	# Type may be undefined; it's ingored for some categories.
	if (!defined($mdef_category[$mdef_index]))
	  { die "Undefined category (type $mdef_type[$mdef_index]): $i $mdef_index $mdef_name[$mdef_index] $mdef_args[$mdef_index] $mdef_body[$mdef_index] $mdef_body_noc[$mdef_index]"; } } }

  if ($debug_categorize_macro)
    { my @cat_and_type = ();
      my $i;
      for ($i = 1; $i <= $numdefs; $i++)
	{ my $mdef_index = $macros{$name}[$i];
	  my $this_type = $mdef_type[$mdef_index];
	  push(@cat_and_type,
	       $mdef_category[$mdef_index]
	       . (defined($this_type) ? "(" . type_name($this_type) . ")" : "")); }
      # No newline yet.
      print "categorize_macro_name $name: (", join("; ", @cat_and_type), ")"; }

  # Collect the categorizations
  # Fix: this isn't quite right; rather than two literal categorizations
  # resulting in another literal categorizations, they should go to "some
  # constant" unless the values are identical.
  my $type = $mdef_type[$macros{$name}[1]];
  my $category = $mdef_category[$macros{$name}[1]];
  { my $i;
    for ($i = 2; $i <= $numdefs; $i++)
      { my $mdef_index = $macros{$name}[$i];
	$category = category_lub($category, $mdef_category[$mdef_index]);
	# Type is allowed to be undefined; it's ignored for some categories.
	if ((!defined($type)) || (!defined($mdef_type[$mdef_index])))
	  { $type = undef; }
	else
	  { $type = type_lub($type, $mdef_type[$mdef_index]); } } }

  if ($debug_categorize_macro)
    { print " => $category",
          (defined($type) ? "(" . type_name($type) . ")" : ""),
          "\n"; }

  $mntype{$name} = $type;
  $mncategory{$name} = $category;
}


# Takes index into macro arrays as argument
sub categorize_macro_def ($)
{ my ($index) = check_args(1, @_);

  # print "Categorizing $index $mdef_name[$index]$mdef_args[$index] $mdef_body[$index]\n";

  if (defined($mdef_category[$index]))
    { # print "Already categorized! $mdef_category[$index] $categoryname[$mdef_category[$index]]\n";
      return; }
  # Avoid recursive call even if possible loop in macro definitions.
  $mdef_category[$index] = $catINPROCESS;

  my $body = $mdef_body_noc[$index];
  if (!defined($body))
    { die "Why isn't mdef_body_noc[$index] defined? ($mdef_body[$index])"; }
  $fDebugCommentRemoval && print STDERR "body = '$mdef_body[$index]'\nbody_noc = '$body'\n";

  # Fix: are these special cases better done in parse_expression?
  my $category;
  my $type;
  if ($body eq "")
    # Null define
    { $category = $catNULLDEFINE; }
  elsif ($body =~ /^($string_literal_re\s*)+$/)
    # String
    { # print "found string";
      $category = $catLITERAL;
      $type = $typeSTRING; }
  elsif ($body =~ /^($float_literal_whole_re|$float_literal_frac_re|float_literal_exp_re|float_literal_noexp_re)$/)
    { $category = $catLITERAL;
      $type = $typeFLOAT; }
  elsif ($body =~ /^($hex_literal_re|$dec_oct_literal_re)$/)
    { $category = $catLITERAL;
      $type = infer_int_type($body); }
  elsif ($body =~ /^$char_literal_re$/)
    { $category = $catLITERAL;
      $type = $typeCHAR; }
  # Being a statement has precedence over having a reserved word,
  # but this body is just a single word.
  elsif ($body =~ /^$reserved_nontype_word_re$/)
    { # $failure_type = "expands_to_reserved_word";
      $category = $catRESDWORD;
      # evilprint("expands to reserved word: $body\n");
    }
  elsif ( # like $type_re, but unconditional suffix
	 ($body =~ /^$type_specifier_re$type_suffix_re+$/o)
	 || ($body =~ /^($reserved_type_word_re[ \t\*\[\]]*)+$/)
	 || ($body =~ /^struct\s*$identifier_re$/))
    { $category = $catTYPE; }
  elsif (($body =~ /^$identifier_re$/)
	 && (categorize_macro_name($body) || $true) # for side effect
	 && (defined($mncategory{$body})))
    { $category = $mncategory{$body};
      $type = $mntype{$body}; }
  elsif ($body =~ /\b\Q$mdef_name[$index]\E\b/)
    { $category = $catRECURSIVE; }
  elsif (($body =~ /,\s*$builtin_type_re\s*[,\)]/o)
	 || ($body =~ /\(\s*$builtin_type_re\s*(,|\)$)/o)
	 || ($body =~ /,\s*($type_re\s*$type_suffix_re+)\s*[,\)]/o) # ends with *: pointer
	 || ($body =~ /\(\s*($type_re\s*$type_suffix_re+)\s*(,|\)$)/o)
	 || ($body =~ /,\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*[,\)]/o) # identifier ending with _t
	 || ($body =~ /\(\s*([a-zA-Z_\$][a-zA-Z0-9_\$]*_t)\s*(,|\)$)/o))
    { $category = $catUSESTYPEARG; }
  else
    { my $remaining;
      reset_parse_vars();
      ($type, $remaining) = parse_expression($body);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*$/))
	# Expression
	# Fix: I'm not sure how correct any of this is.
	{ if ($type =~ /^category: /)
	    # Not an expression after all.
	    { $category = $POSTMATCH; }
	  elsif ($body =~ /^$constant_exp_re$/)
	    # This is wrong; it considers (1 << ((x)-1))
	    # constant because that matches $constant_exp_re.
	    { $category = $catSOMECONSTANT; }
	  elsif ($parse_exp_saw_equals)
	    { $category = $catEXPASSIGN; }
	  else
	    { $category = $catEXP; }
	  # print "category = $categoryname[$category]; found expression $body\n";
	  # Check whether a macro argument was used as a type.
	  { my $arg;
	    foreach $arg (split(/[\(, \t\)]+/, $mdef_args[$index]))
	      { delete $parsevars{$arg};
		if (defined($parsetypes{$arg}))
		  { $category = $catHASTYPEARG;
		    goto CATEGORIZED; }
		delete $parsefuns{$arg}; } }
	  # print "category postargs = $category\n";
	  # Assume the functions and types are well-defined if not macros
	  # If they are macros, should check 'em, not just fail.
	  { my $fun;
	    foreach $fun (keys %parsefuns)
	      { if (defined $macros{$fun})
		  # This is actually fine most of the time; fix later.
		  { $category = $catMACROFUN;
		    goto CATEGORIZED; } } }
	  # print "category postfun = $category\n";
	  { my $type;
	    foreach $type (keys %parsetypes)
	      { if (defined($macros{$type}))
		  # This may be fine; fix later.
		  { $category = $catMACROTYPE;
		    parse_error("Macro as type: $type");
		    goto CATEGORIZED; } } }
	  # print "category posttype = $category\n";
	  # For each free variable, check its type.
	  { my $var;
	    foreach $var (keys %mdef_freevars)
	      { # print "examining free var $var ($mdef_name[$index])\n";
		if (defined($macros{$var}))
		  { my $varclass;
		    my $i;
		    foreach $i ($macros{$var})
		      { if ($mdef_category[$i] == $catNOTYET)
			  { categorize_macro_def($i); }
			if (!defined($varclass))
			  { $varclass = $mdef_category[$i]; }
			elsif ((($mdef_category[$i] == $catLITERAL)
				|| ($mdef_category[$i] == $catCONSTANT)
				|| ($mdef_category[$i] == $catSOMECONSTANT))
			       && (($varclass == $catLITERAL)
				   || ($varclass == $catCONSTANT)
				   || ($varclass == $catSOMECONSTANT)))
			  { $varclass = $catSOMECONSTANT; }
			elsif ($varclass != $mdef_category[$i])
			  { $category = $catFAILURE;
			    goto CATEGORIZED; }
			else
			  # fix: not sure what would get us here.
			  # (Never saw this error message yet...)
			  { mdie("Huh?"); } }
		    if (!(($varclass == $catLITERAL)
			  || ($varclass == $catCONSTANT)
			  || ($varclass == $catSOMECONSTANT)))
		      # Is this right?
		      { $category = $catFAILURE; # should be more specific here
			goto CATEGORIZED; } }
		else
		  # This is a free variable.  Should check whether it is a global
		  # (which would be OK; a local would be bad).
		  { $category = $catEXPFREE; # should be more specific here
		    goto CATEGORIZED; }
	      } }
	  # Don't set category here; it was defaulted to $catEXP above.
	  # print "category postfree = $category\n";
	}
      elsif ($type && ($remaining =~ /^\s*;\s*$/))
	{
	  $category = $catSTATEMENT;
	}
      # Perhaps check against type_re here; but that should have already
      # been caught, right?  And here the check would catch far too much.
      else
	# Should do some evilness processing here, to justify the failed
	# categorization.
	{ # Not an expression, apparently
	  $category = $catFAILURE;
	  $type = "";
	  my ($evil_flags,$failure_type,$extended_category) = check_macro_body($body);
	  $category = harder_category($category,$extended_category);
	}
    }

CATEGORIZED:
  $mdef_category[$index] = $category;
  $mdef_type[$index] = $type;
  # track our histogram of categories
  update_categories_for($category);

  if ($debug_categorize_macro)
    { print "categorize_macro_def ($index): $categoryname[$category]",
          (defined($type) ? "(" . type_name($type) . ")" : ""),
          ": $body\n"; }
}


# Return true for a macro that takes a single arg and either returns it or
# returns only open and close parens, which can be used to construct either
# a K&R or ANSI function declaration by passing in a parenthesized list as
# the argument.
sub is_fun_decl_arg_macro ($)
{ my ($identifier) = check_args(1, @_);

#  print STDERR "is_fun_decl_arg_macro: $identifier $macros{$identifier}[0] ", join(', ',(map {$mdef_args[$macros{$identifier}[$_]]} (1..$macros{$identifier}[0]))), "\n";

  # don't require only 2 definitions-- require > 1 and
  # check that all definitions
  # return either the single arg or "()"
  # __P in /usr/include/{sys/cdefs,ctype}.h is defined 5 times

  die "is_fun_decl_arg_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use @m_i = @{$macros{$identifier}}, to reduce repetitivity
  my $cMacroDefs = $macros{$identifier}[0];

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_just_parens = $false;
  my $one_expanded_to_itself = $false;

  { my $i;
    foreach $i (1..$cMacroDefs) {
      if (count_macro_args($mdef_args[$macros{$identifier}[$i]]) != 1) {
	#      print STDERR "=> false1 at $i\n";
	return $false;
      }
      my $args = $mdef_args[$macros{$identifier}[$i]];
      my $body = $mdef_body_noc[$macros{$identifier}[$i]];

      my $expands_to_just_parens = $false;
      my $expands_to_itself = $false;
      # Can't be $body ne "()" because there might be space between the parens.
      if ($body =~ /^\(\s*\)$/) {
	$expands_to_just_parens = $true;
	$one_expanded_to_just_parens = $true;
      } elsif (($body =~ /^$identifier_re$/)
	       && ($args =~ /^\(\s*\Q$body\E\s*\)$/)) {
	$expands_to_itself = $true;
	$one_expanded_to_itself = $true;
      }

      #    if ($body !~ /\(\s*\)/ && $args !~ /^\(\s*\Q$body\E\s*\)$/ ) {
      if (!$expands_to_just_parens && !$expands_to_itself) {
	#      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
	return $false;
      }

    }
  }
#  print STDERR "=> true\n";

  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_itself && $one_expanded_to_just_parens) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}

# Return true for a macro that takes a single arg and either returns it or
# returns only an open paren.  See bc-1.03/dc.h line 35.
sub is_semi_fun_decl_arg_macro ($)
{ my ($identifier) = check_args(1, @_);

#  print STDERR "is_fun_decl_arg_macro: $identifier $macros{$identifier}[0] ", join(', ',(map {$mdef_args[$macros{$identifier}[$_]]} (1..$macros{$identifier}[0]))), "\n";

  # don't require only 2 definitions-- require > 1 and
  # check that all definitions
  # return either the single arg or "()"
  # __P in /usr/include/{sys/cdefs,ctype}.h is defined 5 times

  die "is_fun_decl_arg_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use @m_i = @{$macros{$identifier}}
  my $cMacroDefs = $macros{$identifier}[0];

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_just_paren = $false;
  my $one_expanded_to_itself = $false;

  { my $i;
    foreach $i (1..$macros{$identifier}[0]) {
      if (count_macro_args($mdef_args[$macros{$identifier}[$i]]) != 1) {
#      print STDERR "=> false1 at $i\n";
	return $false;
      }
      my $args = $mdef_args[$macros{$identifier}[$i]];
      my $body = $mdef_body_noc[$macros{$identifier}[$i]];

      my $expands_to_just_paren = $false;
      my $expands_to_itself = $false;
      # Perhaps this test is overly strict.
      if ($body eq "\(") {
	$expands_to_just_paren = $true;
	$one_expanded_to_just_paren = $true;
      } elsif ($args =~ /^\(\s*\Q$body\E\s*\)$/) {
	$expands_to_itself = $true;
	$one_expanded_to_itself = $true;
      }

#    if ($body !~ /\(\s*\)/ && $args !~ /^\(\s*\Q$body\E\s*\)$/ ) {
      if (!$expands_to_just_paren && !$expands_to_itself) {
#      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
	return $false;
      }

    }
  }
#  print STDERR "=> true\n";

  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_itself && $one_expanded_to_just_paren) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}


# Return true for a non-function macro that expands to either nothing or "void".
sub is_void_macro ($)
{ my ($identifier) = check_args(1, @_);

  die "is_void_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use @m_i = @{$macros{$identifier}}
  my $cMacroDefs = $macros{$identifier}[0];

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_empty = $false;
  my $one_expanded_to_void = $false;

  { my $i;
    foreach $i (1..$macros{$identifier}[0]) {
      my $args = $mdef_args[$macros{$identifier}[$i]];
      my $body = $mdef_body_noc[$macros{$identifier}[$i]];

      if ($args ne "") {
	#      print STDERR "=> false1 at $i\n";
	return $false;
      }

      my $expands_to_empty = $false;
      my $expands_to_void = $false;
      if ($body eq "") {
	$expands_to_empty = $true;
	$one_expanded_to_empty = $true;
      } elsif ($body eq "void") {
	$expands_to_void = $true;
	$one_expanded_to_void = $true;
      }

      if (!$expands_to_empty && !$expands_to_void) {
#      print STDERR "=> false2 at $i: \"$body\",\"$args\"\n";
	return $false;
      }

    }
  }
#  print STDERR "=> true\n";

  # Actually, this isn't necessary here.
  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_empty && $one_expanded_to_void) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}


# Report "evil" CPP macros:
#  Illegal macros:
#   Unterminated string
#   Wrong length character constant
#   Unterminated character constant
#   Pasting via comments (syntactically legal, but no pasting occurs in ISO C)
#  Potentially dangerous macros:
#   Unbalanced parens, braces, and brackets
#   Pasting via ##
#   Stringization via #
#   Arguments but no body
#  Turned off testing for:
#   Empty string


# Perhaps pass in macro name, for better error messages.

# We have to redo a lot of parsing, because we didn't parse the body of a
# macro normally.  (Did we?  Can some of this be omitted?)

# This should return an evil categorization (or categorizations?) as well.

# returns zero if it was ok
# otherwise $EVIL $DANGER $OBSOLETE $ILLEGAL
# (each individual bits)

#FIX:  evilprint is used, and that uses $current_file, current_line_no()
# but these are not correct when we're in our categorization loop.
# we need to fix this to print the correct file/line# information for
# the macro we're checking.  Presumably, this means we must pass it in,
# or modify the globals for the current macro when we're in the classification
# phase.

# This is called only if parsing the body as an expession and other
# simple tests already failed.
sub check_macro_body ($) {
  my ($body) = check_args(1, @_);
  if (!wantarray)
    { my ($file, $line, $sub) = (caller(0))[1,2,3];
      die "check_macro_body called not wanting an array at $file:$line $sub";
    }

  my $result = 0;
  # print "check_macro_body: $body\n";
  my @nesting = ();

  # FIX: should I concatenate failure_type-s so we see multiple failures?
  # this would mean it'd be tricky to keep the table the same across files
  my $failure_type = "unknown";
  my $category = $catFAILURE;
  my $full_body = $body;

  if ($body =~ /^return\b\s*/)
    { my ($type, $remaining) = parse_expression($POSTMATCH);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*$/))
	{ $category = $catSTATEMENT;
	  $failure_type = "semicolonless return";
	  return ($result,$failure_type,$category); } }
  if ($body =~ /^(if|while)\s*\(/)
    { # Don't try to parse the open paren, as it might look like a cast.
      my ($type, $remaining) = parse_expression($POSTMATCH);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*\)/))
	{ $remaining = $POSTMATCH;
	  if ($remaining !~ /\s*\{/)
	    { if ($remaining =~ /^\s*(return|goto)\b\s*/)
		# "goto" was a hack
		{ $remaining = $POSTMATCH; }
	      ($type, $remaining) = parse_expression($remaining);
	      # print "2nd type = $type; remaining = $remaining\n";
	      if ($type && ($remaining =~ /^\s*$/))
		{ $category = $catSTATEMENT;
		  $failure_type = "semicolonless, braceless if";
		  return ($result,$failure_type,$category); } } } }
  if ($body =~ /^goto\s*$identifier_re$/)
    { $category = $catSTATEMENT;
      $failure_type = "semicolonless goto";
      return ($result,$failure_type,$category); }

  #print "BODY: $body\n";
  # Used to include '$reserved_word_re'
  while ($body =~ m%[\]\[(){}\"\'\#]|//|/\*|\*/|(__)?asm(__)?|;%o) #'HACKCOLOR
    # Found paren, quote, cpp directive, or comment
    { my $match = $MATCH;
      $body = $POSTMATCH;
      if ($debug_categorize_macro) { print "check_macro_body matched '$match' before $body\n" }
      if ($match =~ /[\[\(\{]/)
        { push(@nesting,$match);
	  # print STDERR "FRONTMATCH\n";
	}
      elsif ($match =~ /;/)
	{
	  #FIXMERNST: what about "," operator?
	  $failure_type = "expands_to_statement";
	  $category = harder_category($category,$catSTATEMENT);
	  # evilprint("expands to statement: $full_body\n");
	}
      elsif ($match =~ /^(__)?asm(__)?$/)
	{ $failure_type = "assembly_code";
	  $category = harder_category($category,$catASM);
	}
      #  elsif ($match =~ /^$reserved_type_word_re$/o)
      #  {
      #    $failure_type = "expands_to_type";
      #    $category = harder_category($category,$catTYPE);
      #    # evilprint("expands to type '$MATCH': $full_body\n");
      #  }
      #  elsif ($match =~ /^$reserved_nontype_word_re$/o)
      #  {
      #    $failure_type = "expands_to_reserved_word";
      #    $category = harder_category($category,$catRESDWORD);
      #    # evilprint("expands to reserved word '$MATCH': $full_body\n");
      #  }
      elsif ($match =~ /[\]\)\}]/)
	{ if ($#nesting == -1)
	    { $result |= $DANGER;
	      $failure_type = "close_but_no_open";
	      $category = harder_category($category,$catMISMATCH);
	      evilprint("dangerous: close $match without open\n    $full_body\n"); }
	  else
	    { my $popped = pop(@nesting);
	      # print STDERR "ENDMATCH\n";
	      if ((($match eq "\]") && ($popped ne "\["))
		  || (($match eq "\)") && ($popped ne "\("))
		  || (($match eq "\}") && ($popped ne "\{")))
		{ $result |= $DANGER;
		  $failure_type = "mismatched_entities";
		  $category = harder_category($category,$catMISMATCH);
		  evilprint("dangerous: $popped matched by $match:\n    $full_body\n"); } } }
      elsif ($match eq "\"")
        { if ($body =~ m/$non_escaped_double_quote_re/o)
            # Empty string OK only if that is the entire body.
            { if ($false	# turn off the test for now
		  && ((length($PREMATCH) + length($1) + length($2)) == 0)
		  && (length($body) > 2))
                { $result |= $DANGER;
		  $failure_type = "empty_string";
		  evilprint("dangerous: empty string:\n    $full_body\n"); }
              $body = $POSTMATCH; }
          else
           { $result |= $ILLEGAL;
	     $failure_type = "unterminated_string";
	     evilprint("illegal: unterminated string $MATCH:\n    $full_body\n"); } }
      elsif ($match eq "\'")
        { if (($body =~ m/^\\''/) || ($body =~ m/\'/))
	    { # do this first because we're going to do more matching
	      $body = $POSTMATCH;
	      my $char = $PREMATCH . $MATCH;
              chop($char);	# remove trailing '
	      # Perhaps don't bother with this test; get_fulltoken_line already checked
	      # for illegal character constants.
	      if ($char !~ m/^$char_literal_contents_re$/o)
	        { $result |= $ILLEGAL;
		  $failure_type = "bad_char_constant";
		  evilprint("illegal: bad character constant $char:\n    $full_body\n"); }
    	       }
          else
            { $result |= $ILLEGAL;
	      $failure_type = "unterminated_char_constant";
	      evilprint("illegal: unterminated character constant $MATCH:\n    $full_body\n");
              $body = ""; } }
      elsif ($match eq "#")
	{ if (substr($POSTMATCH, 0, 1) eq "#")
	    { $result |= $DANGER;
	      $failure_type = "token_pasting";
	      $category =  harder_category($category,$catPASTING);
	      evilprint("dangerous: ## pasting:\n    $full_body\n");
	      $body = substr($body, 1); }
	  # This list from GNU C preprocessor manual
	  # It's not complete, since #assert introduces new preprocessor commands.
	  elsif ($POSTMATCH =~ m/(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|system|unassert|warning)\b/)
	    { $result |= $DANGER;
	      $failure_type = "preprocessor_directive";
	      evilprint("dangerous: preprocessor directive #$MATCH:\n    $full_body\n"); }
	  else
	    { $result |= $DANGER;
	      $failure_type = "stringization";
	      $category =  harder_category($category,$catSTRINGIZE);
	      evilprint("dangerous: stringization:\n    $full_body\n"); } }
      elsif ($match eq "/*")
	# This test probably fails for a/**//**/b.  Oh, well.
        { my $postmatch = $POSTMATCH;
	  my $precedingabuts = ($PREMATCH =~ m/\w$/);
	  while (not ($postmatch =~ m!\*/!))
	    { my $nextline;
	      if ($nextline = get_fulltoken_line($true))
		# Get some more text, and look for the comment close there.
		{ $body = append_lines($body, $nextline);
		  $postmatch = append_lines($POSTMATCH, $nextline);
		}
	      else
		{ $result |= $EVIL;
		  $failure_type = "unterminated_comment";
		  evilprint("evil: unterminated comment:\n    $full_body\n");
		  $body = "";
		  $postmatch = ""; } }
	  # print "Setting $body to $POSTMATCH; $PREMATCH; $MATCH.\n";
	  # Redo this because the one in the while test is considered
	  #   in the block, so we lost the (localized) match data.
	  $postmatch =~ m/\*\//;
	  $body = $POSTMATCH;
	  if ($precedingabuts && ($body =~ m/^\w/))
	    { $result |= $OBSOLETE;
	      $failure_type = "old_style_token_pasting";
	      $category =  harder_category($category,$catPASTING);
	      evilprint("obsoleted: comment pasting:\n    $full_body\n"); } }
      elsif ($match eq "//")
        { # print "$current_file:", current_line_no(), ": evil: //-style comment:\n    $full_body\n";
          $body = ""; }
      elsif ($match eq "*/")
	# $body doesn't give me the whole thing; why?  ($body only contains
	#   what follows the match at this point.)
        { $result |= $EVIL;
	  $failure_type = "unexpected_end_comment";
	  evilprint("evil: comment terminator */ not in comment:\n    $full_body\n"); }
      else
        { mdie("$current_file:", current_line_no(), ": ???: match = $match before '$body' in $full_body"); }
        }
  if ($#nesting != -1)
    { $result |= $EVIL;
      $failure_type = "no_match";
      $category = harder_category($category,$catMISMATCH);
      evilprint("evil: no match for ", @nesting, ":\n    $full_body\n"); }
  if (($failure_type eq "unknown") && ($full_body =~ /^[\(\);, .\*\?]*$/))
    { # Not harder_category, lest ";" be called "statement".
      # $category = harder_category($category,$catSYNTAX);
      $category = $catSYNTAX;
      $failure_type = "expansion_into_syntax";
    }
  # I moved this into the body (was that the right thing), so this
  # oughtn't have any effect.
  if (($failure_type eq "unknown") && ($full_body =~ /__asm__/))
    { $category = harder_category($category,$catASM);
      $failure_type = "assembly_code";
    }

  #   if ($failure_type eq "unknown") {
  #     evilprint("unknown failed categorization:\n    $full_body\n");
  #   }
  return ($result,$failure_type,$category);
}

# just max of its two arguments
sub harder_category ($$) {
  my ($cat1, $cat2) = check_args(2,@_);
  if ($cat1 > $cat2) {
    return $cat1;
  } else {
    return $cat2;
  }
}


###########################################################################
### Miscellaneous
###

# Like die, but with file and line number prefix.  Do NOT redefine this so
# that it doesn't die -- this is for dying.  If you don't want to die, call
# something that doesn't necessarily die, like parse_error.  Do not use
# regular die; this should have all the same functionality and more.

# just return the current file and line number as a string
sub input_file_and_line ()
{
  check_args(0, @_);
  return "$current_file:" . current_line_no();
}

# This only adds input_file_and_line; is it now gratuitous?
sub mdie ($@) {
  my (@msg) = check_args_at_least(1, @_);
  # Could use croak instead.
  my ($file,$line) = (caller)[1,2];
  print STDERR "$file:$line ",
      # (defined($current_function) ? "function $current_function " : ""),
      "on ", input_file_and_line(), ": ", @msg, "\n";
  exit -1;
}

# Perhaps make this die/mdie when debugging.
sub parse_error ($@)
{
  my (@msg) = check_args_at_least(1, @_);
  my ($file,$line) = (caller)[1,2];
  my $message = "$file:$line on " . input_file_and_line() . ": @msg\n";
  $message =~ s/\n+\n$/\n/;
  if ($opt_p) { print STDERR $message; }
  print PARSE_ERRS $message;
  return;
}


# Print a message to the EVIL stream, with file and line number prefix
sub evilprint ($@) {
  my (@msg) = check_args_at_least(1, @_);
  print EVIL input_file_and_line(), ": ", @msg;
  return;
}

# Return the current line number -- hopefully we can just compute
# this off of $. and @getline_ungot_raw_lines
# ***** fix: This isn't right -- each line in getline_ungot_raw_lines can
# represent multiple physical lines.
sub current_line_no () {
  check_args(0, @_);
  if (!$categorizing_macros) {
    return ($. - $#getline_ungot_raw_lines - 1);
  } else {
    return $current_macro_line_number;
  }
}


sub forbidden_file ($)
{ my ($filename) = check_args(1, @_);
  # bash/machines.h is for use by the makefile, not C code
  # /usr/include/linux/linkage.h is assembly, not C code
  # glibc/asm-syntax.h and glibc/sysdep.h are assembly, not C code
  # print "Checking '$filename'\n";
  return ((($opt_d =~ /bash/) && ($filename eq "./machines.h"))
	  || ($filename eq "/usr/include/linux/linkage.h")
	  || (($opt_d =~ /glibc/) && (($filename =~ /\/asm-syntax\.h$/)
				      || ($filename =~ /\/sysdep\.h$/))));
}


# Return the index into the @ftype_ arrays for the current filename.
# Consider how it was included, and whether it's a header or code.
sub compute_ftype_index ($) {
  my ($filename) = check_args(1, @_);

  my $offset = file_is_header($filename) ? $ftype_HEADER_Start : $ftype_NONHEADER_Start;

  die "compute_ftype_index can't determine an index for an inclusion method"
    if !exists $InclusionMethod_to_Index{$file_inclusion_method{$filename}};

  return $offset + $InclusionMethod_to_Index{$file_inclusion_method{$filename}};
}


# Tell us if the current file was added by a #include directive
# (as opposed to passed in to evilmacros on the cmd line or in STDIN w/ -i )
sub file_was_included ($) {
  my ($filename) = check_args(1, @_);
  if ($file_inclusion_method{$filename} =~ /^FromInclude/) { return $true; }
  return $false;
}

# Tell if the current filename looks like a header file
sub file_is_header ($) {
  my ($filename) = check_args(1, @_);
  if ($current_file =~ /.[hH].?.?$/) { return $true; }
  return $false;
}

# Return the number of arguments, given a macro argument
# declaration.  Just counts number of commas, and adds 1,
# or zero if we were passed "".
sub count_macro_args ($) {
  my ($arg_decl) = check_args(1, @_);
  my $retval;

  if ($arg_decl eq "") {
    $retval = 0;
  } else {
    # count the number of commas, by substituting commas for themselves
    # (tr returns the number of deletions or substitutions)
    $retval = ($arg_decl =~ tr/,/,/d) + 1;
  }
  #print STDERR "count_macro_args: $retval for $arg_decl\n";
  return $retval;
}


# Initialize the lists of hashes
# for each filetype.
# This is done so that the outputs across all files
# has the same columns, and none missing
sub initialize_lists_of_hashes () {
  check_args(0, @_);
  my $i;
  my $j;
  foreach $i (0..$c_ftype-1) {
    foreach $j (keys %cppcmdcount) {
# FIX: gjb thinks these are same
#      $rg_cppcmdcounts[$i]->{$j} = 0;
      $ {$rg_cppcmdcounts[$i]}{$j} = 0;
    }
    foreach $j (@categoryname) {
      $ {$rg_category_counts[$i]}{$j} = 0;
    }
  }
}


# GJBFIX: Put these in the correct lists; each should only appear once, probably.

# Initialize the macros structures for the builtin macros of gcc
# FIX: Should generalize so that it works for non-gcc compilers
# This list is not necessarily comprehensive even for gcc
# I got it with:
# uni,p1:~/macros% strings /usr/lib/gcc-lib/i486-linux/2.7.2/cpp | more
# and looked for "__"
sub initialize_builtin_macros () {
  check_args(0, @_);
  # The standard defines __LINE__ __STDC__ __STDC_VERSION__ __FILE__ __DATE__
  # __TIME__.  __STDC__ is undefined or has a nonzero value.
  # __STDC_VERSION__ is 199409L if implementation complies with Amendment 1.

  # FIX: split this into the "standard" builtins, and the gcc builtins
  # FIX: the blank lines in the qw() constructs below separate the two types
  my @num_def_macros = (
    qw(__LINE__ __STDC_VERSION__

       __BASE_FILE__ __IMMEDIATE_PREFIX__ __INCLUDE_LEVEL__ __OBJC__
       __PTRDIFF_TYPE__ __REGISTER_PREFIX__ __SIZE_TYPE__
       __USER_LABEL_PREFIX__ __VERSION__ __WCHAR_TYPE__ ) );

  my @string_def_macros = (
    qw(__DATE__ __FILE__ __TIME__

       __BASE_FILE__ __VERSION__ __SIZE_TYPE__ __PTRDIFF_TYPE__
       __WCHAR_TYPE__ __DATE__ ) );

  my @empty_def_macros = ( qw(__STDC__

			      __OBJC__ ) );

  my $mac;
  foreach $mac ((@empty_def_macros,@string_def_macros,@num_def_macros)) {
    $macros{$mac} = [0];
    $macros_uses{$mac} = [0,0,0];
    $macros_c_undefs{$mac} = 0;
    $macros_used_in_functions{$mac} = [];
    $macros_file_line_uses{$mac} = [];
  }

  foreach $mac (@empty_def_macros) {
    $macros{$mac} = [1,$cBuiltinMacros];
    $mdef_name[$cBuiltinMacros] = $mac;
    $mdef_args[$cBuiltinMacros] = "";
    $mdef_body[$cBuiltinMacros] = " /* Fake built-in null define */";
    $mdef_body_noc[$cBuiltinMacros] = "";
    $mdef_file[$cBuiltinMacros] = $built_in_fake_file;
    $mdef_line[$cBuiltinMacros] = 0;
    $mdef_physical_lines[$cBuiltinMacros] = 0;
    $mdef_category[$cBuiltinMacros] = 0;
    $mncategory{$mac} = $catNULLDEFINE;

# FIX: initialize all the mdef_XXX arrays, here and below cases
#    $mdef_physical_ncnb_lines[$cBuiltinMacros] = 0;
#    $mdef_physical_dependenton[$cBuiltinMacros] = 0;
#    $mdef_physical_expansion_uses[$cBuiltinMacros] = 0;
#    $mdef_physical_type[$cBuiltinMacros] = 0;
#    $mdef_physical_category[$cBuiltinMacros] = 0;
#    $mdef_physical_evilness[$cBuiltinMacros] = 0;

    $cBuiltinMacros++;
  }

  foreach $mac (@string_def_macros) {
    $macros{$mac} = [1,$cBuiltinMacros];
    $mdef_name[$cBuiltinMacros] = $mac;
    $mdef_args[$cBuiltinMacros] = "";
    $mdef_body[$cBuiltinMacros] = "\"\" /* Fake built-in string */";
    $mdef_body_noc[$cBuiltinMacros] = "\"\"";
    $mdef_file[$cBuiltinMacros] = $built_in_fake_file;
    $mdef_line[$cBuiltinMacros] = 0;
    $mdef_physical_lines[$cBuiltinMacros] = 0;
    $mdef_category[$cBuiltinMacros] = 0;
    $mncategory{$mac} = $catLITERAL;
    $mntype{$mac} = $typeSTRING;

    $cBuiltinMacros++;
  }

  foreach $mac (@num_def_macros) {
    $macros{$mac} = [1,$cBuiltinMacros];
    $mdef_name[$cBuiltinMacros] = $mac;
    $mdef_args[$cBuiltinMacros] = "";
    $mdef_body[$cBuiltinMacros] = "1 /* Fake built-in number */";
    $mdef_body_noc[$cBuiltinMacros] = "1";
    $mdef_file[$cBuiltinMacros] = $built_in_fake_file;
    $mdef_line[$cBuiltinMacros] = 0;
    $mdef_physical_lines[$cBuiltinMacros] = 0;
    $mdef_category[$cBuiltinMacros] = 0;
    $mncategory{$mac} = $catLITERAL;
    # This isn't quite right; some are long, some float.
    $mntype{$mac} = $typeINT;

    $cBuiltinMacros++;
  }

  # This works:
  # print "HERE:", join(',',@$macros{"__LINE__"}), "\n";

  $cMacrosInTables = $cBuiltinMacros;

  return;
}


# analyze_for_macro_use($spliced_line)
# looks for macros in $spliced_line and saves the file,line#

# These are macro expansions, not mere uses:  we don't count the
# argument to #undef, for instance.

# This won't be quite right since we currently don't look through
# include-s in order.  Note that this is still subject to differences
# from the actual parse by cpp, since not all files are included by
# all files, but we work with a global (to the project) macro
# definitions list.
#
# We can do better by ensuring that before we count a macro usage,
# double check to make sure the current file includes a (or is the)
# file which defines the macro (and if it is the file, then make sure
# that the macro was defined on an earlier line number than we're at).
# (That's not quite enough; maybe this is included by a file that
# previously included the file that defines the macro.  We really need
# to read files in order...)
# 
# None of this is done for now, but probably should be later.
# Currently, we err on the side of reporting too many uses of macros.

# Note: another possible way to do this is with gjb's
# make-inclkude-for-defs-file -- see that in ~gjb/bin/share for eg.
sub analyze_for_macro_use ($) {
  my ($line) = check_args(1, @_);

  die "Shouldn't be analyzing for macro use when finding defs!"
    if $finding_macro_defs;

  # study $line;  # use this if you're gonna do lots of pattern matches


  my $macro_uses_index = $i_usage_code;
  my $cpp_defining_macro_name;
  if (substr($line,0,1) eq "#") {
    $line = substr($line,1);
    $line =~ s/^\s+//;
    $macro_uses_index = $i_usage_cond;
    if ($line =~ /^define\s+($identifier_re)/o)
      { $cpp_defining_macro_name = $1;
	#print STDERR "Defining $cpp_defining_macro_name\n";
	# Don't report the macro being defined unless it calls itself recursively
	# (in the body), which is legal in the current standard.
	$line = $POSTMATCH;
	$macro_uses_index = $i_usage_macro; }
    elsif ($line =~ /^undef\b/)
      { return; }
    elsif ($line =~ /^(if(n?def)?|elif)?\b/)
      { $line = $POSTMATCH; }
    else
      { # Let all the others default to "in conditional" also.
	# Perhaps macros can't expand anywhere else except in #include.
	# In that case, it would be safe to just return (after adding
	# the case to check for #include(_next)? and #import).
      }
  }

  my $word;
  # \W+ is probably more efficient than \b for the split criterion.
  foreach $word (split /\W+/,$line) {
    if (defined($macros{$word})) {
      # Need to remember:
      #  * that this macro was used on a code line, or not
      #  * that the macro was used on a preprocessor line, or not
      #  * that the macro was used in the current function, if any
      #  * that the macro was used globally, if it wasn't in a function
      # FIX: do we want to include information about a macro's expansion
      # including another macro?  (like dependent-macros)

      $macros_uses{$word}[$macro_uses_index]++;

      # Store the fact that $word is expanded in the expansion
      # of $cpp_defining_macro_name.
      if (defined($cpp_defining_macro_name)) {
	my $mi = mindex_from_name_file_line($cpp_defining_macro_name,
					    $current_file,
					    current_line_no());
	push @{$mdef_expansion_uses[$mi]}, $word;
	# print STDERR "Macro $cpp_defining_macro_name expands to something with $word-- using index $mi\n";
      }
      push @{$macros_file_line_uses{$word}}, ($current_file,current_line_no());
    }
  }
}

# cached values for which_function
# FIXPERL: perhaps we can simulate static function variables
# by putting functions that need them after a "package" declaration
# to change their scope.  We might then need to access globals explicitly,
# but it could be worth it-- definitely if we move to separate files
my $wf_last_filename = "%EMPTY CACHE%";
my $wf_last_line_no = -1;
my $wf_last_index = -1;

# Note: which_function can only be used after a complete second parse
# if you want to be sure you get things right
# use the $files_lines{$filename} list to find what function we're in,
# if any
sub which_function ($$) {
  my ($filename, $line_no) = check_args(2, @_);

  my $i = 0;

  my $listref = $files_lines{$filename};

  # FIXPERL: what is the implementation of lists? vector or linked-list?
  # FIXPERL: any way to do c-style static lexical variables?
  if ($filename eq $wf_last_filename &&
      $line_no >= $wf_last_line_no) {
    # we're moving forward in the same file, so use our old $wf_last_index
    $i=$wf_last_index;
  }

  # $$listref[i] is starting line of function,
  # $$listref[i+1] is name of function w/ leading "{"
  # $$listref[i+2] is ending line of function,
  # $$listref[i+3] is the information for the next function linearly

  # so if $line_no is between $$listref[i] and $$listref[i+2], inclusively,
  # we return $$listref[i+1]

  # first step through the list to the interesting case

  if (!defined($listref)) {
    print STDERR "no function information for $filename, $line_no";
    return;
  }

  if ($#{$listref} < $[ || $line_no < $$listref[0]) {
    return;
  }

  while ( $i <= $#{$listref} && $line_no > $$listref[$i]) {
    # print STDERR "Looking at fn $$listref[$i+1] ($$listref[$i],$$listref[$i+2]) for line $line_no in $filename\n";
    $i += 3;
    }

  if ($i >= 3) {
    $i -= 3;
  }

  # three possibilities:
  # 1) $i > $#{$listref} => return undef, since it's past all the fns listed
  # 2) $line_no is in the range $$listref[$i] thru $$listref[$i+2] (inclusive),
  #      so return $$listref[$i+1]
  # 3) $line_no > $$listref[$i] => return undef since we're past the line we want

  my $fn_name;			# starts out undefined

  if ($line_no >= $$listref[$i] && $line_no <= $$listref[$i+2]) {
    $fn_name = $$listref[$i+1];
  } elsif ($line_no > $$listref[$i+2]) {
    # undef
  } elsif ($line_no < $$listref[$i]) {
    # undef
  } else {
    die "Uexpected case in which_function: $filename:$line_no, @$listref[$i,$i+2]:\
$i $#{$listref}\n";
  }

  ($wf_last_filename, $wf_last_line_no ) = ($filename,$line_no);
  $wf_last_index = $i;

  return $fn_name;
}


sub compute_macros_used_in_functions () {
  check_args(0, @_);

  my ($macro,$uses_ref);

  while ( ($macro,$uses_ref) = each %macros_file_line_uses) {
    # FIX: this is a bit of a hack; we need to empty the cache
    # when we start looking at a different macro's uses, since
    # we can't just continue from our last point if the use
    # happens to be in the same file
    $wf_last_filename = "%EMPTY CACHE%";
    # print STDERR "Handling $macro\n";
    my $i;
    for ($i = 0; $i+1 <= $#{$uses_ref}; $i+=2 ) {
      my ($file,$line) = @{$uses_ref}[$i,$i+1];
      my $function_name = which_function($file,$line);
      my $function_id;
      if ($function_name) {
	$function_id = "$file:$function_name";
      } else {
	$function_name = "%global%";
	$function_id = "$file:%global%";
      }
      # print STDERR "USEIN: $function_name\n";
      push @{$macros_used_in_functions{$macro}}, $function_id;
      push @{$function_name_to_macros_it_uses{$function_id}}, $macro;
    }
  }
}

# return the index into the @mdef_XXX arrays for the macro definition described
sub mindex_from_name_file_line ($$$) {
  my ($name,$file,$line) = check_args(3, @_);

  my $cDefs = $macros{$name}[0];
  my $i = 1;

  while ( $i <= $cDefs ) {
    my $mi = $macros{$name}[$i];
    my $c_phys_lines = $mdef_physical_lines[$mi];
    my $first_phys_line = $mdef_line[$mi];

    #if ($name eq "NEXTBYTE" || $name eq "NLENGTH") {
    #  print STDERR "l,c,f: $line,$c_phys_lines,$first_phys_line\n";
    #}

    #FIX: I'm not convinced about why it needs to be $first_phys_line-1
    if ($mdef_file[$mi] eq $file &&
	($line >= $first_phys_line-1 && $line <= $first_phys_line + $c_phys_lines)) {
      return $mi;
    }
    $i++;
  }

  die "couldn't find mindex for $name $file $line";

  return;
}



###########################################################################
### data structure ops for orthogonal file types
###

sub update_cpp_directive_counts ($) {
  my ($cpp_cmd) = check_args(1, @_);

  #FIXPERL: emacs cperl mode requires the space between $ and { below
  #to correctly not parse the { as an open block

  # This code avoids warnings about using uninitialized values
  no strict 'refs';  #FIX: Must I do this?

  if (!defined($cppcmdcount{$cpp_cmd})) {
    print STDERR "Warning: Uncounted %OTHER% directive: $cpp_cmd for $current_ftype_index\n";
    $cpp_cmd = "%OTHER%";
  }
  $ {$rg_cppcmdcounts[$current_ftype_index]}{$cpp_cmd}++;

  $rg_cpp_cmds[$current_ftype_index]++;
  #print STDERR "GOTCPP: $cpp_cmd, for $current_ftype_index, so have $rg_cpp_cmds[$current_ftype_index]\n";
}

sub update_categories_for ($) {
  my ($catnumber) = check_args(1, @_);
  my $category = $categoryname[$catnumber];

  #FIXPERL: emacs cperl mode requires the space between $ and { below
  #to correctly not parse the { as an open block

  # This code avoids warnings about using uninitialized values
  no strict 'refs';  #FIX: Must I do this?
  if (!defined($ {$rg_category_counts[$current_ftype_index]}{$category})) {
    $ {$rg_category_counts[$current_ftype_index]}{$category} = 0;
  }
  $ {$rg_category_counts[$current_ftype_index]}{$category}++;

  #print STDERR "CAT: $category got incremented -- now is ",
  #$ {$rg_category_counts[$current_ftype_index]}{$category}, "\n";
}


# Sum corresponding elements of an array (or array slice)
# into the destination reference provided
sub sum_parallel_hashes ($@) {
  my ($dest_hashref,@array_of_hash_refs) = check_args_at_least(1,@_);
  no strict 'refs';  #FIX: Must I do this?
  my $hashref;
  my $key;
  foreach $hashref (@array_of_hash_refs) {
    foreach $key (keys %{$hashref}) {
      if (!defined($ {$dest_hashref}{$key})) {
	# print STDERR "UNDEF: $key\n";
	$ {$dest_hashref}{$key} = 0;
      }
      $ {$dest_hashref}{$key} += $ {$hashref}{$key};
    }
  }
  return;
}


# compute $cpp_cmds, $cpp_cmds_ni
# %cppcmpdcount, %cppcmdcount_ni
sub compute_global_cpp_sums () {
  check_args(0, @_);

  $cpp_cmds = sum_array(@rg_cpp_cmds[@ftype_ALL]);
  $cpp_cmds_ni = sum_array(@rg_cpp_cmds[@ftype_NOT_INCLUDED]);

  $cpp_cmds_c = sum_array(@rg_cpp_cmds[@ftype_CODE]);
  $cpp_cmds_c_ni = sum_array(@rg_cpp_cmds[@ftype_NONHEADER_NOT_INCLUDED]);

  $cpp_cmds_hdr = sum_array(@rg_cpp_cmds[@ftype_HEAD]);
  $cpp_cmds_hdr_ni = sum_array(@rg_cpp_cmds[@ftype_HEADER_NOT_INCLUDED]);

  sum_parallel_hashes(\%cppcmdcount,@rg_cppcmdcounts[@ftype_ALL]);
  sum_parallel_hashes(\%cppcmdcount_ni,@rg_cppcmdcounts[@ftype_NOT_INCLUDED]);
  sum_parallel_hashes(\%cppcmdcount_c_ni,@rg_cppcmdcounts[@ftype_NONHEADER_NOT_INCLUDED]);
  sum_parallel_hashes(\%cppcmdcount_hdr_ni,@rg_cppcmdcounts[@ftype_HEADER_NOT_INCLUDED]);

  sum_parallel_hashes(\%category_counts_ni,@rg_category_counts[@ftype_NOT_INCLUDED]);
  sum_parallel_hashes(\%category_counts_c_ni,@rg_category_counts[@ftype_NONHEADER_NOT_INCLUDED]);
  sum_parallel_hashes(\%category_counts_hdr_ni,@rg_category_counts[@ftype_HEADER_NOT_INCLUDED]);

}



###########################################################################
### #include handling
###


# FIX: Should optionally query system for the path
# With gcc, this means compiling a minimal program with gcc -v -c
# and parsing the output.
sub get_include_path () {
  check_args(0, @_);
  @include_path = (
		   "/usr/local/include",
		   "/usr/local/.contrib/gcc-2.7.2/i586-unknown-linux/include",
		   "/usr/local/.contrib/gcc-2.7.2/lib/gcc-lib/i586-unknown-linux/2.7.2/include",
		   "/usr/include",
#FIX: Should I include "."?  If so, then we have to be careful about
# multiple inclusions of header files in the project, since they will
# by pushed onto @files, and also exist in @files already (w/o complete
# pathname) from stdin
#		   ".",
		  );
  return;
}

# fix: If $system is true, look only for a system include file.
# Otherwise, look in package and system directories.
# Search through @include_path's directories and find the first
# directory that has $file in it.
sub complete_include_pathname ($$) {
  my ($file, $system) = check_args(2, @_);
  my $complete_file_try;
  my $complete_file = undef;
  my $dir;
  foreach $dir (@include_path) {
    $complete_file_try = "$dir/$file";
    if (-f $complete_file_try) {
      $complete_file = $complete_file_try;
      last;
    }
  }
  # print STDERR "Found $file to be $complete_file\n";
  # returns undefined if never set
  return $complete_file;
}


###########################################################################
### Utilities
###

# pct2(x) returns a percentage (not a fraction) which corresponds to arg1/arg2.
sub pct2 ($$) {
  my ($x,$w) = check_args(2, @_);
  if ($w <= 0) {
    croak("pct2: Bad divisor: $x / $w");
    return 0;
  }
  if ($x < 0 || $x > $w) {
    print STDERR "pct2: Percentage out of range: $x / $w\n";
  }
  return (100*$x/$w);
}


# sum_array sums all its inputs, typically the elements of an array.
# Pass in a slice of the array in order to sum that part.
sub sum_array (@) {
  my (@args) = check_args_at_least(0, @_);
  my $sum = 0;
  { my $elt = 0;
    foreach $elt (@args)
      { $sum += $elt; } }
  return $sum;
}

# Add newline to end of string; return string unchanged if it already has one.
sub add_newline ($)
{ my ($string) = check_args(1, @_);
  if ($string =~ m/\n$/)
    { return $string; }
  else
    { return $string . "\n"; }
}

# Remove newline from end of string; return string unchanged if it has none.
sub remove_newline ($)
{ my ($string) = check_args(1, @_);
  $string =~ s/\n$//;
  return $string;
}



###########################################################################
### Testing
###

# Don't bother checking type; we test expression types elsewhere.
sub test_categorize_macro_def ($$)
{ my ($category,$body) = check_args(2, @_);
  if (is_number($category))
    { $category = $categoryname[$category]; }
  $mdef_body[1000] = $body;
  $mdef_body_noc[1000] = $body;
  $mdef_name[1000] = "dummy";
  $mdef_args[1000] = "(arg)";
  undef $mdef_category[1000];
  categorize_macro_def(1000);
  if ($category ne $categoryname[$mdef_category[1000]])
    { print "Category $categoryname[$mdef_category[1000]] should have been $category for $body\n"; }
}

sub test_categorize_macro_defs ()
{
  $current_file = "testing";	# hack, for input_file_and_line
  $current_ftype_index = 1;	# hack, for update_categories_for

  test_categorize_macro_def("literal", "\"\\037\\235\"");
  test_categorize_macro_def("literal", "\"\037\235\"");
  test_categorize_macro_def("expression", "(uch)get_byte()");
  test_categorize_macro_def("expression", "memset ((voidp)(s), 0, (n))");
  test_categorize_macro_def("expression", "((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
  test_categorize_macro_def("expression", "((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
  test_categorize_macro_def("expression", "((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
  test_categorize_macro_def("expression", "malloc((size_t)(items)*(size_t)(size))");
  test_categorize_macro_def("expression", "(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
  test_categorize_macro_def($catTYPE, "struct bsdtty");
  test_categorize_macro_def($catTYPE, "extern inline");
  test_categorize_macro_def("statement", "if (status < 0) { perror(name); error=1; }");
  test_categorize_macro_def("statement", "if (foo) bar(baz)");
  test_categorize_macro_def("statement", "while (b - bufp->buffer + (n) > bufp->allocated)  EXTEND_BUFFER ()");
  test_categorize_macro_def("statement", "goto yyerrlab1");
  test_categorize_macro_def("statement", "return 0");
  test_categorize_macro_def("statement", "return err__fl((int)f,m,s)");
  test_categorize_macro_def("statement", "if (auth != mach_task_self () && ! __USEPORT (AUTH, port == auth))  return EPERM");
  test_categorize_macro_def("statement", "if (x == NULL) goto error");
  test_categorize_macro_def("recursive", "foo(dummy)");

  test_categorize_macro_def($catUSESTYPEARG, "((d)->d_reclen - offsetof (struct direct, d_name) - 1)");
  test_categorize_macro_def($catUSESTYPEARG, "_IOR('m', 2, struct mtget)");
  # I think this one fails.
  test_categorize_macro_def($catUSESTYPEARG, "__BITS(char*)");
}


# Print all lines that look like declarations.
sub test_typedecl_regexp ()
{
  check_args(0, @_);
  my $ifiles = 0;
#  foreach $this_file (@files)
  for (; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      $current_ftype_index = compute_ftype_index($current_file);
      if ($opt_v)
	{ print STDERR $current_file . "\n"; }
      open(INPUT,$current_file) or next; # skip to next file if open fails
      check_file_boundary();
      while ($line = get_fulltoken_line())
	{ if ($line =~ /^$type_specifier_re/o)
	    { print "ts: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re/o)
	    { print "td: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re\s*[,=;\(]/o)
	    { print "td+: $line"; }
	}
      check_file_boundary();
      close(INPUT);
    }
}


#$current_file = "test.c";

# This comes before the main loop so we can avoid executing it (the main loop).

# { my $argdecls = "int argc;char **argv;{";
#   if ($argdecls =~ /^\s*$type_declarator_re\s*([,;])/)
#     { print "$1|$3|$7|$9|$POSTMATCH\n"; } }

sub test_parse_expressions ()
{
  check_args(0, @_);

  # Integers
  test_parse_expression("int", "0400");
  test_parse_expression("unsigned int", "0x8000");
  # Different than the above because 55 is an int -- might be negative,
  # which wouldn't fit into unsigned int.  type_lub should take values
  # when appropriate, too, maybe.
  test_parse_expression("unsigned long", "33 ? 55 : 0x8000");
  # Should be int, not bool; it's (5 > 4) ? 3 : 2, not 5 > (4 ? 3 : 2).
  # This leads me down the slippery slope of coping with operator precedence...
  test_parse_expression("int", "5 > 4 ? 3 : 2");
  test_parse_expression("unsigned long", "2ULL");
  test_parse_expression("unsigned long", "(LONG_LONG_MAX * 2ULL + 1)");
  test_parse_expression("unsigned long", "0X7FFFFFFFL");

  # Floating-point literals
  test_parse_expression("float", "2.f");
  test_parse_expression("float", ".2f");
  test_parse_expression("float", "2.2f");
  test_parse_expression("float", "2.e3f");
  test_parse_expression("float", ".2e-4f");
  test_parse_expression("float", "2.2e8f");
  test_parse_expression("float", "2e22f");
  test_parse_expression("float", "22f");
  test_parse_expression("double", "2.");
  test_parse_expression("double", ".2");
  test_parse_expression("double", "2.2");
  test_parse_expression("double", "2.e3");
  test_parse_expression("double", ".2e-4");
  test_parse_expression("double", "2.2e8");
  test_parse_expression("double", "2e22");
  test_parse_expression("long double", "2.l");
  test_parse_expression("long double", ".2l");
  test_parse_expression("long double", "2.2l");
  test_parse_expression("long double", "2.e3l");
  test_parse_expression("long double", ".2e-4l");
  test_parse_expression("long double", "2.2e8l");
  test_parse_expression("long double", "2e22l");

  # Casts and named types
  test_parse_expression("char *", "(char*)NULL");
  test_parse_expression("ct_data near *", "(ct_data near *)0");
  test_parse_expression("uch", "(uch)get_byte()");
  test_parse_expression("char *", "(char*)&window[(unsigned)block_start]");
  test_parse_expression("char *", "(char*)NULL, (long)strstart - block_start, (eof)");
  test_parse_expression("long", "(long)strstart - block_start");
  test_parse_expression("char_type *", "((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
  test_parse_expression("ush", "((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
  test_parse_expression("ulg", "((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
  test_parse_expression("uch", "(uch)get_byte");
  test_parse_expression("uch", "(uch)get_byte()");
  test_parse_expression("va_list", "(va_list)__builtin_saveregs()");
  test_parse_expression("va_list", "((AP) = (va_list)__builtin_saveregs())");
  test_parse_expression("XColormapEvent *", "(XColormapEvent *)&Event");
  test_parse_expression("unsigned", "(unsigned)(1<<HASH_BITS)");
  test_parse_expression("__sighandler_t", "((__sighandler_t)-1)");
  test_parse_expression("size_t", "((size_t) &((TYPE *)0)->MEMBER)");
  test_parse_expression("Dimension", "((Dimension)~0)");
  test_parse_expression("struct __va_regs", "((struct __va_regs) foo)");
  test_parse_expression("struct __va_regs", "((struct __va_regs) { 1 })");
  test_parse_expression("struct __va_regs", "((struct __va_regs) {  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11})");
  test_parse_expression("struct __va_regs", "_AP =  ((struct __va_regs) {  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11})");

  # Characters
  test_parse_expression("char", "'\\'");
  test_parse_expression("char *", "\"foo\"");
  test_parse_expression("char *", "flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))");
  test_parse_expression("char *", "\"foo\" \"bar\"");
  test_parse_expression("char *", "\"foo\" \"bar\" \"baz\"");

  # Boolean
  test_parse_expression("bool", "inptr < insize");
  test_parse_expression("bool", "block_start >= 0L");
  test_parse_expression("bool", "(strcmp((s1),(s2)) == 0)");
  test_parse_expression("bool", "(state->basic.eax == MACH_RCV_INTERRUPTED && !memcmp (pc, &syscall, sizeof syscall))");
  test_parse_expression("bool", "(size1 == 0)");
  test_parse_expression("bool", "(startpos >= size1)");
  test_parse_expression("bool", "(foo || bar)");
  test_parse_expression("bool", "(size1 == 0 || startpos >= size1)");

  # Array
  test_parse_expression("typeUNKNOWN", "{  { LONG_MAX, LONG_MAX },  { LONG_MAX, LONG_MAX }, }");

  # Unknown
  test_parse_expression("typeUNKNOWN", "((B) - 1)");
  test_parse_expression("typeUNKNOWN", "tab_prefix[i]");
  test_parse_expression("typeUNKNOWN", "&window");
  test_parse_expression("typeUNKNOWN", "NULL");
  test_parse_expression("typeUNKNOWN", "(eof)");
  test_parse_expression("typeUNKNOWN", "memset ((voidp)(s), 0, (n))");
  test_parse_expression("typeUNKNOWN", "malloc((size_t)(items)*(size_t)(size))");
  test_parse_expression("typeUNKNOWN", "inbuf[inptr++]");
  test_parse_expression("typeUNKNOWN", "((A) < (B) ? (A) : (B))");
  test_parse_expression("typeUNKNOWN", "(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
  test_parse_expression("typeUNKNOWN", "fill_inbuf(0)");
  test_parse_expression("typeUNKNOWN", "BLOCK_SIGNAL (SIGCHLD, nvar, ovar)");
  test_parse_expression("typeUNKNOWN", "_elf_data_set_element(set, symbol)");
  test_parse_expression("typeUNKNOWN", "symbol_set_declare(set)");
  test_parse_expression("typeUNKNOWN", "_elf_text_set_element(set, symbol)");
  test_parse_expression($typeUNKNOWN, "get_byte()");
  test_parse_expression($typeUNKNOWN, "strcmp((s1),(s2))");
  test_parse_expression($typeUNKNOWN, "((s1),(s2))");
  test_parse_expression($typeUNKNOWN, "(s1),(s2)");
  test_parse_expression($typeUNKNOWN, "(s1)");
  test_parse_expression($typeUNKNOWN, "s1,s2");
  test_parse_expression($typeUNKNOWN, "strcmp(s1,s2)");
  test_parse_expression($typeUNKNOWN, "(1L << (n))");
  test_parse_expression($typeUNKNOWN, "(1 << (n))");
  test_parse_expression($typeUNKNOWN, "(1 << n)");
  test_parse_expression($typeUNKNOWN, "(1<<HASH_BITS)");
  test_parse_expression($typeUNKNOWN, "(((struct mhead *) mem) - 1) -> mh_index");
  test_parse_expression($typeUNKNOWN, "8 << (((struct mhead *) mem) - 1) -> mh_index");
  test_parse_expression($typeUNKNOWN, "O_WRONLY | O_CREAT | O_EXCL | O_BINARY");
  test_parse_expression($typeUNKNOWN, "(foo ? string2[startpos - size1]  : string1[startpos])");
  test_parse_expression($typeUNKNOWN, "(size1 == 0 || startpos >= size1 ? string2[startpos - size1]  : string1[startpos])");
  test_parse_expression($typeUNKNOWN, '$$PsectAttributes_NOSHR$$environ');
  test_parse_expression($typeUNKNOWN, "pthread_run->error_p =(x)");
  test_parse_expression("typeUNKNOWN", "{  &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,  __va0,__va1,__va2,__va3,__va4,__va5,  __va6,__va7,__va8,__va9,__va10,__va11}");
}

sub test_parse_expression ($$)
{
  my ($expected_type, $exp) = check_args(2, @_);
  $expected_type = type_name(type_to_num($expected_type));
  if ($debug_parse_expression)
    { print "test_parse_expression: '$expected_type' '$exp'\n"; }
  my ($parsed_type, $remaining) = parse_expression($exp);
  my $parsed_type_name = type_name($parsed_type);
  if ($debug_parse_expression)
    { print "test_parse_expression: '$expected_type' '$exp' '$parsed_type' '$parsed_type_name'\n"; }
  if ($remaining ne "")
    { print STDERR "Didn't parse all of $expected_type '$exp',\n    got $parsed_type_name with remaining = '$remaining'\n"; }
  elsif ($expected_type ne $parsed_type_name)
    { if ($exp =~ /\?/)
	{ print STDERR "Conditional flub? "; }
      print STDERR "Type $parsed_type_name ($parsed_type) should have been $expected_type for $exp\n"; }
}

sub test_regexp ($$;$)
{
  my ($string, $regexp, $regexp_pretty) = check_args_range(2, 3, @_);
  if ($string !~ /$regexp/)
    { print "'$string' should have matched "
	. (defined($regexp_pretty) ? $regexp_pretty : "regexp '$regexp'") . "\n"; }
}

sub test_declarator_re ($)
{
  my ($string) = check_args(1, @_);
  test_regexp($string, '^' . $declarator_re . '$', "declarator_re");
}

sub test_type_declarator_re ($)
{
  my ($string) = check_args(1, @_);
  test_regexp($string, '^' . $type_declarator_re . '$', "type_declarator_re");
}

sub test_type_declarator_re_plus ($)
{
  my ($string) = check_args(1, @_);
  test_regexp($string, '^\s*' . $type_declarator_re . '\s*([,=;\(])$', "type_declarator_re plus");
}

sub test_type_declarator_arglist_re ($)
{
  my ($string) = check_args(1, @_);
  test_regexp($string, '^' . $type_declarator_arglist_re . '$', "type_declarator_arglist_re");
}

sub test_typedecl_regexps ()
{
  check_args(0, @_);
  test_type_declarator_re_plus("int fill_inbuf(eof_ok);");
  test_type_declarator_arglist_re("int fill_inbuf(eof_ok)");
  test_type_declarator_re_plus("static char *license_msg[] =");
  test_type_declarator_re("static char *license_msg[]");
  test_type_declarator_re_plus("char z_suffix[MAX_SUFFIX+1];");
  test_declarator_re("(*out_char)");
  test_type_declarator_re("void (*out_char)");
  test_type_declarator_re_plus("void (*out_char)(");
  test_type_declarator_arglist_re("void (*out_char)()");
  test_declarator_re("(*close_func)");
  test_type_declarator_re("int (*close_func)");
  test_type_declarator_re_plus("int (*close_func)(");
  test_type_declarator_arglist_re("int (*close_func)(CL_Handle)");
  test_type_declarator_arglist_re("int (*func)(CL_Handle, int *, int)");
}

# print defined($type_num["foo"]);
# print "foo" + 0;
# print type_name(1);

# $foo = "x"; $foo =~ /x/; print defined($POSTMATCH), defined($POSTMATCH), defined($POSTMATCH), "\n";
# print ("" eq "\n"), "\n";
# "abaababb" =~ /(((a+)(b+))*)/; print "<<$1>><<$2>><<$3>><<$4>><<$MATCH>>\n";
# print scalar("static char" =~ /^\s*$type_specifier_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_unparenthesized_re$/o), "\n";
# print scalar("*" =~ /^$pointer_declarator_prefix_re/o), "\n";
# print scalar("license_msg" =~ /^\s*$identifier_re/o), "\n";
# print scalar("[]" =~ /^\s*$array_declarator_suffix_re/o), "\n";
# print scalar("char" =~ /^$type_re$/o), "\n";
# print scalar("char" =~ /^$type_specifier_re$/o), "\n";
# print scalar("char" =~ /^$identifier_re$/o), "\n";
# print scalar("(ct_data near *)" =~ /^\s*\(\s*$type_re\s*\)\s*$/o), "\n";
# print parse_array_initializer("bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};\n"), "\n";
# print scalar("(*sig_type)" =~ /^$declarator_re$/o), "\n";
# print scalar("z_suffix[MAX_SUFFIX+1]" =~ /^$declarator_re$/o), "\n";
# print scalar("[MAX_SUFFIX+1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print scalar("[1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print join(' -- ', parse_declarator("char", "z_suffix[MAX_SUFFIX+1]")), "\n";
# my @foo = (3,4,5,6); my @bar = @foo; $foo[0] = "new"; print @foo, "\n", @bar, "\n";

# print scalar("static void *" =~ /^$builtin_type_re/o), "\n";
# print scalar("void *" =~ /^$builtin_type_re/o), "\n";
# print scalar("void *" =~ /^$type_specifier_re/o), "\n";


# "extern void dc_binop (int (*)(dc_num, dc_num, int, dc_num *), int);"

# print scalar("int (*)(dc_num, dc_num, int, dc_num *), int));" =~ /^\s*($type_re_special)\s*([,\(\)])/o), "\n";
# print $type_re_special, "\n";


###########################################################################
### Main loop
###

# This is at the end of the file so that constants and variables can be
# introduced and set near where they are used rather than at the top of the
# file (before the main loop).  This is especially nice for globals that
# are only used by one or two routines.


use Getopt::Std;
getopts($getopts_option_letters);

usage() if ($opt_h);

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    if (!forbidden_file($_))
      { push @files,$_;
	$file_inclusion_method{$_} = "FromStdin"; }
  }
}

if ($opt_a && ($opt_u || $opt_1)) {
  die "Option -a is incompatible with options -u or -1";
}


# using a default directory-- only open the files that
# aren't explicitly given
if ($opt_d) {
  my ($dir,$basename) = split /:/,$opt_d;

  if (!defined($basename) || $basename eq "") {
    $basename = "";
  } else {
    $basename .= ".";
  }

  if ($dir !~ /\/$/) {
    $dir .= "/";
  }

  print STDERR "Output to $dir with prefix '$basename'\n";

  if (!$opt_E) {
    open(EVIL,">$dir/${basename}evil") || die "Failed opening $!";
  }

  if (!$opt_S) {
    open(STATS,">$dir/${basename}stat") || die "Failed opening $!";
  }

  if (!$opt_D) {
    open(DEFINES,">$dir/${basename}def") || die "Failed opening $!";
  }

  if (!$opt_M) {
    open(MACROS,">$dir/${basename}mac") || die "Failed opening $!";
  }

  if (!$opt_F) {
    open(FUNCTIONS,">$dir/${basename}func") || die "Failed opening $!";
  }

  if (!$opt_L) {
    open(FUNCLINES,">$dir/${basename}fnln") || die "Failed opening $!";
  }

  if (!$opt_C) {
    open(CATEG,">$dir/${basename}catg") || die "Failed opening $!";
  }

  if (!$opt_P) {
    open(PARSE_ERRS,">$dir/${basename}perr") || die "Failed opening $!";
  }
}

if ($opt_E) { open(EVIL,">$opt_E") || die "Failed opening $opt_E"; }
  elsif (!$opt_d) { open(EVIL,">-") || die "Failed opening stdout!"; }
if ($opt_P) { open(PARSE_ERRS,">$opt_P") || die "Failed opening $opt_P"; }
  elsif (!$opt_d) { open(PARSE_ERRS,">-") || die "Failed opening stdout!"; }
if ($opt_S) { open(STATS,">$opt_S") || die "Failed opening $opt_S"; }
if ($opt_F) { open(FUNCTIONS,">$opt_F") || die "Failed opening $opt_F"; }
if ($opt_L) { open(FUNCLINES,">$opt_L") || die "Failed opening $opt_L"; }
if ($opt_D) { open(DEFINES,">$opt_D") || die "Failed opening $opt_D"; }
if ($opt_M) { open(MACROS,">$opt_M") || die "Failed opening $opt_M"; }
if ($opt_C) { open(CATEG,">$opt_C") || die "Failed opening $opt_C"; }
if ($opt_I) { $fIgnoreIncludes = $true; }
if ($opt_t) { $outOFS = "\t"; } # use tab for OFS
if ($opt_l) { $identifier_re = $identifier_no_dollar_re; } # no $ in identifiers

# Fix: Explain why these are set unconditionally.
# Now set these so we'll actually do the output
# (output_stats uses $opt_X as a guard for printing)
$opt_E = $true;
$opt_S = $true;
$opt_D = $true;
$opt_M = $true;
$opt_F = $true;
$opt_L = $true;
$opt_C = $true;
$opt_P = $true;

# Clunky, but faster than editing and saving the file over NFS.
if ($opt_g)
{ if ($opt_g == 0)
    { $fDebugCmdProcessing = $false;
      $fDebugCommentRemoval = $false;
      $debug_scopes = $false;
      $debug_type_match = $false;
      $debug_parse_function = $false;
      $debug_parse_expression = $false;
      $debug_merge_branches = $false;
      $debug_parse_array_init = $false;
      $debug_peek = $false;
      $debug_getline = $false;
      $debug_categorize_macro = $false; }
  elsif ($opt_g == 1) { $fDebugCmdProcessing = $true; }
  elsif ($opt_g == 2) { $fDebugCommentRemoval = $true; }
  elsif ($opt_g == 3) { $debug_scopes = $true; }
  elsif ($opt_g == 4) { $debug_type_match = $true; }
  elsif ($opt_g == 5) { $debug_parse_function = $true; }
  elsif ($opt_g == 6) { $debug_parse_expression = $true; }
  elsif ($opt_g == 7) { $debug_merge_branches = $true; }
  elsif ($opt_g == 8) { $debug_parse_array_init = $true; }
  elsif ($opt_g == 9) { $debug_peek = $true; }
  elsif ($opt_g == 10) { $debug_getline = $true; }
  elsif ($opt_g == 11) { $debug_categorize_macro = $true; }
  elsif ($opt_g == 12) { $debug_cpp_if_comments = $true; }
  else { die "Bad -g option $opt_g"; }
}

# Testing
if ($opt_T)
{ test_typedecl_regexps();
  test_parse_expressions();
  test_categorize_macro_defs();
  exit -1;			# Don't run following programs, eg from gzip.
  # exit;			# Find this via search for the string "exit;".
}

$fDebugCmdProcessing && print "@ARGV";

# Add the rest of the arguments to the files list
{ my $file;
  foreach $file (@ARGV) {
    if (!forbidden_file($file))
      { push @files,$file;
	$file_inclusion_method{$file} = "FromCmdLine"; }
  } }

get_include_path();
initialize_builtin_macros();
initialize_lists_of_hashes();

## Begin processing files

if ($opt_v) { print STDERR "Processing ", scalar(@files), " files",
  	                   ($opt_I ? "" : " (plus \#included files)"), "...\n"; }

find_macro_definitions();	# also counts other preprocessor usage

# Kind of a hack
{ my $name;
  for $name (keys %macros)
    { if (is_fun_decl_arg_macro($name))
	{ $fun_decl_arg_macros{$name} = $true; }
      if (is_semi_fun_decl_arg_macro($name))
	{ $semi_fun_decl_arg_macros{$name} = $true; }
      if (is_void_macro($name))
	{ $void_macros{$name} = $true; } } }
# print "fun_decl_arg_macros: ", join(" ", (keys %fun_decl_arg_macros)), "\n";
# print "semi_fun_decl_arg_macros: ", join(" ", (keys %semi_fun_decl_arg_macros)), "\n";
# print "void_macros: ", join(" ", (keys %void_macros)), "\n";


# Print number of definitions for each macro
# { my $name;
#   for $name (sort keys %macros)
#     { print "$name $macros{$name}[0]\n"; } }

if (!$opt_1)
{ if ($opt_v) { print STDERR "done finding macro definitions; now finding macro uses...\n"; }
  process_macro_calls();
}

if ($opt_v) { print STDERR "Computing macro/function use relations...\n"; }
compute_macros_used_in_functions();

### All the files have been read; now process the macros
# Expression used to have +1, but that wasn't right.
print STDERR "Categorizing " . ($cMacrosInTables - $cBuiltinMacros) . " macros\n";
{ my $i;
  local $categorizing_macros = $true;
  for ($i = $cBuiltinMacros;
       $i < $cMacrosInTables;
       $i++ )
    { # print "$i: $mdef_body[$i]\n";
      #   print &parse_expression($mdef_body[$i]) . ": ";
      #   foreach $var (keys(%parsevars)) { print $var . " "; }
      #   print "\n  $mdef_name[$i]";
      #   if (defined($mdef_args[$i])) { print $mdef_args[$i]; }
      #   print " $mdef_body[$i]\n";
      #current_file and current_line_no need to be set for
      # while we are categorizing.  Also must always
      # set $current_ftype_index when we change the $current_file
      # (use compute_ftype_index() )
      $current_file = $mdef_file[$i];
      $current_ftype_index = compute_ftype_index($current_file);
      $current_macro_line_number = $mdef_line[$i];
      categorize_macro_def($i);
    } }

#FIX: should I only print this stuff w/ -v?
print STDERR "Computing various global statistics...\n";
compute_global_cpp_sums();

output_stats();

#print STDERR "Included files:", join("\n",@files_included), "\n";

exit();

### Local Variables:
### page-delimiter: "^#################################################*\n"
### End:
