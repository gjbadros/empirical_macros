#!/uns/bin/perl -w
# $Id$
# evilmacros

# Report "evil" CPP macros:
#  Illegal macros:
#   Unterminated string
#   Wrong length character constant
#   Unterminated character constant
#   Pasting via comments (syntactically legal, but no pasting occurs in ISO C)
#  Potentially dangerous macros:
#   Unbalanced parens, braces, and brackets
#   Pasting via ##
#   Stringization via #
#   Arguments but no body
#  Turned off testing for:
#   Empty string

# FIX: the options are non-orthogonal ... this is confusing
sub usage {
   die "@_\nUsage: $0 [-ihvDsS] <files>
  -i  use files listed on stdin [one per line] in addition to any on cmd line
  -h  display this help message
  -v  be verbose and list files as they are processed to stderr
  -D [file]  output the names of the macros (and number of times defined)
  -S [file]  output the per directive statistics to file
  -c [file]  show categorizations to file
  -e [file]  send evil macros to file instead of stdout
";
}

# Invoke like this:   evilmacros `find-c`
# or like this:  find-c | evilmacros -i
# Perhaps this should do the searching through subdirectories itself,
# but that is easy to do from the shell.

#Complex execution (use zsh):
# ext=all; p=~/505/data; for i in *(/); do pushd $i; find-c | nice evilmacros -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# alias find-c='find . \( -name UNUSED -o -name CVS -o -name SCCS -o -name RCS \) -prune -o \( -name "*.[chCH]" -o -name "*.[cC][cC]" -o -name "*.[cC][pP][pP]" \) -print'
# ext=all; p=/tmp/mernst/data; for i in *(/); do pushd $i; find-c | nice /homes/rivers/mernst/research/notkin/macros/evilmacros-961223 -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# For some reason, adding " >&! ../out-err" doesn't work.
# Probably omit ">! ../out-out", too, so I can see output.
# find-c | evilmacros -i -D../out-def -e../out-evil -c../out-cat -S../out-stat -v >! ../out-out
# evilmacros -D../out-def -e../out-evil -c../out-cat -S../out-stat -v getopt.c

# Harbison & Steele p. 53:
#   ISO C reaffirms that macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.


###########################################################################
### To do
###

## Temporarily moved into my notes-macros file.



###########################################################################
### Constants
###

$scopemarker = "scope marker";	# contains space, as no real variable can

### Boolean
$true = (1 == 1);
$false = (1 == 0);

# some evilness (pasting, stringization) is independent of the others,
# though it may not be able to be classified (actually, stringization
# is pretty easy to classify, when we see that a macro argument follows #).
# In this case evilness is more need-for-preprocessor.

# Also note that some evilness has to do with whole files, or parsing,
# while other has to do with macros that have to be macros.
# Maybe rename the latter from "evil" to "macrofeature" or some such.

# These should probably be merged into failure categories, below
$OBSOLETE = 1;
$DANGER = 2;
$EVIL = 3;
$ILLEGAL = 4;

# Nonconstant: free var (var, function, etc), expression w/side effect,
#	inconsistent types, etc.
# Statement (??)
# Other unclassifiable: give evilness reason, or name the free var,
#	or do multiple of these.


# Categories

$catNOTYET = 0;			# shouldn't be used; should be undefined instead
$catINPROCESS = 1;
$catMULTIPLE = 2;
$catNULLDEFINE = 3;
# Expressions
$catEXP = 4;
$catEXPFREE = 5;		# expression with free variables
$catLITERAL = 6;			# also specify the literal
$catCONSTANT = 7;			# need to also specify the particular value, if possible
$catSOMECONSTANT = 8;
# Non-expressions
$catFAILURE = 9;		# shouldn't have just one, should have many
$catTYPEARG = 10;			# macro argument has a type
# These shouldn't be failures
$catMACROFUN = 11;
$catMACROTYPE = 12;

@categoryname = ('uncategorized', 'being categorized', 'multiply categorized', 'null define', 'expression', 'expression with free variables', 'literal', 'constant', 'some constant', 'failed categorization', 'has type argument', 'macro as function', 'macro as type');

## Needs to be fixed.
## Perhaps give actual constant, so it can be determined.
sub category_lub
{ my ($c1, $c2) = @_;
  return (($c1 == $c2) ? $c1 : $catMULTIPLE);
}


###########################################################################
### Regular expressions
###

# Use /o in matches for these, so interpolation/compilation occurs just once.
# Use single, not  double, quotes so as not to lose the backslashes.
# But note that \\ and \' are interpolated in single-quoted strings.
# "\b" prevents two words from running up against one another
# These regexps are intended not to include any leading or trailing space

# FIX: this regexp is lame-- L,x,U needed for 0x80 << 1LU
$constantexpregexp = '[-LxU0-9() \t<>+=*|&%!]+';	# note this matches whitespace

# Types and declarations/definitions.
$typespecifier = '\b\w+\b(\s+\b\w+\b)*'; # 1 group
$typeregexp = '(' . $typespecifier . '(\s*(\*|\[\s*\]))*)'; # 4 groups
$identregexp = '\b([a-zA-Z_]\w*)\b';
# Use $typedeclarator instead.
# $typeidentregexp = $typeregexp . '\s*' . $identregexp;

# Declarators are actually rather more complicated than this:  see H&S p. 85.
$typequalifier = '\b(const|volatile)\b';
$pointerdeclaratorprefix = '\*(\s*' . $typequalifier . ')*'; # 2 groups
$arraydeclaratorsuffix = '\[(' . $constantexpregexp . ')?\]';
# $functiondeclaratorsuffix = ...;
# declaratorsuffix = $arraydeclaratorsuffix plus $functiondeclaratorsuffix
# 6 groups: $1 = pointerdeclarators, $4 = identifier, $5 = arraydeclarators
$declarator = '(' . $pointerdeclaratorprefix . '\s*)*'
  . $identregexp
  . '(\s*' . $arraydeclaratorsuffix . ')*';
# Use this in preference to $typeidentregexp
# 8 groups: $1 = typespecifier, $3 = pointerdeclarators, $6 = identifier, $7 = arraydeclarators
$typedeclarator = '(' . $typespecifier . ')\s*' . $declarator;

# # This isn't going to work, because of looping.  Break it somehow.
# $simpledeclarator = $identregexp;
# $arraydeclarator = $directdeclarator . '\s*\[(' . $constantexpregexp . ')?\]';
# $typequalifier = '\b(const|volatile)\b';
# $directdeclarator = '(' . $arraydeclarator . '|' . $simpledeclarator . ')';
# $pointerdeclarator = '\*(\s*' . $typequalifier . ')*\s*' . $directdeclarator;
# $declarator = '(' . $pointerdeclarator . '|' . $directdeclarator . ')';
# type plus identifier:  $1 = type, $5 = identifier

# Numeric literals
# floating-point number (two variants): $1 = exponent, $2 = suffix (fFlL)
$floatlitwhole = '[-+]?\d+\.\d*([eE][-+]?\d+)?([fFlL]?)'; # decimal 2.
$floatlitfrac = '[-+]?\d*\.\d+([eE][-+]?\d+)?([fFlL]?)'; # fraction .2
# integer regexp: $1 = number, $2 = suffix (uUlL)
$hexlitregexp = '(0x[0-9a-fA-F]+)([uUlL]?[uUlL]?)';
$decoctlitregexp = '(\d+)([uUlL]?[uUlL]?)';

# Character and string literals
$charlitcontents = '(\\\\?.|\\\\[0-7][0-7][0-7])'; # contents of char literal
$charlit = "L?'" . $charlitcontents . "'"; # character literal
$nonescdquote = '(^|[^\\\\])(\\\\\\\\)*\"'; # non-escaped double quote
# PROBLEM:  .* matches too much skips over intervening quotes; .*? is non-greedy
$stringlitregexp = 'L?\"(|.*?[^\\\\])(\\\\\\\\)*\"'; # string literal

# Does not handle enum, struct, union, and function types
$numerictypeword = '\b(short|signed|unsigned|long|int|char|float|double)\b';
$numerictype = $numerictypeword . '(\s+' . $numerictypeword . ')*';
$nonnumerictype = '\b(void)\b';
$builtintype = "($numerictype|$nonnumerictype)";
$typesuffix = '(\s*(\*|\[\d*\]))*'; # note contains leading whitespace
$fullbuiltintype = $builtintype . $typesuffix;


###########################################################################
### Types
###

# Perhaps reserve 0 for unrecognized (non-built-in) type.
# No, with new scheme it's important that it be 0
$typeFAIL = 0;			# does not parse as a valid type
$typeBOOL = 1;
$typeCHAR = 2;			# ought to have typeWCHAR as well
$typeUCHAR = 3;
$typeSCHAR = 4;
$typeSHORT = 5;
$typeUSHORT = 6;
$typeINT = 7;
$typeUINT = 8;
$typeLONG = 9;
$typeULONG = 10;
$typeFLOAT = 11;
$typeDOUBLE = 12;
$typeLDOUBLE = 13;
$typeSTRING = 14;
$typeUNKNOWN = 15;		# we know it's some type, but don't know which
$typeUNSPECIFIED = 16;		# declared w/o a type (e.g., as function arg)

%type_num = ('short' => $typeSHORT, 'short int' => $typeSHORT,
	     'signed short' => $typeSHORT, 'signed short int' => $typeSHORT,
	     'unsigned short' => $typeUSHORT, 'unsigned short int' => $typeUSHORT,
	     'int' => $typeINT, 'signed int' => $typeINT, 'signed' => $typeINT,
	     'unsigned int' => $typeUINT, 'unsigned' => $typeUINT,
	     'long' => $typeLONG, 'long int' => $typeLONG,
	     'signed long' => $typeLONG, 'signed long int' => $typeLONG,
	     'unsigned long' => $typeULONG, 'unsigned long int' => $typeULONG,
	     'char' => $typeCHAR,
	     'unsigned char' => $typeUCHAR,
	     'signed char' => $typeSCHAR,
	     'float' => $typeFLOAT,
	     'double' => $typeDOUBLE,
	     'long double' => $typeLDOUBLE,
	     'char *' => $typeSTRING, 'char*' => $typeSTRING);

@type_name_array = ('typeFAIL', 'bool',
		    'char', 'unsigned char', 'signed char',
		    'short', 'unsigned short',
		    'int', 'unsigned int',
		    'long', 'unsigned long',
		    'float', 'double', 'long double',
		    'char *',
		    'TYPEunknown');

# For determining whether a Perl variable has numeric type.
# This is incredibly disgusting; do something about it.
sub is_number
{
  my ($arg) = @_;
  $arg =~ /^\d+$/;
}

sub type_name
{
  my ($type) = @_;
  if (is_number($type))
    { return $type_name_array[$type]; }
  else
    { return $type; }
}

sub type_to_num
{
  my ($type) = @_;
  # print "type = $type; type_num{type} = $type_num{$type} \n";
  $type =~ s/( [ \t]+|\t[ \t]*)//og; # compress multiple spaces to just one
  if (defined($type_num{$type}))
    { return $type_num{$type}; }
  else
    { push(@parsetypes, $type);
      return $type; }
}


### Numeric types

# This doesn't yet do the right thing.
sub infer_int_type
{
  my ($int) = @_;
  if ($int =~ /^0[xX]/)
    # Hex
    { # return first of ($typeUINT $typeLONG $typeULONG) in which the number fits
      return $typeUINT; }
  elsif ($int =~ /^0/)
    { return $typeINT; }	# was unsigned int in non-ANSI C.
  else
    { # return first of ($typeINT $typeLONG $typeULONG) in which the number fits
      return $typeINT; }
}

sub type_integral_p
{ my ($type) = @_;
  return (($type == $typeBOOL)
	  || ($type == $typeCHAR) || ($type == $typeUCHAR) || ($type == $typeSCHAR)
	  || ($type == $typeSHORT) || ($type == $typeUSHORT)
	  || ($type == $typeINT) || ($type == $typeUINT)
	  || ($type == $typeLONG) || ($type == $typeULONG));
}

### Type manipulation: arrays, pointers, functions

sub type_dereference
{ my ($type) = @_;
  if ($type == $typeSTRING)
    { return $typeCHAR; }
  if ($type =~ /(\*|\[\])\s*$/)
    { return $`; }
  return $typeUNKNOWN;
}

# A function type looks like ( ),( ),( )->( )
# The full parentheses are necessary (but I don't think they are sufficient)
# to avoid misparsing nested function types.  Maybe that doesn't happen...

# sub type_apply


### Type conversions

# Perhaps these should be arrays instead.

sub type_unsigned
{
  my ($type) = @_;
  if (($type == $typeCHAR) || ($type == $typeSCHAR))
    { return $typeUCHAR; }
  elsif ($type == $typeSHORT)
    { return $typeUSHORT; }
  elsif ($type == $typeINT)
    { return $typeUINT; }
  elsif ($type == $typeLONG)
    { return $typeULONG; }
  else
    { return $type; }
}

sub type_signed
{
  my ($type) = @_;
  if (($type == $typeCHAR) || ($type == $typeUCHAR))
    { return $typeSCHAR; }
  elsif ($type == $typeUSHORT)
    { return $typeSHORT; }
  elsif ($type == $typeUINT)
    { return $typeINT; }
  elsif ($type == $typeULONG)
    { return $typeLONG; }
  else
    { return $type; }
}

sub type_long
{
  my ($type) = @_;
  if ($type == $typeCHAR)
    { return $typeLONG; }
  elsif ($type == $typeUCHAR)
    { return $typeULONG; }
  elsif ($type == $typeSCHAR)
    { return $typeLONG; }
  elsif ($type == $typeSHORT)
    { return $typeLONG; }
  elsif ($type == $typeUSHORT)
    { return $typeULONG; }
  elsif ($type == $typeINT)
    { return $typeLONG; }
  elsif ($type == $typeUINT)
    { return $typeULONG; }
  elsif ($type == $typeLONG)
    { return $typeLONG; }
  elsif ($type == $typeULONG)
    { return $typeULONG; }
  else
    { return $type; }
}

# The "usual binary conversions"; H&S p. 176
# except that if types are identical, it returns them.
# Can also return short, ushort.
sub type_lub
{ my ($t1, $t2) = @_;
  # This test works whether $t1, $t2 are numbers or strings
  if ($t1 eq $t2)
    { return $t1; }
  if (!is_number($t1))
    { $t1 = $typeUNKNOWN; }
  if (!is_number($t2))
    { $t2 = $typeUNKNOWN; }
  if ($t1 > $t2)
    { ($t1, $t2) = ($t2, $t1); }
  # If either $t1 or $t2 is a string, its numeric equivalent is zero
  if ($t1 == 0)			# 0 == $typeFAIL
    { return $typeFAIL; }
  if ($t2 == $typeUNKNOWN)
    { return $typeUNKNOWN; }
  if (($t2 == $typeLDOUBLE) || ($t2 == $typeDOUBLE) || ($t2 == $typeFLOAT)
      || ($t2 = $typeULONG) || ($t2 = $typeLONG)
      || ($t2 == $typeUINT) || ($t2 == $typeINT)
      || ($t2 == $typeUSHORT)  || ($t2 == $typeSHORT))
    { return $t2; }
  # Otherwise, differing char types.
  return $typeSHORT;
}


###########################################################################
### Variables
###

## Integers:
$lines = 0;			# count of lines; line continuation doesn't increment
$cpp_cmds = 0;			# total preprocessor commands
$symtab_scopes = 0;		# the number of scopes, less the global scope
## Strings:
$line = "";			# current line
# $lastline = "";			# the prior line
# $currentfile = 0;
# $mname = 0;
# $margs = 0;
# $mdef = 0;
## Boolean:
$incomment = $false;		# in /* */ style comment
$instring = $false;
$commaop = $true;		# whether commas should be operators or not
				# (they shouldn't in arglists, initializers)
# These indicate the pass, for getline_handle_preprocessor_command
$finding_macro_defs = $false;
$getting_macro_call_types = $false;

# Shouldn't be in a character constant across lines.
# $incharconst = 0;
## Arrays
# %cppcmdcount: number of uses of each cpp command
# %files: contains each file processed

# perhaps make %macros proper just index into other arrays.

# %macros = for each macro, list of indexes for info about it
# Also want to have summary info true about all definitions...
#  @mname @margs @mbody @mfile @mline
#  @mbody_noc @mfreevars @mfreefuns
#  @mdependenton @mtype @mcategory @mevilness
# These are for aggregate information.  Keep it for all macros, or just
# those multiply defined?  Or put it in the other arrays?  (No.)
#  %mntype %

# For getline():
$getline_nocomment = $false;
$getline_simplify = $false;
@getline_ungotlines = ();
$getline_nocpp = $false;
#gd# @getline_ungotdependenton = ();

@dependenton = ();
# Need a stack of old dependentons, for use by ungetline?  Or maybe just
# let peekline take an optional argument.



###########################################################################
### Testing
###

# { my $argdecls = "int argc;char **argv;{";
#   if ($argdecls =~ /^\s*$typedeclarator\s*([,;])/)
#     { print "$1|$3|$7|$9|$'\n"; } }

# print "<<" . parse_expression ("(uch)get_byte()") . "\n";
# print "<<" . parse_expression ("get_byte()") . "\n";
# print "<<" . parse_expression ("(uch)get_byte") . "\n";
# print "<<" . parse_expression ("(strcmp((s1),(s2)) == 0)") . "\n";
# print "<<" . parse_expression ("strcmp((s1),(s2))") . "\n";
# print "<<" . parse_expression ("((s1),(s2))") . "\n";
# print "<<" . parse_expression ("(s1),(s2)") . "\n";
# print "<<" . parse_expression ("(s1)") . "\n";
# print "<<" . parse_expression ("s1,s2") . "\n";
# print "<<" . parse_expression ("strcmp(s1,s2)") . "\n";
# print "<<" . parse_expression ("'\\'") . "\n";
# print "<<" . parse_expression ("(1L << (n))") . "\n";
# print "<<" . parse_expression ("(1 << (n))") . "\n";
# print "<<" . parse_expression ("(1 << n)") . "\n";
# print "<<" . parse_expression ("(unsigned)(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("\"foo\"") . ">>\n";
# print "<<" . testcategorizeMacro("\"\\037\\235\"") . ">>\n";
# print "<<" . testcategorizeMacro("\"\037\235\"") . ">>\n";
# if (parse_expression ("\"foo\"")) { print "FOO is true "; } else { print "false"; }
# if (0) { print "ZERO is true "; } else { print "false"; }
# print type_name(parse_expression("0400")) . "\n";
# print type_name(parse_expression("0x8000")) . "\n";
# print type_name(parse_expression("33 ? 55 : 0x8000")) . "\n";
# print type_name(parse_expression("tab_prefix[i]")) . "\n";
# print defined($type_num["foo"]);
# print "foo" + 0;
# print type_name(1);
# print type_name(parse_expression("flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("block_start >= 0L")) . "\n";
# print type_name(parse_expression("(char*)&window[(unsigned)block_start]")) . "\n";
# print type_name(parse_expression("(char*)NULL, (long)strstart - block_start, (eof)")) . "\n";
# print type_name(parse_expression("&window")) . "\n";
# print type_name(parse_expression("(char*)NULL")) . "\n";
# print type_name(parse_expression("NULL")) . "\n";
# print type_name(parse_expression("(long)strstart - block_start")) . "\n";
# print type_name(parse_expression("(eof)")) . "\n";
# print type_name(parse_expression("(uch)get_byte()")) . "\n";
# testcategorizeMacro("(uch)get_byte()");
# print type_name(parse_expression("memset ((voidp)(s), 0, (n))")) . "\n";
# print type_name(parse_expression("((char_type *)(&d_buf[DIST_BUFSIZE-1]))")) . "\n";
# print type_name(parse_expression("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))")) . "\n";
# print type_name(parse_expression("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))")) . "\n";
# print type_name(parse_expression("malloc((size_t)(items)*(size_t)(size))")) . "\n";
# testcategorizeMacro("memset ((voidp)(s), 0, (n))");
# testcategorizeMacro("((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
# testcategorizeMacro("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
# testcategorizeMacro("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
# testcategorizeMacro("malloc((size_t)(items)*(size_t)(size))");
# $foo = "x"; $foo =~ /x/; print defined($'), defined($'), defined($'), "\n";
# print ("" eq "\n"), "\n";
# testcategorizeMacro("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
# print type_name(parse_expression("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))")) . "\n";
# print type_name(parse_expression("inptr < insize")) . "\n";
# print type_name(parse_expression("inbuf[inptr++]")) . "\n";
# # This is failing because of the function call, I suppose.
# print type_name(parse_expression("fill_inbuf(0)")) . "\n";
# exit;



###########################################################################
### Use strict
###

use vars qw( $fShowCategorization $fDebugCmdProcessing %cppcmdcount $index $file
	   @dependenton $line $identregexp $cpp_cmd $cpp_cmds %macros @mname @margs @mbody
	   @mdependenton @mfile $lines $h $mline $cObsoleted $cDanger $cEvil $cIllegal
	   @categoryname $typespecifier $typedeclarator $symtab_scopes $instring);
$fDebugCmdProcessing = 0;
$fDebugCommentRemoval = 0;

# Use strict requires that all globals are either fully qualified with
# the package name (e.g. $main::$true) or are declared in a use vars qw( ... ) decl'n
# Turning "use strict" on would involve adding all globals to above,
#    or making them lexical vars.  Changing the scoping of a variable can
#    lead to hard to find bugs, so gjb is not doing this now.
# use strict;
# use English;



###########################################################################
### Main loop
###

# I would like to move this to the end of the file, so that we can
# introduce constants and variables near where they are used, especially
# those that are only used by one or two routines to save state or control
# behavior.

use Getopt::Std;
use vars qw( $opt_i $opt_h $opt_v $opt_D $opt_S $opt_c $opt_e);

getopts('ihvD:S:c:e:');
usage() if ($opt_h);

$fShowCategorization = $opt_c;

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    push @ARGV, $_;
  }
}

if ($opt_e) { open(EVIL,">$opt_e") || die "Failed opening $opt_e"; }
  else { open(EVIL,">-") || die "Failed opening stdout!"; }
if ($opt_S) { open(STATS,">$opt_S") || die "Failed opening $opt_S"; }
if ($opt_D) { open(DEFINES,">$opt_D") || die "Failed opening $opt_D"; }
if ($opt_c) { open(CATEG,">$opt_c") || die "Failed opening $opt_c"; }


$fDebugCmdProcessing && print "@ARGV";

# test_typedecl_regexp(); exit();

find_macro_definitions();	# also counts other preprocessor usage

# Print number of definitions for each macro
# for $name (keys %macros)
# { print "$name $macros{$name}[0]\n"; }

get_macro_call_types();

### All the files have been read; now process the macros
print "Processing " . $cppcmdcount{"define"} . " macros\n";
for $index (0..$cppcmdcount{"define"}-1)
{ # print "$index:  . "" . $mbody[$index] . "\n";
#   print &parse_expression($mbody[$index]) . ": ";
#   foreach $var (keys(%parsevars)) { print $var . " "; }
#   print "\n  $mname[$index]";
#   if (defined($margs[$index])) { print $margs[$index]; }
#   print " $mbody[$index]\n";
  categorizeMacro($index);
}

# 	  
# 
# 	  # Nothing to check if this is just making the macro defined w/o a body.
# 	  if (defined($mdef) && ($flags = checkmacrobody($mdef)) != 0) {
# 	    $cEvil++ if $flags & $EVIL;
# 	    $cIllegal++ if $flags & $ILLEGAL;
# 	    $cObsoleted++ if $flags & $OBSOLETE;
# 	    $cDanger++ if $flags & $DANGER;
# 	  }

output_stats();

exit();


###########################################################################
### Main loop routines
###

### Read files, save info about macros
sub find_macro_definitions
{
  if ($finding_macro_defs)
    { die "Called find_macro_definitions, but already finding macrodefs"; }
  local $finding_macro_defs = $true;
  foreach $file (@ARGV)
    { if ($opt_v)
	{ print STDERR $file . "\n"; }
      open(INPUT,$file) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$file} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      while ($line = getline())
	{
	  # Amazingly enough, all the work is done by getline, which
	  # calls process_macro_definition.
	}
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      close(INPUT);
    }
}

# Given a macro definition (everything after "#define", with no leading,
# trailing space), enter it into the appropriate global arrays
sub process_macro_definition
{
  my ($def) = @_;
  # print "process_macro_definition <<$def>>\n";
  my ($name, $args, $body) = macroparse($def);

  if (!defined($args)) { $args = ""; }
  # print "parsed: |$name|$args|$body|\n";
  my ($thisnum) = $cppcmdcount{"define"}-1;
  ($macros{$name}[0])++;
  $macros{$name}[$macros{$name}[0]] = $thisnum;
  # print "def number $macros{$name}[0]:";
  # for ($i = 1; $i <= $macros{$name}[0]; $i++)
  #   { print " $macros{$name}[$i]"; }
  # print "\n";
  $mname[$thisnum] = $name;
  $margs[$thisnum] = $args;
  $mbody[$thisnum] = $body;
  $mdependenton[$thisnum] = @dependenton;
  $mfile[$thisnum] = $file;
  $mline[$thisnum] = $.;
}


sub output_stats
{

  if ($lines == 0) {
    print STDERR "No lines read! Perhaps you meant to use the -i option?\n";
  } else {
    if ($opt_S) {
      my ($h, $v);
      # Dump statistics on frequencies of directives
      printf STATS "DIRECTIVES#: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	print STATS "$h ";
      }
      print STATS "\n";
      printf STATS "DIRECTIVES: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	print STATS "$v ";
      }
      print STATS "\n";
      printf STATS "DIRECTIVES%: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	printf STATS "%2.2f ", (100*$v/$lines);
      }
      print STATS "\n";

      printf STATS "GLOBAL: $cppcmdcount{'define'} define-s (%2.2f%), " . ($cpp_cmds - $cppcmdcount{"define"}) . " other (%2.2f%), $lines lines (%2.2f%), %d files\n",
      100*$cppcmdcount{"define"}/$lines, 100*($cpp_cmds - $cppcmdcount{"define"})/$lines,
      100*($cpp_cmds)/$lines, $#ARGV+1;
      printf STATS "EVILSTATS: $cObsoleted obsoleted (%2.2f%), $cDanger dangerous (%2.2f%), $cEvil evil (%2.2f%), $cIllegal illegal (%2.2f%)\n",
      pct($cObsoleted), pct($cDanger), pct($cEvil), pct($cIllegal);

      # Show categorization
      print STATS "CATEGORIZATION:";
      my $catname;
      foreach $catname (@categoryname)
	{ print STATS "\t$catname"; }
      print STATS "\n";
      print STATS "CATEGORIZATION#:";
      # Need to count up total numbers for each categorization.
      # print STATS "CATEGORIZATION: $cppcmdcount{"define"} $cNullDefine $cPreventMI $cSimpleConstant $cSimpleConstantWithDefault $cSimpleStrConstant $cCastedConstant $cSimpleExpression $cWithNullArgs $cWithArgs $cUncategorized\n";
      print STATS "\n";
      print STATS "CATEGORIZATION%:";
      # Need to count up percentages for each categorization.
      #     printf STATS "CATEGORIZATION%: %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f\n",
      #     pct($cppcmdcount{"define"}),pct($cNullDefine),pct($cPreventMI),pct($cSimpleConstant),
      #     pct($cSimpleConstantWithDefault),pct($cSimpleStrConstant),pct($cCastedConstant),
      #     pct($cSimpleExpression),pct($cWithNullArgs),pct($cWithArgs),pct($cUncategorized);
      print STATS "\n";
    }

    # -D = dump the defines
    if ($opt_D) {
      my $name;
      foreach $name (keys %macros) {
	# Could also print number of times it's defined.
	print DEFINES "$name\n";
      }
    }
  }
}

# pct(x) returns a percentage of macros defined
sub pct {
  my ($x) = $_[0];
  if (!defined($x))
    { return; }
  if ($x < 0 || $x > $cppcmdcount{"define"}) {
    print STDERR "Percentage out of range: $x / $cppcmdcount{'define'}\n";
  }
  return (100*$x/$cppcmdcount{"define"});
}

sub test_typedecl_regexp
{
  foreach $file (@ARGV)
    { if ($opt_v)
	{ print STDERR $file . "\n"; }
      open(INPUT,$file) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$file} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      while ($line = getline())
	{ if ($line =~ /^$typespecifier/o)
	    { print "ts: <<$&>> $line"; }
	  if ($line =~ /^$typedeclarator/o)
	    { print "td: <<$&>> $line"; }
	  if ($line =~ /^$typedeclarator\s*[,=;\(]/o)
	    { print "td+: $line"; }
	}
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      close(INPUT);
    }
}



###########################################################################
### Parsing
###

# Uses globals $getline_nocomment and $getline_simplify.
#   If $getline_nocomment is set, then comments are stripped from result.
#   If $getline_simplify is set, then character and string literals are
#     replaced by 'a' and "", respe respectively.  That lets us do a simple
#     syntactic check for parens, braces, commas, etc., obviating the need
#     for has_token, which redoes all this work anyway.
# If calls to ungetline have been made, those strings are returned (uses
#   global @getline_ungotlines), without any processing of comments or
#   literals, but with macro preprocessor command processing.  peekline
#   avoids macro preprocessor command processing by setting $getline_nocpp.
# To simplify an arbitrary string, use updateinvars.

# Read the next logical line from <INPUT>, until no continuation char
#   and not in string or comment.
# Result ends with newline.
# With argument, doesn't pop (actually, shift) from getline_ungotlines.
sub getline
{ my ($dont_pop) = @_;
  if (!defined($dont_pop))
    { $dont_pop = $false; }

  if ($instring || $incomment)
    { die "Bad instring $instring or incomment $incomment"; }

  my $result;
  if ((@getline_ungotlines > 0) && (!$dont_pop))
    { # print "popping getline_ungotlines $getline_ungotlines[$#getline_ungotlines]"; # no newline: it ends with one
      # print "all ungotlines: <<", join(">><<", @getline_ungotlines), ">>\n";
      #gd# @dependenton = shift(@getline_ungotdependenton);
      #gd# return shift(@getline_ungotlines);
      $result = shift(@getline_ungotlines);
    }
  else
    { if (not ($result = <INPUT>))
	{ return $result; }
      $lines++;

      $result = updateinvars($result);
      # perhaps check for $mname and mention it in message if it's set
      while ($incomment || $instring || ($result =~ m/\\$/))
	{
	  # splice lines
	  while ($result =~ m/\\$/)
	    {			# block to localize match data
	      { if ($result =~ m/\\\Z(?!\n)/) # backslash, end of string, no newline
		  { print EVIL "$file:$.: evil: file ends with backslash (no newline)\n"; } }
	      $result = $`;	# remove backslash and possibly newline
	      my $nextline;
	      if ($nextline = <INPUT>)
		{ $nextline = updateinvars($nextline);
		  $result = appendlines($result, $nextline);
		  # The appendlines trims trailing spaces, prettying the message.
		  if ($nextline =~ m/^\s*$/)
		    {		# No \n at end: $result ends in a newline
		      print EVIL "$file:$.: dangerous: blank line follows continuation character:\n    $result"; }
		}
	      else
		# Already removed backslash and newline from result.
		# (Should I add them back?)
		{ print EVIL "$file:$.: dangerous: file ends with continuation character:\n    $result\n"; } }

	  while ($incomment)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $lines++;
		  $nextline = updateinvars($nextline);
		  $result = appendlines($result, $nextline); }
	      else
		{ print EVIL "$file:$.: dangerous: file ends in comment:\n    $result";
		  $incomment = 0; } }

	  # Not "while ($instring) ..." because processing continuation lines
	  # takes priority over simple concatenation.
	  if ($instring)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $lines++;
		  $nextline = updateinvars($nextline);
		  # Strict ANSI C does not permit newlines in string constants;
		  # perhaps warn.
		  # Not "$result = appendlines($result, $nextline);" because in string.
		  $result = $result . $nextline;
		}
	      else
		{ print EVIL "$file:$.: dangerous: file ends in string:\n    $result\n";
		  $instring = 0; } }
	} }

  if (($result =~ /^\#/) && !$getline_nocpp)
    { # Preprocessor line
      getline_handle_preprocessor_line($result);
      # Return empty line
      return "\n"; }

  if ($result eq "")
    { die "empty getline result"; }
  # print "getline returning <<$result>>\n"; # $result ends in newline
  $result;
}

# Users shouldn't use this, because they won't be able to correctly set
# getline_ungotdependenton.
# sub ungetline
# {
#   my ($ungotline) = @_;
#   push (@getline_ungotlines, $ungotline);
# }

#gd# This clever saving and restoring of @dependenton is neat and all that, but
#gd# perhaps misguided.  Instead, change the contract of peekline to never do
#gd# any preprocessor processing, and have getline do it when the line is gotten
#gd# for real.
sub peekline
{
  my ($arg) = @_;
  if (!defined($arg))
    { $arg = 1; }

  #gd# if (@getline_ungotlines != @getline_ungotdependenton)
  #gd#   { die "different lengths for ungot{lines,dependenton} " . scalar(@getline_ungotlines) . " @getline_ungotlines ||| " . scalar(@getline_ungotdependenton) . " @getline_ungotdependenton"; }

  if ($arg <= @getline_ungotlines)
    { # We have previously peeked at the line in question
      my $index = @getline_ungotlines-$arg;
      #gd#       return($getline_ungotlines[$index], $getline_ungotdependenton[$index]);
      return($getline_ungotlines[$index]); }
  else
    { if ($arg < (@getline_ungotlines + 1))
	{ # Recursively fill up the arrays
	  # Actually, this should never happen:  why  would one look two
	  # lines ahead before checking the next line?
	  die "Why look far ahead when you haven't looked near?  $arg " . scalar(@getline_ungotlines);
	  peekline($arg-1); }
      if ($arg != (@getline_ungotlines + 1))
	{ die "This can't happen"; }

      # Do the real work.
      #gd# local @dependenton = @dependenton; # tricky!
      #gd# if (@getline_ungotdependenton == 0)
      #gd#   { @dependenton = $getline_ungotdependenton[$#getline_ungotdependenton]; }
      my $nextline;
      { local $getline_nocpp = $true;
	# print "peeking about to call getline\n";
	$nextline = getline("don't pop"); }
      # print "peeking found $nextline";
      #gd# $getline_ungotdependenton[$#getline_ungotdependenton+1] = @dependenton;
      push (@getline_ungotlines, $nextline);
      #gd# return($nextline, @dependenton);
      # print "peekline($arg) returning $nextline";
      return($nextline); }
}


# takes a simplified line as its argument; returns the number of open
# braces less the number of close braces.  could count parens, too...
sub bracechange
{ my ($line) = @_;
  # print "bracechange $line";
  my $result = 0;
  while ($line =~ /[\{\}]/)
    { if ($& eq "\{")
	{ $result++; }
      elsif ($& eq "\}")
	{ $result--; }
      else
	{ die "What match? $&"; }
    $line = $'; }
  return $result;
}


# updateinvars exists for the purposes of getline, but may be called by others,
#	particularly to remove comments or simplify string/character literals.
# Obeys global variables $getline_nocomment and $getline_simplify; see their
#	documentation at getline.
# Result differs from input only if one of them is set.
# All backslash line continuations have already been processed.
sub updateinvars
{
  my ($remaining) = @_;
  my $result;
  my $computeresult = ($getline_nocomment || $getline_simplify);
  if ($computeresult)
    { $result = ""; }
  else
    { $result = $remaining; }

  # print "updateinvars ($computeresult) $remaining"; # $remaining ends w/newline
  while ($remaining)
    { if ($incomment)
	{ if ($remaining =~ /\*\//)
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $` . $&; }
	      $remaining = $';
	      $incomment = 0; }
	  else
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $remaining; }
	      return $result; } }
      elsif ($instring)
	{ # print "in string, processing $remaining";
	  if ($remaining =~ m/$nonescdquote/o)
	    # Found a non-escaped double quote
	    { # print "non-escaped double quote: $result|$remaining|$`|$&|$'\n";
	      if ($computeresult)
		{ if ($getline_simplify)
		    { $result .= "\""; }
		  else
		    { $result .= $` . $&; } }
	      # print "post-nonescdquote: $result|$remaining\n";
	      $remaining = $';
	      $instring = 0; }
	  else
	    { # print "$file:$.: in string after line $_[0]";
	      if ($computeresult && !$getline_simplify)
		{ $result .= $` . $&; }
	      return $result; } }
      # If not instring, \" suffices instead of the more complicated
      # regexp that checks for leading backslashes.
      elsif ($remaining =~ m/\/[\*\/]|[\'\"]/) #'FIXCOLOR
	{ my $match = $&;
	  my $postmatch = $';
	  if ($computeresult)
	    { $result .= $`; }
	  if ($match eq "\'")
	    { if ($postmatch =~ m/^$charlitcontents\'/o)
		{ if ($computeresult)
		    { if ($getline_simplify)
			{ $result .= "'a'"; }
		      else
			{ $result .= "'" . $&; } }
		  $remaining = $'; }
	      else
                # No newline, since $_[0] has one.
		{ print EVIL "$file:$.: bad character constant $match$postmatch\n    in $_[0]";
		  if ($postmatch =~ /\'/)
		    { if ($computeresult)
			{ if ($getline_simplify)
			    { $result .= "'a'"; }
			  else
			    { $result .= "'" . $&; } }
		      $remaining = $'; }
		  else
		    { $remaining = $postmatch; } } }
	  elsif ($match eq "\"")
	    { if ($computeresult)
		{ $result .= $match; }
	      $remaining = $';
	      $instring = 1; }
	  elsif ($match eq "//")
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      return $result; }
	  elsif ($match eq "/*")
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      $remaining = $';
	      $incomment = 1; }
	  else
	    { die "$file:$.: updateinvars: what match?  $match in $_[0]\n"; } }
      else
	{ if ($computeresult)
	    { $result .= $remaining; }
	  return $result; }
    }
}

# All backslash line continuations have already been processed; no
# nonterminated strings, comments, or character constants.
# Result does NOT end in newline
sub remove_comments
{
  my ($input) = @_;
  local $getline_nocomment = $true;
  local $getline_simplify = $false;
  my $result = updateinvars($input);
  if ($instring || $incomment)
    { die "Bad string passed to remove_comments: instring $instring incomment $incomment"; }
  return $result;
}


# This isn't needed any longer, because a simplified string has no
# comments, strings, or character literals to confuse a simplistic check.
# (Don't remove it yet, though, just in case we need it later.)
# # Assumes no comments
# sub has_token
# {
#   my ($token, $line) = @_;
#   if (!defined($token)) { die "undefined token, line $line\n"; }
#   if (!defined($line)) { die "undefined line, token $token\n"; }
# 
#   # Check for character constants to avoid processing " in one.
# 
#   # If not instring, I think \" suffices instead of the more complicated
#   # regexp that checks for leading backslashes.
#   while (($line =~ m/[\"\']/) #'FIXCOLOR
# 	 # should regexp-quote $token
# 	 || ($line =~ m/\Q$token\E/))
#     { my $match = $&;
#       $line = $';
#       print "has_token($token) matched $match before $line\n";
#       if ($match eq $token)
# 	{ return $true; }
#       elsif ($match eq "\"")
# 	{ if ($line =~ /$nonescdquote/o)
# 	    { $line = $'; }
# 	  else
# 	    { die "Didn't find end of string literal $line.\n"; } }
#       elsif ($match eq "'")
# 	{ if ($line =~ /$charlitcontents\'/o)
# 	    { $line = $'; }
# 	  else
# 	    { die "Didn't find end of character literal $line.\n"; } }
#       else
# 	{ die "What match $match in $line\n"; } }
#   return $false;
# }


sub getline_handle_preprocessor_line
{
  my ($line) = @_;
  if ($line =~ /^\#\s*$/)
    { # null preprocessor command; do nothing
    }
  # Maybe also check for (0 === 1), or macro that
  # always expands to 0; but that is probably overkill.
  elsif ($line =~ /^\#\s*ifdef\s+(0|\(0\))\s*$/)
    { discard_to_endif(); }
  elsif ($line =~ m/^\#\s*$identregexp\s*/o)
    { # Found a real preprocessor command
      my $cpp_cmd = $1;
      $line = $';
      $line =~ s/\s+$//;	# remove trailing whitespace
      getline_handle_preprocessor_command($cpp_cmd, $line); }
  else
    { die "Strange preprocessor line $line"; } }

# This is a catchall for everything that has to be done to a preprocessor line.
# It's a bit gross to do it this way, but it seems most expedient.
# Always do:
#  * set @dependenton
# Sometimes do:
#  * if $finding_macro_defs, then in first pass, so
#      for each use of the preprocessor, set $cppcmdcount
#      for each #define, call process_macro_definition
#  * if $getting_macro_call_types, then in second pass, so
# Control the action via the following variables: ...
sub getline_handle_preprocessor_command
{
  # $cpp_cmd and $cpp_cmd_arg contain no leading or trailing space.
  my ($cpp_cmd, $cpp_cmd_arg) = @_;
  # print "getline_handle_preprocessor_command <<$cpp_cmd>> <<$cpp_cmd_arg>>\n";

  if ($finding_macro_defs)
    { # Perhaps keep a list of each use, with line numbers (could help when
      # determining if it is a preventMI).
      $cppcmdcount{$cpp_cmd}++;
      $cpp_cmds++;
    }

  if ($cpp_cmd eq "if")
    { push(@dependenton, $cpp_cmd_arg);
      # print "if $. $cpp_cmd_arg; now dependent on @dependenton\n";
      $brace_unbalanced_if = check_for_braceunbalanced_if();
    }
  elsif ($cpp_cmd eq "ifdef")
    { push(@dependenton, "defined($cpp_cmd_arg)");
      # print "ifdef $. $cpp_cmd_arg; now dependent on @dependenton\n";
      $brace_unbalanced_if = check_for_braceunbalanced_if();
    }
  elsif ($cpp_cmd eq "ifndef")
    { push(@dependenton, "!defined($cpp_cmd_arg)");
      # print "ifndef $. $cpp_cmd_arg; now dependent on @dependenton\n";
      $brace_unbalanced_if = check_for_braceunbalanced_if();
    }
  elsif ($cpp_cmd eq "endif")
    { if (@dependenton == 0)
	{ die "improperly nested \#endif"; }
      # print "endif $. $dependenton[$#dependenton]; ";
      pop(@dependenton);
      # print "now dependent on @dependenton.\n";
    }
  elsif ($cpp_cmd eq "else")
    { if (@dependenton == 0)
	{ die "improperly nested \#else"; }
      my $last = pop(@dependenton);
      push(@dependenton, "!($last)"); }
  elsif ($cpp_cmd eq "elif")
    { if (@dependenton == 0)
	{ die "improperly nested \#elif"; }
      my $last = pop(@dependenton);
      push(@dependenton, "(!($last)) && ($cpp_cmd_arg)"); }
  elsif ($cpp_cmd eq "define")
    { if ($finding_macro_defs)
	{ process_macro_definition($cpp_cmd_arg); }
    }
  elsif ($cpp_cmd eq "include")
    { # handle #include
    }
  elsif ($cpp_cmd eq "undef")
    { # handle #undef
    }
  else
    { # Some other cpp command
      print "unhandled cpp command \#$cpp_cmd $cpp_cmd_arg\n";
    }
}


# Read and discard lines until we find the matching #endif
# No return value.
sub discard_to_endif
{ my $if0depth = 1;
  my $line;
  while ($if0depth > 0)
    { if (not ($line = <INPUT>))
	{ die "File ends in \#ifdef 0"; }
      $lines++;
      # I'll trust that no comment or string contains anything that
      # looks like a preprocessor command.  Strictly speaking, I should
      # use getline and/or updateinvars, because anything in an #ifdef
      # is supposed to be a sequence of valid tokens, but #ifdef 0 often
      # contains non-syntactic constructs.  (Maybe eventually use
      # getline/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($line =~ m/^\#\s*if(n?def)\b/o)
	{ $if0depth++; }
      elsif ($line =~ m/^\#\s*endif\b/o)
	{ $if0depth--; } }
}

# We just saw a #if.  If the following lines are:
#   * brace-unbalanced
#   * #else
#   * brace-unbalanced (in the same way)
#   * #endif
# then return $true.

# Need to also permit #elsif and #else #if, and support multiple parts
# (can return the number of such as the result; 0 means none).

# It would be better to check not just single lines, but everything to the
# matching #else.
# Pro: catch more cases.
# Con: how many more?
#      harder to communicate to client how many pieces and how many lines make
#      	   up each piece (not really: just an array)
#      don't want to fill up array with big containers (so throttle it at
#	   just a few lines, for that's most likely to have biggest benefit
#	   anyway

sub check_for_braceunbalanced_if
{ my @line;
  my @braces;
  $line[1] = peekline(1);
  if (!is_cpp_command($line[1]))
    { $braces[1] = bracechange($line[1]);
      if ($braces[1] != 0)
	{ $line[2] = peekline(2);
	  # print "bracechange = $braces[1]; line2 = $line[2]"; # line2 has a newline
	  if ($line[2] =~ /^\#\s*else\b/)
	    { $line[3] = peekline(3);
	      if (!is_cpp_command($line[3]))
		{ $braces[3] = bracechange($line[3]);
		  if ($braces[1] == $braces[3])
		    { $line[4] = peekline(4);
		      if ($line[4] =~ /^\#\s*endif\b/)
			{ return $true; } } } } } }
  return $false;
}

sub merge_brace_unbalanced_lines
{ my ($line1, $line2) = @_;
  my $result = "";

  while ($true)
    { my ($match1, $prematch1, $match2, $prematch2);
      if ($line1 =~ /[\{\}]/)
	{ $prematch1 = $`;
	  $match1 = $&;
	  $line1 = $'; }
      if ($line2 =~ /[\{\}]/)
	{ $prematch2 = $`;
	  $match2 = $&;
	  $line2 = $'; }

      if (defined($match1) && defined($match2) && ($match1 eq $match2))
	{ $result .= " $prematch1 $prematch2 $match1"; }
      elsif ((!defined($match1)) && (!defined($match2)))
	{ return $result . " $line1 $line2"; }
      else
	{ die "Similarly unbalanced lines aren't identically unbalanced ||$prematch1$match1$line1||$prematch2$match2$line2||"; }
    }
}



sub is_cpp_command
{ my ($line) = @_;
  $line =~ /^\#/;
}

# Watch out: this removes the trailing newline.
sub trim_whitespace
{
  my ($result) = @_;
  $result =~ s/^\s+//;
  $result =~ s/\s+$//;
  # if ($result =~ /^\s+(.*)$/) { $result = $1; }
  # # (.*)\s+ only gets rid of last space
  # if ($result =~ /^(.*[^\s])\s+$/) { $result = $1; }
  return $result;
}


# This pretties things up but changes contents of line-spanning strings,
# so don't call it if ARG1 ends inside a string.
sub appendlines
{
  my ($arg1, $arg2) = @_;
  # "+", not "*", so don't introduce spaces where there were none before
  # Do I need \Z instead of $?  It seems I don't...
  $arg1 =~ s/[ \t\n]+$/ /;
  $arg2 =~ s/^[ \t\n]+/ /;
  $arg1 . $arg2;
}

# Return an array of three elements: name, args, def.
# None have leading or trailing whitespace
sub macroparse
{ if (@_ != 1) { die "Wrong number of arguments to macrobody."; }
  my ($line) = @_;
  # print "macroparse $_[0]\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($line =~ m/^(\w+)(\([^\)]*\))?\s*(.*)\s*$/);
  if ($#result != 2)		# ($# == 2) => 3 elements
    { die "Problem parsing macro `$line'\n"; }
  @result;
}


# Recursive descent?  Something simpler?
#   exp = (exp) | num | var | exp op exp     -- no functions
# To tokenize, just split at word beginning and end and at number beginning
# 	and end (which may be a bit tricky to tease apart from operator, with
#	leading +/-, but standard says literals have no leading sign -- it's
#       a unary operator).


# Side-effects %parsevars, %parsefuns, %parsetypes

# Arguments: string
# Returns: type (or 0 if unsuccessful parse)
#          remaining string?
# Side-effects: @parsevars, @parsefuns, @parsetypes

# Should check @parsexxxs for reserved words; if we find any, I misparsed.

sub parse_expression
{
  my ($exp) = $_[0];
  # Could use undef instead...
  @parsevars = ();
  @parsefuns = ();
  @parsetypes = ();
  # print "parse_expression $exp\n";
  my ($type, $remaining) = parse_exp(remove_comments($exp));
  # print "parse_expression $remaining\n";
  if ($remaining =~ /^\s*$/)
    { return $type; }
  else
    { return $typeFAIL; }
}


sub parse_exp_nocommaop
{
  my ($exp, $ignoretypes) = @_;
  local $commaop = $false;
  return parse_exp($exp, $ignoretypes);
}

sub parse_exp_commaop
{
  my ($exp, $ignoretypes) = @_;
  local $commaop = $true;
  return parse_exp($exp, $ignoretypes);
}


# Takes a
# Like parse_expression, but doesn't reset @parsexxxs.
# Returns two values:  the expression's type and the remaining string.
# Every call should be followed by   "if (!$type) { return($typeFAIL,$exp); }"
# See H&S p. 181.
sub parse_exp
{
  my ($exp, $ignoretypes) = @_;
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  # If ignoretypes is set, then we don't try to infer types, look up types
  # of unknown functions, or set symbol tables.  We do still compute types
  # for literals and return a type, I think.

  # Perhaps remember length of @parsexxxs, so we can restore them if failure.
  # But right now we never fail unless everything fails, so never mind...

  # First, cope with open parens

  # Cast
  if ($exp =~ /^\s*\(\s*($fullbuiltintype)\s*\)/)
    { # print "Found cast $1\n";
      my ($casttype) = $1;
      my ($type, $remaining) = parse_exp($');
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower(type_to_num($casttype),$remaining); }
  # ($exp =~ /^\s*\(\(\s*$typeregexp\s*\)\s*(.*)\)/ && FIsNumConst($3))
  # Type in parens followed by (what looks like) paren, number, or identifier
  if ($exp =~ /^\s*\(\s*$typeregexp\s*\)\s*([0-9a-z\(])/)
    { my ($casttype) = $1;
      push(@parsetypes, $casttype);
      # print "Found cast $1 $5\n";
      my ($type, $remaining) = parse_exp($5 . $');
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($casttype,$remaining); }

  # Parens as grouping
  if ($exp =~ m/^\s*\(/)
    { my ($type, $remaining) = parse_exp_commaop($');
      if (!$type) { return($typeFAIL,$exp); }
      if ($remaining =~ m/^\s*\)/)
	{ return parse_exp_follower($type, $'); }
      else
	{ return($typeFAIL,$exp); } }

  # Unary prefix operators
  if ($exp =~ /^\s*(\+\+|--|[-~!+&*])/)
    { my ($type, $remaining) = parse_exp($');
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($type,$remaining); }
  # [^\)] was [ \ta-zA-Z0-9*]
  if ($exp =~ /^\s*sizeof\s*\(\s*([^\)]+)\)/)
    { my $sizeoftype = $1;
      $sizeoftype =~ s/\s+$//;
      my $remaining = $';
      if (!($sizeoftype =~ /^$typeregexp$/o))
	{ die "sizeof($sizeoftype) doesn't look like a type.\n"; }
      return parse_exp_follower(type_to_num($sizeoftype),$remaining); }

  # Literals
  $exp =~ s/^\s+//;		# remove leading space

  # Literal string
  if ($exp =~ /^$stringlitregexp/)
    # String contains no non-escaped double-quote
    # Should look for a following string, to concatenate the two.
    # Perhaps special-case:  look for symbol (which is macro with typeSTRING)
    # or literal string.
    { return ($typeSTRING, $'); }

  # Literal character
  if ($exp =~ /^$charlit/o)
    { return parse_exp_follower($typeCHAR, $'); }

  # Literal floating-point
  # This precedes integer because an integer matches the first part of a float
  if (($exp =~ /^$floatlitwhole/o)
      || ($exp =~ /^$floatlitfrac/o))
    { my ($type) = $typeDOUBLE;
      if (($2 eq "f") || ($2 eq "F"))
	{ $type = $typeFLOAT; }
      elsif (($2 eq "l") || ($2 eq "L"))
	{ $type = $typeLDOUBLE; }
      return parse_exp_follower($type,$'); }

  # Literal integer (octal)
  # Don't need leading [-+]? because they are always unary operators, never
  # part of the literal itself.
  if (($exp =~ /^$hexlitregexp/o)  # hex (regexp failed with \d for 0-9)
      # hex precedes octal/decimal because the "0" looks like a leading integer
      || ($exp =~ /^$decoctlitregexp/o)) # octal or decimal
    { # print "Found integer $1\n";
      my ($remaining) = $';
      my ($type) = infer_int_type($1);
      # print "inferred type ", type_name($type), "\n";
      if ($2 =~ /[uU]/)
	{ $type = type_unsigned($type); }
      if ($2 =~ /[lL]/)
	{ $type = type_long($type); }
      # print "parse_exp_follower($type,$remaining)\n";
      return parse_exp_follower($type,$remaining); }

  # Variable
  elsif ($exp =~ /^$identregexp/o)
    { my ($var) = $1;
      my ($remaining) = $';
      categorizeMacroName($var);
      my $vartype = $mntype{$var};
      if (!defined($vartype))
	# Need to do a MUCH better job here; in particular, infer a type.
	# Perhaps return a negative number, an index into a list of things
	# whose types need to be inferred.
	{ $vartype = $typeUNKNOWN; }
      # Perhaps do something different if the categorization was successful.
      if ($remaining =~ /^\s*\(/)
	{ push(@parsefuns, $var);
	  return parse_arglist($vartype, $');
	}
      else
	{ push(@parsevars, $var);
	  return parse_exp_follower($vartype, $remaining); }
    }
  else
    { # print "Couldn't match $exp\n";
      return ($typeFAIL, $exp); }
}


# $arglist already has leading paren stripped.
sub parse_arglist
{
  my ($ftype, $arglist) = @_;

  # Need a notation for function types; maybe just -> in front.
  while (!($arglist =~ /^\s*\)/))
    { my ($thisargtype, $comma) = parse_exp_nocommaop($arglist);
      if (!$thisargtype) { return($typeFAIL, $arglist); }
      # push $thisargtype somewhere
      if ($comma =~ /^\s*,/)
	{ $arglist = $'; }
      elsif ($comma =~ /^\s*\)/)
	{ $arglist = $comma; }
      else
	{ die "Neither comma nor close paren followed well-formed arg $arglist\n";
	  return($typeFAIL, $exp); } }
  return parse_exp_follower($ftype,$');
}

# $initializer already has leading brace stripped
sub parse_array_initializer
{
  my ($initlist) = @_;

  # print "parse_array_initializer $initlist"; # $initlist ends in newline

  while (!($initlist =~ /^\s*\}/))
    { my ($thisinittype, $comma);
      # print "current initlist = $initlist"; # $initlist ends in newline
      if ($initlist =~ /^\s*\{/)
	{ ($thisinittype, $comma) = parse_array_initializer($');
	  # transform subinittype from array to scalar type
	}
      else
	{ ($thisinittype, $comma) = parse_exp_nocommaop($initlist);
	  # print "parse_exp_nocommaop returned ($thisinittype) $comma\n";
	}
      if (!$thisinittype) { return($typeFAIL, $initlist); }
      # push $thisinittype somewhere
      if ($comma =~ /^\s*,/)
	{ $initlist = $'; }
      elsif ($comma =~ /^\s*\}/)
	{ return ($thisinittype, $'); }
      else
	{ die "Neither comma nor close brace followed well-formed init $initlist\n";
	  return($typeFAIL, $exp); } }
  # don't call parse_exp_follower
  return ($typeUNKNOWN,$');
}

# Side-effects the global arrays @argnames @argtypes
# Returns a success boolean, and the post-closeparen string
sub parse_function_decl_args
{
  my ($argdecls) = @_;
  my $remaining = $argdecls;
  @argnames = ();
  @argtypes = ();

  while (!($argdecls =~ /^\)/))
    { my $remaining = $argdecls;
      # print "parsing next arg decl in $argdecls\n";
      while (!($remaining =~ /^\s*[,\)]/))
	{ my ($thisargtype, $stillremaining) = parse_exp_nocommaop($remaining, "ignore types");
	  if ($stillremaining eq $remaining)
	    { print "defined macros:";
	      for $macro (sort keys %macros)
		{ print " ", $macro; }
	      print "\n";
	      die "Didn't find arg decl in $remaining"; }
	  if (!$thisargtype)
	    { die "Parse failed; shouldn't get to here.\n";
	      # The parse failed; this wasn't a function declaration after all
	      # Try again starting after the first close paren.
	      if ($remaining =~ /\)/)
		{ $remaining = $'; }
	      else
		{ $remaining = ""; }
	      return ($false, $remaining); }
	  $remaining = $stillremaining; }
      # Now $remaining is $argdecls less the argument
      # thisdecl has no leading or trailing whitespace
      my $thisdecl = substr($argdecls,0,length($argdecls)-length($remaining));
      if ($thisdecl =~ /^\s*$/)
	{ die "Didn't find a function decl arg in $remaining\n"; }
      # print "parsing function arg declarator $thisdecl\n";
      if ($thisdecl =~ /^$identregexp$/o)
	{ push(@argnames, $thisdecl);
	  push(@argtypes, $typeUNSPECIFIED); }
      elsif ($thisdecl =~ /^$typedeclarator$/o)
	{ my $typespec = $1;
	  my $ptrdecls = $3;
	  my $identifier = $6;
	  my $arraydecls = $7;
	  push(@argnames, $identifier);
	  push(@argtypes, $typespec . $ptrdecls . $arraydecls); }
      else
	{ die "Couldn't parse function arg declarator $thisdecl\n"; }
      if ($remaining =~ /^\s*,/)
	{ $remaining = $'; }
      $argdecls = $remaining;
      $argdecls =~ s/^\s+//;	# remove leading whitespace
    }
  # print "match: $`|$&|$'\n";
  if (!defined($'))
    { die "postmatch not defined.\n"; }
  my $postmatch = $';
  if (!defined($postmatch))
    { die "postmatch not defined.\n"; }
  return ($true, $');
}

# Side effects global %argnametype;
# Return an associative array of names to types and the remaining string
# after the open brace.
sub parse_KandR_function_arg_decls
{
  my ($argdecls) = @_;
  %argnametype = ();
  while (!($argdecls =~ /^\s*\{/))
    { # print "parsing K&R function arg decls $argdecls\n";
      if (!($argdecls =~ /^\s*$typedeclarator\s*([,;])/))
	{ die "Couldn't parse K&R-style type declarator $argdecls\n"; }
      my $typespec = $1;
      if (!(defined($typespec))) { die "undefined typespec for $argdecls"; }
      my $ptrdecls = $3;
      if (!(defined($ptrdecls))) { $ptrdecls = ""; }
      my $arraydecls = $7;
      if (!(defined($arraydecls))) { $arraydecls = ""; }
      my $identifier = $6;
      if (!(defined($identifier))) { die "undefined identifier for $argdecls"; }
      my $nextchar = $9;
      if (!(defined($nextchar))) { die "undefined nextchar for $argdecls"; }
      $argdecls = $';
      $argnametype{$identifier} = $typespec . $ptrdecls . $arraydecls;
      while ($nextchar eq ",")
	{ if (!($argdecls =~ /^\s*$declarator\s*([,;])/))
	    { die "Couldn't parse declarator following comma after '$typespec $ptrdecl $identifier $arraydecl $nextchar': $argdecls\n"; }
	  $ptrdecl = $1;
	  $identifier = $4;
	  $arraydecl = $5;
	  $nextchar = $7;
	  $argdecls = $';
	  $argnametype{$identifier} = $typespec . $ptrdecls . $arraydecls; } }
  # print "after K&R, remainder $'\n";
  return $';
}


sub parse_exp_follower
{
  my ($type, $follow) = @_;
  $follow =~ s/^\s+//;		# remove leading space

  if (!defined($type)) { die "type undefined $follow\n"; }

  # Should this be eq to avoid failing when $type is a string?
  if ($type eq $typeFAIL)
    # This isn't quite right since the failure occurred earlier.
    # Perhaps die in this case instead.
    { return($type, $follow); }

  # Array subscript
  if ($follow =~ /^\[/)
    { my $subscript = $';
      my ($subscrtype, $closebracket) = parse_exp($subscript);
      if (!$subscrtype) { return($typeFAIL,$exp); }
      if (!(type_integral_p($subscrtype) || ($subscrtype == $typeUNKNOWN)))
	# This shouldn't happen; perhaps die instead.
	{ die "Non-integral type ", type_name($subscrtype), " in subscript\n";
	  return ($typeFAIL, $follow); }
      if ($closebracket =~ /\s*\]/)
	{ my ($remaining) = $';
	  return parse_exp_follower(type_dereference($type), $remaining); }
      else
	{ return ($typeFAIL, $follow); } }

  # Function call (might this be some other use of parens??)
  if ($follow =~ /^\(/)
    { return parse_arglist($type, $'); }

  # Unary postfix operators
  if ($follow =~ /^(\+\+|--)/)
    { return parse_exp_follower($type, $'); }
  # Structure selectors
  if ($follow =~ /^\s*(\.|->)\w+\b/)
    { return parse_exp_follower($typeUNKNOWN, $'); }

  # Binary operators:  multi-char operators must precede single-char ones
  if (($follow =~ /^(<<|>>|[<=>!]=|&&|\|\||[-*\/%+&^|<>])/)
      || ($commaop && ($follow =~ /^(,)/)))
    { my $op = $1;
      my $arg2 = $';
      if ($op eq ",")
	{ # print "found a comma operator, commaop = $commaop\n";
	}
      my ($type2, $remaining) = parse_exp($arg2);
      if (!$type2) { return ($typeFAIL, $arg2); }
      if (bool_op_p($op))
	{ return parse_exp_follower($typeBOOL, $remaining); }
      elsif ($op eq ",")
	{ return parse_exp_follower($type2, $remaining); }
      else
	{ return parse_exp_follower(type_lub($type, $type2), $remaining); } }

  # Ternary operator ?:
  if ($follow =~ /^\?/)
    { my $then = $';
      my ($thentype, $colon) = parse_exp($then);
      if (!$thentype) { return ($typeFAIL, $then); }
      if (!($colon =~ /^\s*:/)) { return ($typeFAIL, $colon); }
      my ($elsetype, $remaining) = parse_exp($');
      if (!$elsetype) { return ($typeFAIL, $colon); }
      return (type_lub($thentype, $elsetype), $remaining); }

  return ($type, $follow);
}

sub bool_op_p
{
  my ($op) = @_;
  return ($op =~ /[<=>!]=|&&|\|\||<|>/);
}


# More involved non-recursive version.
# # This fails for:
# #  * array subscript []
# #  * function call through pointer (*foo)(3)
# #  * ternary operators: ?:
# #  * assignment (intentionally; would have to keep track of lhs or use ref vars)
# #	= + - * / % << >> & ^ |
# It would probably be better to write this recursively...
# # Side-effects %parsevars, %parsefuns, %parsetypes
# # return an array of free variables;
# # also maybe how many characters were read (or current input pos)
# # Should check the array for reserved words; if we find any, I misparsed.
# # 0 if not an expression, otherwise list of variables
# # Doesn't check types.
# sub parse_expression
# {
#   # get-expression =
#   #   if looking at paren,
#   #     get paren, get-expression, get paren
#   #   else get num or var
#   #   while looking at op,
#   #     get op, get-expression
#   my ($remaining) = $_[0];
#   my ($parens) = 0;
#   # Could use undef instead...
#   %parsevars = ();
#   %parsefuns = ();
#   %parsetypes = ();
#   # print "parse_expression $remaining\n";
#   $remaining = remove_comments($remaining);
#   # print "parse_expression $remaining\n";
# 
#  EXPSTART:
#   # Open parens
#   # First, cope with casts
#   # print "expstart: $parens $remaining\n";
#   if ($remaining =~ /^\s*\(\((\w+)(\s+\**)?\)\s*(.*)\)/ && FIsNumConst($3))
#     { $remaining = $';
#       $parsetypes{$1} = 1;
#       # print "Found cast $1 $2 $3\n";
#       goto EXPDONE; }
#   if ($remaining =~ /^\s*\((\w+)(\s+\**)?\)\s*([0-9a-z\(])/)
#     { # print "found suspected cast $3$'\n";
#       $remaining = $3 . $';
#       $parsetypes{$1} = 1;
#       # print "Found cast $1 $2 $3\n";
#       goto EXPSTART; }
#   if ($remaining =~ /^\s*\(((short|signed|unsigned|long|int|char|float|double)\s*)\)/)
#     { $remaining = $';
#       goto EXPSTART; }
# 
#   if ($remaining =~ m/^\s*\(/)
#     { $parens++;
#       $remaining = $';
#       goto EXPSTART; }
# 
#   # Unary prefix operators
#   if ($remaining =~ /^\s*(\+\+|--|[~!\-+&*])/)
#     { $remaining = $';
#       goto EXPSTART; }
#   # Watch out: the type might be a macro argument.  Check it??
#   if ($remaining =~ /^\s*sizeof\s*\([ \ta-zA-Z0-9*]+\)/)
#     { $remaining = $';
#       goto EXPDONE; }
# 
#   # Variable or numeric literal
#   if ($remaining =~ /^\s+/) { $remaining = $'; }
#   # Check for number precedes word because digits are word constitutents
#   if ($remaining =~ /^-?\d+\.\d*/ || # decimal 2.
#       $remaining =~ /^-?\d*\.\d+/ || # fraction .2
#       $remaining =~ /^0x[0-9a-fA-F]+[ulUL]?/ ||   # hex (regexp failed with \d for 0-9)
#       $remaining =~ /^-?\d+[ulUL]?/ || # integer
#       $remaining =~ /^'(\\?.|\\[0-7][0-7][0-7])'/) # character
#     { $remaining = $'; }
#   elsif ($remaining =~ /^(\w+)\b/)
#     { my ($var) = $1;
#       $remaining = $';
#       if ($remaining =~ /^\s*\(/)
# 	{ $parsefuns{$var} = 1;
# 	  $remaining = $';
# 	  if ($remaining =~ /^\s*\)/)
# 	    { $remaining = $';
# 	      goto EXPDONE; }
# 	  else
# 	    { $parens++;
# 	      goto EXPSTART; } }
#       else
# 	{ $parsevars{$var} = 1; }
#       # print "Added $1; $remaining\n";
#       # print "Parsevars: ";
#       # foreach $var (keys(%parsevars)) { print $var . " "; }
#       # print '\n';
#     }
#   else
#     { # print "Couldn't match $remaining\n";
#       return $false; }
# 
#  EXPDONE:
#   # Close parens
#   while ($remaining =~ m/^\s*\)/)
#     { $parens--;
#       # print "decremented parens $parens\n";
#       if ($parens < 0)
# 	{ # print "negative parens\n";
# 	  return $false; }
#       $remaining = $'; }
#   # Unary postfix operators
#   if ($remaining =~ /^\s*(\+\+|--|(\.|->)\w+)/)
#     { $remaining = $';
#       goto EXPDONE; }
# 
#   # Binary operators:  multi-char operators must precede single-char ones
#   if ($remaining =~ /^\s*(<<|>>|[<=>!]=|&&|\|\||[*\/%+\-&^|,<>])/)
#     { $remaining = $';
#       goto EXPSTART; }
# 
#   # print "returning $parens '$remaining'\n";
#   return (($parens == 0) && ($remaining =~ /^\s*$/));
# }



# Non-recursive version
# sub parse_expression
# {
#   # get-expression =
#   #   if looking at paren,
#   #     get paren, get-expression, get paren
#   #   else get num or var
#   #   while looking at op,
#   #     get op, get-expression
#   my ($remaining) = $_[0];
#   my ($parens) = 0;
#   %parsevars = ();
#   while (!($remaining =~ /^\s*$/))
#     { # Open parens
#       while ($remaining =~ m/^\s*\(/)
# 	{ $parens++;
# 	  $remaining = $'; }
# 
#       # Variable or numeric literal
#       if ($remaining =~ /^\s+/) { $remaining = $'; }
#       if ($remaining =~ /^\w+\b/)
# 	{ $vars{$1} = 1;
# 	  $remaining = $'; }
#       elsif (($remaining =~ /^-?\d+\.?\d*/ || # decimal 2.
# 	      $remaining =~ /^-?\d*\.?\d+/ || # fraction .2
# 	      $remaining =~ /^0x[\d|a-f|A-F]+/ ||   # hex
# 	      $remaining =~ /^-?\d+[ulUL]/))
# 	{ $remaining = $'; }
#       else
# 	{ return $false; }
# 
#       # Close parens
#       while ($remaining =~ m/^\s*\(/)
# 	{ $parens--;
# 	  if ($parens < 0)
# 	    { return $false; }
# 	  $remaining = $'; }
# 
#       # Optional operator
#       if ($remaining =~ /^\s+/) { $remaining = $'; }
# 
#       # Postfix operators: (\.|->)\w+\b|
#       # 
# 
#       # Binary operators:
#       if ($remaining =~ /^([*/%+-&^|,<>]|<<|>>|[<=>!]=|&&|\|\|)
# 
# \s+/) { $remaining = $'; }
# 
# 
# 
#       (L|x|\d|\(|\s|\)|\<|\>|\+|\-|\=|\*|\||\&|\%|\!)*$/) {
# 
# 
#     }
#   return ($parens == 0);
# }

### Get types for macro calls

# This is a bit disappointing because it's so heuristic; my inclination is
# really to get it right rather than approximate.

# Find all uses of a macro, to determine types of its arguments.
# (If it isn't used, it can be eliminated -- this will be true of many in
# standard header files, perhaps.)
# Do a rough parse of each file:
#  recognize binding forms:
#     variable declarations, function definitions, function declarations
#     Can use etags to find function defintiions, but it doesn't find
#	global variables.
#  recognize function calls, check whether they are macros
# Cope with macro definitions like "#define local static" and with
#    typedefs like "typedef unsigned long  ulg;" (the latter not to use
#    the raw type, but to permit type_lub to do a better job, maybe).

sub get_macro_call_types
{
  local $getting_macro_call_types = $true;
  local $getline_nocomment = $true;
  local $getline_simplify = $true;
  # Perhaps should use %files instead of @ARGV
  print "ARGV @ARGV";
  foreach $file (@ARGV)
    { print "in ARGV: $file\n"; }
  foreach $file (@ARGV)
    { if ($opt_v)
	{ print STDERR "file $file\n"; }
      # open(INPUT,$file) or next; # skip to next file if open fails
      if (!open(INPUT,$file))
	{ print "failed to open $file\n";
	  next; }
      # Commented out to quiet compiler
      # $files{$file} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      # Perhaps I should use a variant of getline that insists that parens
      # are balanced, too; that might let me more reasonably cope with
      # breaks across lines.
      if ($symtab_scopes != 0)
	{ die "Bad brace depth $symtab_scopes.\n"; }
      my $line;
      while ($line = getline())
	{
GOTLINE:
	  # The line number $. isn't quite right, as we may have peeked ahead
	  # print "line $.: $line"; # no newline, since $line contains one
	  if ($line =~ /^\s*$/)
	    {			# empty line; possibly was originally a preprocessor command
	      if ($brace_unbalanced_if)
		{ my $line1 = getline();
		  getline();	# discard #else line
		  my $line2 = getline();
		  getline();	# discard #endif line
		  $line = merge_brace_unbalanced_lines($line1, $line2);
		  print "converted brace_unbalanced_if ||$line1||$line2||$line||\n";
		  $brace_unbalanced_if = $false;
		  ##  Forward jump seems to give trouble with the foreach
		  # # Skip the indentation test for this one
		  # goto PROCESSLINE;
		  goto GOTLINE;
		}
	    }
	  elsif ($line =~ m/^\#/o)
	    { die "getline shouldn't return preprocessor lines: $line"; }
	  else
	    {			# not empty or a preprocessor line
	      # print "not empty or a preprocessor line $line"; # $line has newline
	      chop($line);	# remove trailing newline
	      # In a scope, must be indented or: close brace, comment, label
	      if (($symtab_scopes != 0)
		  && (!($line =~ m/^(\s|\}|\/[\/\*]|$identregexp\s*:)/o)))
		# Perhaps permit labels to be non-indented.
		{ die "Non-indented line $line at bracedepth $symtab_scopes.\n"; }

	      # Look for:  typedef,
	      #   function definition/declaration (only at symtab_scopes == 0)
	      #   variable definition/declaration,
	      #   function call (of a macro),
	      #   brackets (to keep track of scopes),
	      #   string/char literals (to avoid catching too much).
	      # These can span multiple lines, especially function definitions.

PROCESSLINE:
	      if (!defined($line))
		{ die "PROCESSLINE: line undefined.\n"; }
	      # print "PROCESSLINE $line\n";
	      if ($line =~ /^\s*$/)
		{		# do nothing
		  # print "empty line $.\n";
		}
	      if ($line =~ /^\s*typedef\s+/)
		{		# process typedefs
		  print "typedef line $.\n";
		}
	      elsif (($line =~ /^$typespecifier\s*$/o)
		     # this call to peekline ignores the @dependenton argument
		     && (peekline() =~ /^$declarator\s*\(/o))
		{		# Function definition split over multiple lines
		  $line .= " " . getline();
		  goto PROCESSLINE; }
	      elsif (($line =~ /^\s*$typedeclarator\s*([,=;\(])/o)
 		     && ($1 ne "return") # "return foo;"
 		     && ($1 ne "else") # "else if (...)"
 		     # fail if the function is actually a macro
 		     && (!(($9 eq "(") && $macros{$6})))
		{
		  # print "matched typedeclarator <$1><$2><$3><$4><$5><$6><$7><$8><$9>\n";
		  my $basetype = $1;
		  if (!(defined($basetype))) { die "undefined basetype"; }
		  my $pointerdecls = $3;
		  if (!(defined($pointerdecls))) { $pointerdecls = ""; }
		  my $arraydecls = $7;
		  if (!(defined($arraydecls))) { $arraydecls = ""; }
		  my $identifier = $6;
		  if (!(defined($identifier))) { die "undefined identifier"; }
		  my $nextchar = $9;
		  if (!(defined($nextchar))) { die "undefined nextchar"; }
		  my $remaining = $';
		  if (($line =~ /^\s/)
		      && ($symtab_scopes == 0)
		      # accept indented declaration/definition (except
		      # function def) in a #if at top scope
		      && ((@dependenton == 0) || ($nextchar eq "\(")))
		    { die "Indented line $. at top level ($symtab_scopes, @dependenton, '$nextchar'): $line\n"; }
		  # print "found type '$basetype$pointerdecls$arraydecls' identifier '$identifier' nextchar '$nextchar' remaining '$remaining' on line $.\n";
		  # If no semicolon, then the definition must span lines.
		  if (($nextchar ne ";") && ($nextchar ne "("))
		    # Only need to check the new stuff, not the whole thing.
		    { while (!($remaining =~ /;/))
			{	# print "no semicolon, so appending a line to $remaining\n";
			  $remaining = appendlines($remaining, getline()); } }
		  # print "found semicolon (or nextchar is open paren) in $remaining\n";
		  if ($nextchar eq "(")
		    {		# found (start of) function definition or prototype
		      if ($symtab_scopes != 0)
			{ die "Function definition or prototype $& at bracedepth $symtab_scopes.\n"; }
		      # Only need to check the new stuff, not the whole thing.
		      while (!($remaining =~ /\)/))
			{ print "no close paren, so appending a line to $remaining\n";
			  $remaining = appendlines($remaining, getline()); }
		      if (!($remaining =~ /\)/))
			{ die "There must be a close paren.\n"; }
		      # print "found function $identifier; remaining $remaining\n";
		      # process the args:  create the scope, eat the following
		      # open brace, etc.  $remaining includes everything after
		      # the original open paren.
		      # Three possibilities:
		      #   function declaration (K&R or ANSI)
		      #   K&R-style function definition
		      #   ANSI-style function definition
		      my ($success, $remaining) = parse_function_decl_args($remaining);
		      if (!defined($remaining))
			{ die "remaining not defined after parse_function_decl_args => @argnames | @argtypes\n"; }
		      if (!$success)
			{ $line = $remaining;
			  goto PROCESSLINE; }
		      # $remaining is what follows the close paren
		      while ($remaining =~ /^\s*$/)
			{	# print "no semi or brace, so appending a line to $remaining\n";
			  my $nextline = getline();
			  $remaining = appendlines($remaining, $nextline); }
		      # $remaining is nonempty; if first character is
		      # semicolon, then this is a declaration, else a definition
		      if ($remaining =~ /^\s*;/)
			{	# declaration
			  # enter this in the global symbol table, perhaps
			  # (to be done)
			  $remaining = $';
			}
		      else
			{	# definition
			  # print "found function definition $identifier; remaining $remaining\n";
			  if ($remaining =~ /^\s*\{/)
			    {	# ANSI-style definition
			      $remaining = $';
			    }
			  else
			    {	# K&R-style definition
			      if (!($remaining =~ /^\s*$typedeclarator\s*([,;])/))
				{ die "Didn't find first type+declarator in K&R-style $remaining\n"; }
			      { my $argtype;
				for $argtype (@argtypes)
				  { if ($argtype != $typeUNSPECIFIED)
				      { die "K&R-style definition, but a type is specified as " . type_name($argtype) . ".\n"; } } }
			      # Only need to check the new stuff, not the whole thing.

			      while (!($remaining =~ /\{/))
				{ # print "no brace, so appending a line to $remaining\n";
				  $remaining = appendlines($remaining, getline()); }
			      $remaining = parse_KandR_function_arg_decls($remaining);
			      # Make sure that the argument list matches the declarators
			      { my $index;
				foreach $index (0..$#argnames)
				  { # print "argname: ", @argname, "\nargtype: ", @argtype, "\n";
				    my $thistype = $argnametype{$argnames[$index]};
				    if (!defined($thistype))
				      { die "No K&R-style declarator for $argnames[$index]\n"; }
				    $argtypes[$index] = $thistype;
				    delete $argnametype{$argnames[$index]};
				  }
				# argnametype should be empty now
				for $name (keys %argnametype)
				  { die "K&R-style declarator, but no argument, for $name $argnametype{$name}\n"; }
			      }
			    }
			  # function definition: $remaining is everything after
			  # the open brace, and @argnames and @argtypes are set.
			  # Two things to do:
			  #  1. add function's type to the global symbol table
			  #  2. enter a scope

			  # 1. add function's type to the global symbol table
			  # (to be done).  Actually, this should be easy since
			  # we are at global scope now.  Perhaps have separate
			  # tables for guesses and for what we know for sure.
			  # We'll have declarations for everything but macros.
			  # Watch out that it isn't already in the global
			  # symbol table (make sure it is compatible if so).

			  # 2. enter a scope
			  enter_scope();
			  for $index (0..$#argnames)
			    { symtab_add($argnames[$index], $argtypes[$index]); }

			  # Done with function definition
			}

		      # We just coped with a function definition or declaration.
		      # Process the rest of the line (if def, this is anything
		      # after the open brace).
		      $line = $remaining;
		      goto PROCESSLINE;
		    }
		  else
		    {
PROCESSVARDEF:
		      # variable definition or declaration
		      # print "variable definition or declaration <<$identifier>> $basetype$pointerdecls$arraydecls\n";
		      # $nextchar = "," or "=" or ";"

		      my $fulltype = $basetype . $pointerdecls . $arraydecls;
		      # This should logically happen here, but hold off
		      # in case there is trouble.
		      # symtab_add($identifier, $fulltype);
		      if ($nextchar eq ";")
			{ symtab_add($identifier, $fulltype);
			  $line = $remaining;
			  goto PROCESSLINE; }
		      elsif ($nextchar eq ",")
			{
ATCOMMA:
			  if ($remaining =~ /^\s*$declarator\s*([,=;])/o)
			    { symtab_add($identifier, $fulltype);
			      $identifier = $4;
			      if (!(defined($identifier))) { die "undefined identifier"; }
			      $pointerdecls = $1;
			      if (!(defined($pointerdecls))) { $pointerdecls = ""; }
			      $arraydecls = $5;
			      if (!(defined($arraydecls))) { $arraydecls = ""; }
			      $nextchar = $7;
			      if (!(defined($nextchar))) { die "undefined nextchar"; }
			      $remaining = $';
			      goto PROCESSVARDEF; }
			  elsif ($remaining =~ /^\s*$typedeclarator\s*([,\)])/o)
			    {	# We're in the middle of a function declarator
			      # Skip to next brace or semicolon
			      $remaining = $';
			      if ($remaining =~ /[\{;]/)
				{ if ($& eq ";")
				    { $remaining = $'; }
				  else
				    { $remaining = $& . $'; } }
			      elsif ($remaining =~ /\)/)
				{ $remaining = $'; }
			      else
				{ die "No semicolon or brace after function declarator?  It can't be!\n"; }
			      $line = $remaining;
			      goto PROCESSLINE; }
			  else
			    { die "Found '$basetype $identifier' ($nextchar) on line $. but no following var in $remaining\n"; } }
		      elsif ($nextchar eq "=")
			{	# Skip over an expression and continue processing from there.
                          # print "skipping expression $remaining\n";
			  my $postexp = skip_expression_nocommaop($remaining);
			  if ($postexp eq "")
			    {	# do nothing; done with this line, because
			      # parsing of the expression failed
			      die "Failed to parse initializer $remaining\n"; }
			  elsif ($postexp =~ /\s*;/)
			    { $line = $';
			      goto PROCESSLINE; }
			  elsif ($postexp =~ /\s*,/)
			    { $remaining = $';
			      goto ATCOMMA; }
			  else
			    { die "After skipping well-formed initializer, didn't find comma or semicolon.\n"; } }
		      else
			{ die "Bad nextchar $nextchar.\n"; } }
		}
	      # Line didn't match $typedeclarator
	      # Parse it looking for:
	      #  * open and close braces to keep track of scopes
	      #  * strings and chars so we can skip over them
	      #    (or maybe simplify_line will do away with them).
	      #  * open parens, because maybe they indicate a function call
	      #  * semicolon: try again
	      while ($line =~ m/[\({}\"\';]/) #'FIXCOLOR
		# Found brace, open paren, quote, comment, or semicolon
		{		# print "Found brace, open paren, quote, comment, or semicolon: $&$'\n";
		  my $match = $&;
		  $line = $';
		  if ($match eq "{")
		    { enter_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq "}")
		    { exit_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq ";")
		    { goto PROCESSLINE; }
		  elsif ($match eq "(")
		    { if ($` =~ /$identregexp\s*$/o)
			{	# found something that looks like a function call
			  # process it
			}
		      else
			{	# This paren doesn't represent a function call;
			  # look for another brace, open paren, quote, comment
			}
		    }
		  elsif ($match eq "\"")
		    { if ($line =~ /$nonescdquote/o)
			{ $line = $'; }
		      else
			{ die "Didn't find end of string literal $line.\n"; } }
		  elsif ($match eq "'")
		    { if ($line =~ /$charlitcontents\'/o)
			{ $line = $'; }
		      else
			{ die "Didn't find end of character literal $line.\n"; } }
		  else
		    { die "What match '$match' '$line'?\n"; } }
	    }
	  # done with this line; get another
	}
      # done with this file; read another
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      print "closing file $file\n";
      close(INPUT);
    }
}

# Returns two values the remaining string, or the empty string if failure.
# This is actually for skipping initializers.
sub skip_expression_nocommaop
{
  my ($input) = @_;
  my ($type, $remaining);

  # print "skipping expression $input\n";

  if ($input =~ /^\s*\{/)
    { ($type, $remaining) = parse_array_initializer($');
      # print "parse_array_initializer returned $type $remaining\n";
    }
  else
    { ($type, $remaining) = parse_exp_nocommaop($input, "ignore types"); }
  if (!$type)
    { return ""; }
  else
    { return $remaining; }
}


### Symbol table

# The symbol table is two parallel arrays:  @identifiers @types
# A scope is indicated by the value $scopemarker in the @identifiers array.

# Perhaps have a different structure (an associative array?) for the global
# level and only use this for nested scopes.

sub show_symtab
{
  my ($text) = @_;
  if ($#identifiers != $#types)
    { die "identifiers and types arrays have different lengths ($#identifiers != $#types)\n"; }
  print "{SYMBOL TABLE $text at line $.:\n";
  # perhaps print out in opposite direction
  my $i;
  for ($i = $#identifiers; $i >= 0; $i--)
    { if ($identifiers[$i] eq $scopemarker)
	{ print " --------\n"; }
      else
	{ print " ", $identifiers[$i], "\t", type_name($types[$i]), "\n"; }
    }
  print "}\n";
}

sub enter_scope
{
  push(@identifiers, $scopemarker);
  push(@types, 0);
  $symtab_scopes++;
  # show_symtab("entered scope $symtab_scopes");
}

sub exit_scope
{
  # exit a scope
  # show_symtab("exiting scope $symtab_scopes");
  if ($#identifiers == -1)
    { die "Trying to exit scope at line $., but empty identifiers array at beginning.\n"; }
  while ($scopemarker ne pop(@identifiers))
    { pop(@types);
      if ($#identifiers == -1)
	{ die "Trying to exit scope at line $., but didn't find scopemarker.\n"; } }
  pop(@types);
  # It's possible that ($#identifiers == -1), if global scope is empty.
  # show_symtab("exited scope $symtab_scopes");
  $symtab_scopes--;
}

# sub symtab_scopes
# {
#   my $result = 1;
#   my $id;
#   for $id (@identifiers)
#     { if ($id eq $scopemarker)
# 	{ $result++; } }
#   return $result;
# }

sub symtab_add
{
  my ($identifier, $type) = @_;
  if (!defined($identifier))
    { die "symtab_add: undefined identifier, type $type"; }
  if (!defined($type))
    { die "symtab_add: undefined type, identifier $identifier"; }
  push (@identifiers, $identifier);
  push (@types, $type);
}

sub symtab_lookup
{
  my ($var) = @_;
  for ($index = $#identifiers; $index >= 0; $index--)
    { if ($var eq $identifiers[$index])
	{ return $types[$index]; } }
  return $typeFAIL;
}



###########################################################################
### Check and categorize macros
###

# Need a routine that assigns a type to a literal.
# (Useful for turning macros into const variables.)

# # FIsNumConst(string)  returns 1 iff string matches a numeric const regexp
# sub FIsNumConst {
#   my $str = $_[0];
#   if ($str =~ /^\(?-?\d+\.?\d*\)?$/ || # decimal 2.
#       $str =~ /^\(?-?\d*\.?\d+\)?$/ || # fraction .2
#       $str =~ /^0x[\d|a-f|A-F]+$/ ||   # hex
#       $str =~ /^-?\d+[ulUL]$/) {       # trailing L for long, U for unsigned
#     return 1;
#   } else {
#     return 0;
#   }
# }

sub testcategorizeMacro
{ my ($body) = @_;
  $mbody[1000] = $body;
  $mname[1000] = "dummy";
  $margs[1000] = "(arg)";
  undef $mcategory[1000];
  categorizeMacro(1000);
  print $categoryname[$mcategory[1000]] . "\n";
}

# Takes macro name as argument; categorizes each of the macro's definitions
sub categorizeMacroName
{ my ($name) = @_;
  if (defined($mntype{$name}))
    { return; }
  my $numdefs = $macros{$name}[0];
  if (!defined($numdefs))
    { # We called this on a non-macro (we try for every name in a definition).
      return; }
  my $type;
  my $category;
  { my $i;
    for ($i = 1; $i <= $numdefs; $i++)
      { if (!defined($mcategory[$macros{$name}[$i]]))
	  { categorizeMacro($macros{$name}[$i]);
	    if (!defined($type))
	      { $type = $mtype[$i];
		$category = $mcategory[$i]; }
	    else
	      { $type = type_lub($type, $mtype[$i]);
		$category = category_lub($category, $mcategory[$i]); } } } }
  $mntype{$name} = $type;
  $mncategory{$name} = $category;
}


# Takes index into macro arrays as argument
sub categorizeMacro
{ my ($index) = @_;

  # print "Categorizing $index $mname[$index]$margs[$index] $mbody[$index]\n";

  if (defined($mcategory[$index]))
    { # print "Already categorized! $mcategory[$index] $categoryname[$mcategory[$index]]\n";
      return; }
  $mcategory[$index] = $catINPROCESS;

  my $body = remove_comments($mbody[$index]);
  $mbody_noc[$index] = $body;
  $fDebugCommentRemoval && print STDERR "body = '$mbody[$index]'\nbody_noc = '$body'\n";

  my $category;
  my $type;
  if ($body eq "")
    # Null define
    { $category = $catNULLDEFINE; }
#!    elsif ($body =~ /^\".*\"$/)
#!      # String
#!      { # print "found string";
#!        $category = $catLITERAL;
#!        $type = $typeSTRING; }
  else
    { my $remaining;
      ($type, $remaining) = parse_exp($body);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*$/))
	# Expression
	{ $category = $catEXP;
	  # print "category = $category; found expression $body\n";
	  foreach $arg (split(/[\(, \t]*/, $margs[$index]))
	    { delete $parsevars{$arg};
	      if (defined($parsetypes{$arg}))
		{ $category = $catTYPEARG;
		  goto CATEGORIZED; }
	      delete $parsefuns{$arg}; }
	  # print "category postargs = $category\n";
	  # Assume the functions and types are well-defined if not macros
	  # If they are macros, should check 'em, not just fail.
	  foreach $fun (keys %parsefuns)
	    { if (defined $macros{$fun})
		# This is actually fine most of the time; fix later.
		{ $category = $catMACROFUN;
		  goto CATEGORIZED; } }
	  # print "category postfun = $category\n";
	  foreach $type (keys %parsetypes)
	    { if (defined($macros{$type}))
		# This may be fine; fix later.
		{ $category = $catMACROTYPE;
		  goto CATEGORIZED; } }
	  # print "category posttype = $category\n";
	  # For each free variable, check its type.
	  foreach $var (keys %mfreevars)
	    { print "examining free var $var ($mname[$index])\n";
	      if (defined($macros{$var}))
		{ my $varclass;
		  foreach $i ($macros{$var})
		    { if ($mcategory[$i] == $catNOTYET)
			{ categorizeMacro($i); }
		      if (!defined($varclass))
			{ $varclass = $mcategory[$i]; }
		      elsif ((($mcategory[$i] == $catLITERAL)
			      || ($mcategory[$i] == $catCONSTANT)
			      || ($mcategory[$i] == $catSOMECONSTANT))
			     && (($varclass == $catLITERAL)
				 || ($varclass == $catCONSTANT)
				 || ($varclass == $catSOMECONSTANT)))
			{ $varclass = $catSOMECONSTANT; }
		      elsif ($varclass != $mcategory[$i])
			{ $category = $catFAILURE;
			  goto CATEGORIZED; }
		      else
			{ die "Huh?"; } }
		  if (!(($varclass == $catLITERAL)
			|| ($varclass == $catCONSTANT)
			|| ($varclass == $catSOMECONSTANT)))
		    { $category = $catFAILURE; # should be more specific here
		      goto CATEGORIZED; } }
	      else
		# This is a free variable.  Should check whether it is a global
		# (which would be OK; a local would be bad).
		{ $category = $catEXPFREE; # should be more specific here
		  goto CATEGORIZED; }
	    }
	  # print "category postfree = $category\n";
	  $category = $catSOMECONSTANT;
	  # print "category = $category\n";
	}
      else
	# Should do some evilness processing here, to justify the failed
	# categorization.
	{ # Not an expression, apparently
	  $category = $catFAILURE;
	}
    }

 CATEGORIZED:
  # print "categorized as $category = $categoryname[$category]\n";
  if ($fShowCategorization)
    { # print "$mfile[$index]:$mline[$index]: $category = $categoryname[$category]: $mname[$index]$margs[$index] $mbody[$index]\n";
      print CATEG "$mfile[$index]:$mline[$index]: $categoryname[$category]";
      if (($category == $catEXP)
	  || ($category == $catEXPFREE)
	  || ($category == $catLITERAL)
	  || ($category == $catCONSTANT)
	  || ($category == $catSOMECONSTANT))
	{ print CATEG "(", type_name($type), ")"; }
      print CATEG ": $mname[$index]$margs[$index] $mbody[$index]\n"; }
  $mcategory[$index] = $category;


#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: NullDefine: $name\n";
#     }
#   }
}

# # Uses $lastline global, too
# sub categorizeMacro
# { my ($name, $args, $fullbody) = @_;
#   if ($fullbody =~ m!^(.*?)\s*(/\*.*\*/\s*)*(//.*)?$!) {
#     # $1 matches non-commented part w/ leading,trailing ws removed
#     $body = $1;
#   } else {
#     $body = $fullbody;
#   }
#   $fDebugCommentRemoval && print STDERR "fullbody = '$fullbody'\nbody = '$body'\n";
#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: PreventMI: $name\n";
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: NullDefine: $name\n";
#     }
#   }
#   # Must have a body
#   elsif ($body =~ /^\".*\"$/) {
#     $cSimpleStrConstant++;
#     $fShowCategorization &&
#       print CATEG "$file:$.: SimpleStrConstant: $name $fullbody\n";
#   }
#   # If the type contains a trailing *, the constant is usually (not always!) 0
#   elsif ($body =~ /^\(\(\w+(\s+\**)?\)\s*(.*)\)$/ && FIsNumConst($2)) {
#       $cCastedConstant++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: CastedConstant: $name $fullbody\n";
#     }
#   #FIX: these regexps could be better
#   elsif (FIsNumConst($body) ||
# 	 $body =~ /^'(\\?.|\\[0-7][0-7][0-7])'$/) { # single character constant 'g'
#     # is it just a number, possibly like "(4.566)" or "7" or "0x5FaB" or "'g'"
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cSimpleConstantWithDefault++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: SimpleConstantWithDefault: $name $fullbody\n";
#     }
#     else {
#       $cSimpleConstant++;
#       $fShowCategorization &&
# 	print CATEG "$file:$.: SimpleConstant: $name $fullbody\n";
#     }
#   }
#   elsif ($body =~ /^(L|x|\d|\(|\s|\)|\<|\>|\+|\-|\=|\*|\||\&|\%|\!)*$/) {
#     # FIX: this regexp is lame-- L,x needed for 0x80 << 3 or 1L << 25
#     # is it a numeric expression?
#     $cSimpleExpression++;
#     $fShowCategorization &&
#       print CATEG "$file:$.: SimpleExpression: $name $fullbody\n";
#   }
#   else {
#     $cUncategorized++;
#     $fShowCategorization &&
#       print CATEG "$file:$.: Uncategorized: $name $fullbody\n";
#   }
# }

# arguments are in @_, that is $_[0], $_[1], etc.
sub checkmacrodef
{
}

# returns zero if it was ok
# otherwise $EVIL $DANGER $OBSOLETE $ILLEGAL
# (each individual bits)
sub checkmacrobody
{ my $body = $_[0];
  my $result = 0;
  if ($#_ != 0) { die "Wrong number of arguments to checkmacrobody."; }
  # print "checkmacrobody: $body\n";
  my $indquote = 0;
  my $insquote = 0;
  my $incomment = 0;
  my @nesting = ();
  while ($body =~ m/[\]\[(){}\"\'\#]|\/\/|\/\*|\*\//) #'FIXCOLOR
    # Found paren, quote, cpp directive, or comment
    { my $match = $&;
      my $body = $';
      # print "$match ||| $body\n";
      if ($match =~ /[\[\(\{]/)
        { push(@nesting,$match); }
      elsif ($match =~ /[\]\)\}]/)
	{ if ($#nesting == -1)
	    { $result |= $DANGER;
	      print EVIL "$file:$.: dangerous: close $match without open in $mname\n    $_[0]\n"; }
	  else
	    { my $popped = pop(@nesting);
	      if ((($match eq "\]") && ($popped ne "\["))
		  || (($match eq "\)") && ($popped ne "\("))
		  || (($match eq "\}") && ($popped ne "\{")))
		{ $result |= $DANGER;
		  print EVIL "$file:$.: dangerous: $popped matched by $match in $mname:\n    $_[0]\n"; } } }
      elsif ($match eq "\"")
        { if ($body =~ m/$nonescdquote/o)
            # Empty string OK only if that is the entire body.
            { if ($false	# turn off the test for now
		  && ((length($`) + length($1) + length($2)) == 0)
		  && (length($_[0]) > 2))
                { $result |= $DANGER;
		  print EVIL "$file:$.: dangerous: empty string in $mname:\n    $_[0]\n"; }
              $body = $'; }
          else
           { $result |= $ILLEGAL;
	     print EVIL "$file:$.: illegal: unterminated string $& in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "\'")
        { if (($body =~ m/^\\''/) || ($body =~ m/\'/))
	    { # do this first because we're going to do more matching
	      $body = $';
	      my $char = $` . $&;
              chop($char);	# remove trailing '
	      # Perhaps don't bother with this test; getline already checked
	      # for illegal character constants.
	      if (! ($char =~ m/$charlitcontents/o))
	        { $result |= $ILLEGAL;
		  print EVIL "$file:$.: illegal: bad character constant $char in $mname:\n    $_[0]\n"; }
    	       }
          else
            { $result |= $ILLEGAL;
	      print EVIL "$file:$.: illegal: unterminated character constant $& in $mname:\n    $_[0]\n";
              $body = ""; } }
      elsif ($match eq "#")
	{ if (substr($', 0, 1) eq "#")
	    { $result |= $DANGER;
	      print EVIL "$file:$.: dangerous: ## pasting in $mname:\n    $_[0]\n";
	      $body = substr($body, 1); }
	  # This list from GNU C preprocessor manual
	  # It's not complete, since #assert introduces new preprocessor commands.
	  elsif ($' =~ m/(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|system|unassert|warning)\b/)
	    { $result |= $DANGER;
	      print EVIL "$file:$.: dangerous: preprocessor directive #$& in $mname:\n    $_[0]\n"; }
	  else
	    { $result |= $DANGER;
	      print EVIL "$file:$.: dangerous: stringization in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "/*")
	# This test probably fails for a/**//**/b.  Oh, well.
        { my $postmatch = $';
	  my $precedingabuts = ($` =~ m/\w$/);
	  while (not ($postmatch =~ m!\*/!))
	    { my $nextline;
	      if ($nextline = getline())
		# Get some more text, and look for the comment close there.
		{ $body = appendlines($body, $nextline);
		  $postmatch = appendlines($', $nextline);
		}
	      else
		{ $result |= $EVIL;
		  print EVIL "$file:$.: evil: unterminated comment in $mname:\n    $_[0]\n";
		  $body = "";
		  $postmatch = ""; } }
	  # print "Setting $body to $'; $`; $&.\n";
	  # Redo this because the one in the while test is considered
	  #   in the block, so we lost the (localized) match data.
	  $postmatch =~ m/\*\//;
	  $body = $';
	  if ($precedingabuts && ($body =~ m/^\w/))
	    { $result |= $OBSOLETE;
	      print EVIL "$file:$.: obsoleted: comment pasting in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "//")
        { # print "$file:$.: evil: //-style comment in $mname:\n    $_[0]\n";
          $body = ""; }
      elsif ($match eq "*/")
	# $_[0] doesn't give me the whole thing; why?  ($body only contains
	#   what follows the match at this point.)
        { $result |= $EVIL;
	  print EVIL "$file:$.: evil: comment terminator */ not in comment in $mname:\n    $_[0]\n"; }
      else
        { die "$file:$.: ???: match = $match before $body in $mname:\n    $_[0]\n"; }
        }
  if ($#nesting != -1)
    { $result |= $EVIL;
      print EVIL "$file:$.: evil: no match for ", @nesting, " in $mname:\n    $_[0]\n"; }
  return $result;
}
