#!/usr/local/bin/perl -w
# $Id$
# evilmacros

# Invoke like this:   evilmacros `find-c`
# or like this:  find-c | evilmacros -i
# Perhaps this should do the searching through subdirectories itself,
# but that wouldn't be too hard.
# Also permits it to be piped file names via standard in. (added by gjb)

#Complex execution (use zsh):
# ext=all; p=~/505/data; for i in *(/); do pushd $i; find-c | nice evilmacros -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
#

# Report "evil" CPP macros:
#  Illegal macros:
#   Unterminated string
#   Wrong length character constant
#   Unterminated character constant
#   Pasting via comments (syntactically legal, but no pasting occurs in ISO C)
#  Potentially dangerous macros:
#   Unbalanced parens, braces, and brackets
#   Pasting via ##
#   Stringization via #
#  Turned off testing for:
#   Empty string

# Harbison & Steele p. 53:
#   ISO C reaffirms tht macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.

# To do:
#  Add comments describing complex regular expressions
#  Classify macros as expression-like (possibly subcategorize as function-like
#	if expression-like and takes argument), statement-like, or neither
#	(ie, that change the state of the parser)
#    Check for the semicolon-swallowing problem.
#    Check for multiple statements, like
#        #define double(stmt)    stmt;stmt;
#        double(i=5) =>   i=5;i=5;
#  Perhaps warn about multi-line comments/strings in macro definitions.
#	Presently getline() removes the newlines silently; it shouldn't warn
#	since it is called for every line, not just those in macro defs.
#  Warn about "#define foo(bar)"?  Probably legal, but probably a mistake.
#  Give % #def/cpp-directives for .c files and .h files separately.
#  Compute number of blank lines, comment lines, and code lines.  (Sum will
#	be more than total, since lines can contain both comments and code,
#	or both comments and preprocessor directives.)
#  Recognize macros that build assembly code, and treat/report specially?
#	(What % of interesting macros are such?)
#  Perhaps extract some of the utility code into a library or separate file.
#  Check for/recognize template-like macros (that take a type as an argument).
#  Keep track of the current conditional compilation constraints
#  Look for __XXX__ in the files


###########################################################################
### Constants
###

$OBSOLETE = 1;
$DANGER = 2;
$EVIL = 3;
$ILLEGAL = 4;

###########################################################################
### Variables
###

## Integers:
$lines = 0;			# count of lines; line continuation doesn't increment
$macrodefs = 0;
$cEvil = 0;			# count of number of evil macros
$cObsoleted = 0;		# count of number of obsoleted macros
$cDanger = 0;			# count of number of dangerous macros
$cIllegal = 0;			# count of number of illegal macros
$cpp_cmds = 0;			# total preprocessor commands, including macro defs
## Strings: 
$line = "";			# current line
$lastline = "";			# the prior line
$currentfile = 0;
$mname = 0;
$margs = 0;
$mdef = 0;
## Boolean:
$incomment = 0;			# in /* */ style comment
$instring = 0;
# Shouldn't be in a character constant across lines.
# $incharconst = 0;

# Though this would work:
#foreach $v (values %macroCommands) {
#  $$v = 0;
#}
# We need to suppress warnings about vars used only once:
$cAssert = 0;  $cCpu = 0;
$cDefine = 0;  $cElif = 0;
$cElse = 0;    $cError = 0;
$cIdent = 0;   $cIf = 0;
$cIfdef = 0;   $cIfndef = 0;
$cImport = 0;  $cInclude = 0;
$cLine = 0;    $cMachine = 0;
$cPragma = 0;  $cSystem = 0;
$cUnassert = 0;$cUndef = 0;
$cWarning = 0;

%macroCommands = 
  ( "assert" => \$cAssert,
    "cpu" => \$cCpu,
    "define" => \$cDefine,
    "elif" => \$cElif,
    "else" => \$cElse,
    "error" => \$cError,
    "ident" => \$cIdent,
    "if" => \$cIf,
    "ifdef" => \$cIfdef,
    "ifndef" => \$cIfndef,
    "import" => \$cImport,
    "include" => \$cInclude,
    "line" => \$cLine,
    "machine" => \$cMachine,
    "pragma" => \$cPragma,
    "system" => \$cSystem,
    "undef" => \$cUndef,
    "unassert" => \$cUnassert,
    "warning" => \$cWarning,
  );

## Categorizations of #define-s
# Maybe keep a list of these, too, @lNullDefine, etc.
$cNullDefine = 0;		# e.g. #define DEBUG
$cSimpleConstantWithDefault = 0; # e.g. #ifndef LEN\n#define LEN 64
$cSimpleConstant = 0;	        # e.g. #define NULL 0
$cSimpleStrConstant = 0;        # e.g. #define font "6x13"
$cSimpleExpression = 0;         # e.g. #define COUNT (1024*256)+5
$cCastedConstant = 0;         # e.g. #define Meta ((char) 0x83)
# cPreventMI is just a null DEFINE with #ifndef just prior
$cPreventMI = 0;		# e.g. #ifndef BLAH, #define BLAH
$cWithNullArgs=0;               # e.g. #define getch()
$cWithArgs=0;                   # e.g. #define sqr(x) ((x)*(x))
$cUncategorized=0;


###########################################################################
### Usage
###

# FIX: the options are non-orthogonal ... this is confusing

# Updated by gjb
sub usage {
   die "@_\nUsage: $0 [-ihvDsS] <files>
-i use files listed on stdin [one per line] in addition to any on cmd line
-h display this help message
-v be verbose and list files as they are processed to stderr
-D [file] dump the names of the macros upon conclusion
-S [file] Output the per directive statistics to file
-c [file] Show categorizations to file
-e [file] Send evil macros to file instead of stdout
";
}


###########################################################################
### Main loop
###

use Getopt::Std;
use vars qw( $opt_i $opt_h $opt_v $opt_D $opt_S $opt_c $opt_e);
$fDebugCmdProcessing = 0;
$fDebugCommentRemoval = 0;

# use strict;
# use English;

getopts('ihvD:S:c:e:');
usage() if ($opt_h);

$fShowCategorization = $opt_c;

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    push @ARGV, $_;
  }
}

if ($opt_e) {
  open(EVIL,">$opt_e") || die "Failed opening $opt_e";
} else {
  open(EVIL,">-") || die "Failed opening stdout!";
}

if ($opt_S) {
  open(STATS,">$opt_S") || die "Failed opening $opt_S";
}

if ($opt_D) {
  open(DEFINES,">$opt_D") || die "Failed opening $opt_D";
}

if ($opt_c) {
  open(CATEG,">$opt_c") || die "Failed opening $opt_c";
}


$fDebugCmdProcessing && print "@ARGV";

foreach $file (@ARGV)
{ if ($opt_v)
    { print STDERR $file . "\n"; }
  $currentfile = $file;
  open(INPUT,$file) or next;	# skip to next file if open fails
  $incomment = 0;
  $instring = 0;
  # $incharconst = 0;
 LINELOOP:
  while ($line = getline())
    {
      # check for macros
      if ($line =~ m/^\#[ \t]*define[ \t]*/)
	{ $macrodefs++;
	  $cDefine++;
	  $line = $';
	  # remove trailing newline
	  chop($line);
	  # print $line, "\n";
	  ($mname, $margs, $mdef) = macroparse($line);
	  # if (!defined($margs)) { $margs = ""; } # avoid uninitialized variable warning
	  # print "parsed: |$mname|$margs|$mdef|\n";

	  # save the name of the macro and its args and definitions
	  # FIX: want to do something about checking whether the
	  # macro has been redefined, or whatever
	  $macros{$mname}[0] = $margs;
	  $macros{$mname}[1] = $mdef;
	  # let [2] count the number of times we've seen this macro define-d
	  if (defined($macros{$mname}[2])) {
	    $macros{$mname}[2]++;
	  } else {
	    $macros{$mname}[2]=1;
	  }

	  categorizeMacro($mname,$margs,$mdef);

	  # Nothing to check if this is just making the macro defined w/o a body.
	  if (defined($mdef) && ($flags = checkmacrobody($mdef)) != 0) {
	    $cEvil++ if $flags & $EVIL;
	    $cIllegal++ if $flags & $ILLEGAL;
	    $cObsoleted++ if $flags & $OBSOLETE;
	    $cDanger++ if $flags & $DANGER;
	  }
	}
      elsif ($line =~ m/^\#[ \t]*([^ ]*)\b/) {
	$ {$macroCommands{$1}}++ if exists $macroCommands{$1}; 
	$cpp_cmds++;
      }
    }
  continue {
    $lastline = $line;
  }
  close(INPUT);
}
if ($lines == 0) {
  # This is useful for testing, I guess.
  print STDERR "No lines read! Perhaps you meant to use the -i option?\n"; 
} else {
  if ($opt_S) {
    # Dump statistics on frequencies of directives
    printf STATS "DIRECTIVES#: ";
    while ( ($h,$v) = each(%macroCommands) ) {
      print STATS "$h ";
    }
    print STATS "\n";
    printf STATS "DIRECTIVES: ";
    while ( ($h,$v) = each(%macroCommands) ) {
      print STATS "$$v ";
    }
    print STATS "\n";
    printf STATS "DIRECTIVES%: ";
    while ( ($h,$v) = each(%macroCommands) ) {
      printf STATS "%2.2f ", (100*$$v/$lines);
    }
    print STATS "\n";

    printf STATS "GLOBAL: $macrodefs define-s (%2.2f%) , $cpp_cmds other (%2.2f%) , $lines lines (%2.2f%) , %d files\n", 
    100*$macrodefs/$lines, 100*$cpp_cmds/$lines, 
      100*($macrodefs+$cpp_cmds)/$lines, $#ARGV+1;
    printf STATS "EVILSTATS: $cObsoleted obsoleted (%2.2f%) , $cDanger dangerous (%2.2f%) , $cEvil evil (%2.2f%) , $cIllegal illegal (%2.2f%)\n",
    pct($cObsoleted), pct($cDanger), pct($cEvil), pct($cIllegal);
    print STATS "CATEGORIZATION#: Total NullDefine PreventMI SimpleConstant SimpleConstantWithDefault SimpleStrConstant CastedConstant SimpleExpression WithNullArgs WithArgs Uncategorized\n";
    print STATS "CATEGORIZATION: $macrodefs $cNullDefine $cPreventMI $cSimpleConstant $cSimpleConstantWithDefault $cSimpleStrConstant $cCastedConstant $cSimpleExpression $cWithNullArgs $cWithArgs $cUncategorized\n";
    printf STATS "CATEGORIZATION%: %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f\n",
    pct($macrodefs),pct($cNullDefine),pct($cPreventMI),pct($cSimpleConstant),
    pct($cSimpleConstantWithDefault),pct($cSimpleStrConstant),pct($cCastedConstant),
    pct($cSimpleExpression),pct($cWithNullArgs),pct($cWithArgs),pct($cUncategorized);
  }

  # -D = dump the defines
  if ($opt_D) {
    foreach $mname (keys %macros) {
      print DEFINES "$mname $macros{$mname}[2]\n";
    }
  }
}


###########################################################################
### Subroutines
###

# Read the next logical line from <INPUT>, until no continuation char
#   and not in string or comment.
# Result ends with newline.
sub getline
{ my $result;
  if (not ($result = <INPUT>))
    { return $result; }
  $lines++;
  updateinvars($result);


  # perhaps check for $mname and mention it in message if it's set
  while ($incomment || $instring || ($result =~ m/\\$/))
    {
      # splice lines
      while ($result =~ m/\\$/)
	{ # block to localize match data
	  { if ($result =~ m/\\\Z(?!\n)/)
	      { print EVIL "$currentfile:$.: evil: file ends with backslash (no newline)\n"; } }
	  $result = $`;		# remove backslash and possibly newline
	  my $nextline;
	  if ($nextline = <INPUT>)
	    { &updateinvars($nextline);
	      $result = appendlines($result, $nextline);
	      # The appendlines trims trailing spaces, prettying the message.
	      if ($nextline =~ m/^[ \t]*$/)
		{ # No \n at end: $result ends in a newline
		  print EVIL "$currentfile:$.: dangerous: blank line follows continuation character:\n    $result"; }
	    }
	  else
	    # Already removed backslash and newline from result.
	    # (Should I add them back?)
	    { print EVIL "$currentfile:$.: dangerous: file ends with continuation character:\n    $result\n"; } }

      while ($incomment)
	{ my $nextline;
	  if ($nextline = <INPUT>)
	    { $lines++;
	      updateinvars($nextline);
	      $result = appendlines($result, $nextline); }
	  else
	    { print EVIL "$currentfile:$.: dangerous: file ends in comment:\n    $result";
	      $incomment = 0; } }

      # Not "while ($instring) ..." because processing continuation lines
      # takes priority over simple concatenation.
      if ($instring)
	{ my $nextline;
	  if ($nextline = <INPUT>)
	    { $lines++;
	      updateinvars($nextline);
	      $result = appendlines($result, $nextline); }
	  else
	    { print EVIL "$currentfile:$.: dangerous: file ends in string:\n    $result\n";
	      $instring = 0; } }
    }

  $result;
}

# All backslash line continuations have already been processed.
sub updateinvars
{
  my $remaining = $_[0];
  
  while ($remaining)
    { if ($incomment)
	{ if ($remaining =~ /\*\//)
	    { $remaining = $';
	      $incomment = 0; }
	  else
	    { return; } }
      elsif ($instring)
	{ # print "in string, processing $remaining";
	  if ($remaining =~ m/(^|[^\\])(\\\\)*\"/)
	    { $remaining = $';
	      $instring = 0; }
	  else
	    { # print "$currentfile:$.: in string after line $_[0]";
	      return; } }
      # If not instring, I think \" suffices instead of the more complicated
      # regexp that checks for leading backslashes.
      elsif ($remaining =~ m/\/[\*\/]|['\"]/) #'FIXCOLOR
	{ if ($& eq "'")
	    { if (($' =~ m/^\\''/) || (($' =~ m/'/) && (length($`) < 5))) #'FIXCOLOR
		{ $remaining = $'; }
	      else
                # No newline, since $_[0] has one.
                # Also, don't die: let processing proceed.
		{ # die "$currentfile:$.: (bad character constant) $&\n    in $_[0]";
                  $remaining = $'; } }
	  elsif ($& eq "\"")
	    { $remaining = $';
	      $instring = 1; }
	  elsif ($& eq "//")
	    { return; }
	  elsif ($& eq "/*")
	    { $remaining = $'; 
	      $incomment = 1; }
	  else
	    { die "What match?  $& in $_[0]\n"; } }
      else
	{ return; }
    }
}


# This pretties things up but changes contents of line-spanning strings
sub appendlines
{
  my ($arg1, $arg2) = @_;
  # "+", not "*", so don't introduce spaces where there were none before
  # Do I need \Z instead of $?  It seems I don't...
  $arg1 =~ s/[ \t\n]+$/ /;
  $arg2 =~ s/^[ \t\n]+/ /;
  $arg1 . $arg2;
}



###########################################################################
### Parse and check macros
###

# Return an array of three elements: name, args, def
sub macroparse
{ if ($#_ != 0) { die "Wrong number of arguments to macrobody."; }
  # print "macroparse $_[0]\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($_[0] =~ m/^([a-zA-Z_0-9]+)(\([^\)]*\))?[ \t]*(.*)$/);
  if ($#result != 2)		# $# = 2 => 3 elements
    { die "Problem parsing macro $_[0]\n"; }
  @result;
}

# FIsNumConst(string)  returns 1 iff string matches a numeric const regexp
sub FIsNumConst {
  my $str = $_[0];
  if ($str =~ /^\(?-?\d+\.?\d*\)?$/ || # decimal 2.
      $str =~ /^\(?-?\d*\.?\d+\)?$/ || # fraction .2
      $str =~ /^0x[\d|a-f|A-F]+$/ ||   # hex
	 $str =~ /^-?\d+L$/) {         # trailing L for long
    return 1;
  } else {
    return 0;
  }
}

# pct(x) returns a percentage of macros defined
sub pct {
  $x = $_[0];
  if ($x < 0 || $x > $macrodefs) {
    print STDERR "Percentage out of range: $x / $macrodefs\n";
  }
  return (100*$x/$macrodefs);
}

# Update globals $cXXXX, @lXXXX based on what we can tell about
# this macro
# FIX: need to update @l vars
# Uses $lastline global, too
sub categorizeMacro
{ (my $name, my $args, my $fullbody) = @_;
  if ($fullbody =~ m!^\s*(.*?)\s*(/\*.*\*/\s*)*(//.*)?$!) {
    # $1 matches non-commented part w/ leading,trailing ws removed
    $body = $1;
  } else {
    $body = $fullbody;
  }
  $fDebugCommentRemoval && print STDERR "fullbody = '$fullbody'\nbody = '$body'\n";
  if (defined($args)) {
    if ($args =~ /^\s*\(\s*\)\s*$/) {
      $cWithNullArgs++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: WithNullArgs: $name $args $fullbody\n";
    } else {
      $cWithArgs++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: WithRealArgs: $name $args $fullbody\n";
    }
  }
  # Must not have had args
  elsif (!defined($body) || $body eq "") {
    if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
      $cPreventMI++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: PreventMI: $name\n";
    }
    else {
      $cNullDefine++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: NullDefine: $name\n";
    }
  }
  # Must have a body
  elsif ($body =~ /^\".*\"$/) {
    $cSimpleStrConstant++;
    $fShowCategorization && 
      print CATEG "$currentfile:$.: SimpleStrConstant: $name $fullbody\n";
  }
  elsif ($body =~ /^\(\s*\(\w+(\s+\**)?\)\s*(.*)\)$/ && FIsNumConst($2)) {
      $cCastedConstant++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: CastedConstant: $name $fullbody\n";
    }    
  #FIX: these regexps could be better
  elsif (FIsNumConst($body) ||
	 $body =~ /^'(\\?.|\\\d\d\d)'$/) {	           # single character constant 'g'
    # is it just a number, possibly like "(4.566)" or "7" or "0x5FaB" or 'g'
    if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
      $cSimpleConstantWithDefault++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: SimpleConstantWithDefault: $name $fullbody\n";
    }
    else {
      $cSimpleConstant++;
      $fShowCategorization && 
	print CATEG "$currentfile:$.: SimpleConstant: $name $fullbody\n";
    }
  }
  elsif ($body =~ /^(L|x|\d|\(|\s|\)|\<|\>|\+|\-|\=|\*|\||\&|\%|\!)*$/) {
    # FIX: this regexp is lame-- L,x needed for 0x80 << 3 or 1L << 25
    # is it a numeric expression?
    $cSimpleExpression++;
    $fShowCategorization && 
      print CATEG "$currentfile:$.: SimpleExpression: $name $fullbody\n";
  }
  else {
    $cUncategorized++;
    $fShowCategorization && 
      print CATEG "$currentfile:$.: Uncategorized: $name $fullbody\n";
  }
}

# arguments are in @_, that is $_[0], $_[1], etc.
sub checkmacrodef
{ 
}
 
# Should also give file, line in error message.
# returns zero if it was ok
# otherwise $EVIL $DANGER $OBSOLETE $ILLEGAL
# (each individual bits)
sub checkmacrobody
{ my $body = $_[0];
  my $result = 0;
  if ($#_ != 0) { die "Wrong number of arguments to checkmacrobody."; }
  # print "checkmacrobody: $body\n";
  my $indquote = 0;
  my $insquote = 0;
  my $incomment = 0;
  my @nesting = ();
  while ($body =~ m![\]\[(){}\"'#]|//|/\*|\*/!) #'FIXCOLOR
    { $match = $&;
      $body = $';
      # print "$match ||| $body\n";
      if ($match =~ /[\[\(\{]/)
        { push(@nesting,$match); }
      elsif ($match =~ /[\]\)\}]/)
	{ if ($#nesting == -1)
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: close $match without open in $mname\n    $_[0]\n"; }
	  else
	    { my $popped = pop(@nesting);
	      if ((($match eq "\]") && ($popped ne "\["))
		  || (($match eq "\)") && ($popped ne "\("))
		  || (($match eq "\}") && ($popped ne "\{")))
		{ $result |= $DANGER;
		  print EVIL "$currentfile:$.: dangerous: $popped matched by $match in $mname:\n    $_[0]\n"; } } }
      elsif ($match eq "\"")
	# Does this test cope with "foo\\"?
        { if ($body =~ m/(^|[^\\])(\\\\)*\"/)
            # Empty string OK only if that is the entire body.
            { if ((1 == 0)	# turn off the test for now
		  && ((length($`) + length($1) + length($2)) == 0)
		  && (length($_[0]) > 2))
                { $result |= $DANGER;
		  print EVIL "$currentfile:$.: dangerous: empty string in $mname:\n    $_[0]\n"; }
              $body = $'; }
          else
           { $result |= $ILLEGAL;
	     print EVIL "$currentfile:$.: illegal: unterminated string $& in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "\'")
        { if (($body =~ m/^\\''/) || ($body =~ m/\'/))
	    { # do this first because we're going to do more matching
	      $body = $';
	      my $char = $` . $&;
              chop($char);	# remove trailing '
	      if (! ($char =~ m/.|\\.|\\[0-7][0-7][0-7]/))
	        { $result |= $ILLEGAL;
		  print EVIL "$currentfile:$.: illegal: bad character constant $char in $mname:\n    $_[0]\n"; }
    	       }
          else
            { $result |= $ILLEGAL;
	      print EVIL "$currentfile:$.: illegal: unterminated character constant $& in $mname:\n    $_[0]\n";
              $body = ""; } }
      elsif ($match eq "#")
	{ if (substr($', 0, 1) eq "#")
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: ## pasting in $mname:\n    $_[0]\n";
	      $body = substr($body, 1); }
	  # This list from GNU C preprocessor manual
	  elsif ($' =~ m/(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|pragm|system|unassert|warning)\b/)
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: preprocessor directive #$& in $mname:\n    $_[0]\n"; }
	  else
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: stringization in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "/*")
	# This test probably fails for a/**//**/b.  Oh, well.
        { my $postmatch = $';
	  my $precedingabuts = ($` =~ m/\w$/);
	  while (not ($postmatch =~ m!\*/!))
	    { my $nextline;
	      if ($nextline = getline())
		# Get some more text, and look for the comment close there.
		{ $body = appendlines($body, $nextline);
		  $postmatch = appendlines($', $nextline);
		}
	      else
		{ $result |= $EVIL;
		  print EVIL "$currentfile:$.: evil: unterminated comment in $mname:\n    $_[0]\n";
		  $body = "";
		  $postmatch = ""; } }
	  # print "Setting $body to $'; $`; $&.\n";
	  # Redo this because the one in the while test is considered
	  #   in the block, so we lost the (localized) match data.
	  $postmatch =~ m/\*\//;
	  $body = $';
	  if ($precedingabuts && ($body =~ m/^\w/))
	    { $result |= $OBSOLETE; 
	      print EVIL "$currentfile:$.: obsoleted: comment pasting in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "//")
        { # print "$currentfile:$.: evil: //-style comment in $mname:\n    $_[0]\n";
          $body = ""; }
      elsif ($match eq "*/")
	# $_[0] doesn't give me the whole thing; why?  ($body only contains
	#   what follows the match at this point.)
        { $result |= $EVIL;
	  print EVIL "$currentfile:$.: evil: comment terminator */ not in comment in $mname:\n    $_[0]\n"; }
      else
        { die "$currentfile:$.: ???: match = $match before $body in $mname:\n    $_[0]\n"; }
        }
  if ($#nesting != -1)
    { $result |= $EVIL; 
      print EVIL "$currentfile:$.: evil: no match for ", @nesting, " in $mname:\n    $_[0]\n"; }
  return $result;
}
