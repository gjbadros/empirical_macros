#!/uns/bin/perl -w
# $Id$
# evilmacros

# Test: $foo isn't defined

# TODO: learn perldb, any perl profiler?, learn perl compiler
# TODO: split up this huge file, use fewer globals, write packages

# TERMS:
#   project file == a file passed in via -i, or on cmd line
#                   it is also called an NI (not-included) file
#   system file == a file that got parsed because another file
#                  #include-d it


# FIXMERNST: handle #define /* badly-placed-comment */ MACRONAME  properly
# FIX: getline should probably always return a simplified and an
# FIX:   unsimplified version of the line so that if we're not looking
# FIX:   at simplified lines, we don't have to duplicate the simplification
# FIX:   in an ad-hoc way

# Can't use "use", as it is executed upon parsing even if in guard.
BEGIN { if (defined $ENV{"PERLINC"})
	  { unshift(@INC, split(/[ :]+/, $ENV{"PERLINC"})); } }

my $getopts_option_letters = "ihvtIAau1d:D:M:S:F:C:E:";

# Remove the asterisks below when the options
# are known to the users

sub usage {
  die "@_\nUsage: $0 [-$getopts_option_letters] <files>
New options marked with *, options with ':', above, take an argument
  -i  use files listed on stdin [one per line] in addition to any on cmd line
  -h  display this help message
  -v  be verbose and list files as they are processed to stderr
  -t  use [TAB] as the OFS for the statistics files (not space)
  -I  ignore include files--just parse files passed in
  -A  do the second pass on all files, not just those passed in
  -a  do macro statistics on all files, not just those passed in
  -u  ignore usage
  -1  do only the first pass (don't do function parsing, usage)
* -d [directory:prefix]  use standard filenames under the given directory
  -D [file]  output the names of the macros (and number of times defined)
  -U [file]  output macro usage information
  -S [file]  output the per directive statistics to file
  -F [file]  output the function information to a file
  -C [file]  show categorizations to file
  -E [file]  send evil macros to file instead of stdout

(Note: -{D,S,F,C,E} options take precedence over the -d option)

e.g.

find-c | evilmacros -iv -d ~/macros/data/stable
";
}

# Invoke like this:   evilmacros `find-c`
# or like this:  find-c | evilmacros -i
# Perhaps this should do the searching through subdirectories itself,
# but that is easy to do from the shell.

#Complex execution (use zsh):
# ext=all; p=~/505/data; for i in *(/); do pushd $i; find-c | nice evilmacros -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# alias find-c='find . \( -name UNUSED -o -name CVS -o -name SCCS -o -name RCS \) -prune -o \( -name "*.[chCH]" -o -name "*.[cC][cC]" -o -name "*.[cC][pP][pP]" \) -print'
# ext=all; p=/tmp/mernst/data; for i in *(/); do pushd $i; find-c | nice /homes/rivers/mernst/research/notkin/macros/evilmacros-961223 -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# For some reason, adding " >&! ../out-err" doesn't work.
# Probably omit ">! ../out-out", too, so I can see output.
# find-c | evilmacros -i -D../out-def -e../out-evil -c../out-cat -S../out-stat -v >! ../out-out
# Bad idea: it's best to operate on an entire project, so you know all the
# functions, macros, etc.
# evilmacros -D../out-def -e../out-evil -c../out-cat -S../out-stat -v getopt.c

# Harbison & Steele p. 53:
#   ISO C reaffirms that macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.


###########################################################################
### To do
###

## Temporarily moved into my notes-macros file.



###########################################################################
### Strictures
###

# Use strict requires that for each global, either
#  * all uses are fully qualified with the package name ($main::$true), or
#  * it is declared with "my" or appears in a use vars qw( ... ) declaration.
use strict;

# "use English" lets or requires (I don't know) use of $line or some such
# in place of $. and so forth.)
# Why is it not turned on?
use English;



###########################################################################
### Other packages
###

use checkargs;



###########################################################################
### Constants
###

### Boolean
my $true = (1 == 1);
my $false = (1 == 0);

# some evilness (pasting, stringization) is independent of the others,
# though it may not be able to be classified (actually, stringization
# is pretty easy to classify, when we see that a macro argument follows #).
# In this case evilness is more need-for-preprocessor.

# Also note that some evilness has to do with whole files, or parsing,
# while other has to do with macros that have to be macros.
# Maybe rename the latter from "evil" to "macrofeature" or some such.

# These should probably be merged into failure categories, below
my $OBSOLETE = 1;
my $DANGER = 2;
my $EVIL = 3;
my $ILLEGAL = 4;

# Nonconstant: free var (var, function, etc), expression w/side effect,
#	inconsistent types, etc.
# Statement (??)
# Other unclassifiable: give evilness reason, or name the free var,
#	or do multiple of these.


# Categories

my $catNOTYET = 0;		# shouldn't be used; should be undefined instead
my $catINPROCESS = 1;
my $catMULTIPLE = 2;
my $catNULLDEFINE = 3;
# Expressions
my $catEXP = 4;
my $catEXPFREE = 5;		# expression with free variables
my $catLITERAL = 6;		# also specify the literal
my $catCONSTANT = 7;		# need to also specify the particular value, if possible
my $catSOMECONSTANT = 8;
# Non-expressions
my $catFAILURE = 9;		# shouldn't have just one, should have many
my $catTYPEARG = 10;		# macro argument has a type
# These shouldn't be failures
my $catMACROFUN = 11;
my $catMACROTYPE = 12;

my @categoryname = (
		    'uncategorized', 'being categorized', 
		    'multiply categorized', 'null define', 
		    'expression', 'expression with free variables',
		    'literal', 'constant', 'some constant', 
		    'failed categorization', 'has type argument',
		    'macro as function', 'macro as type',
		   );

## Needs to be fixed.
## Perhaps give actual constant, so it can be determined.
sub category_lub
{ my ($c1, $c2) = check_args(2, "category_lub", caller, @_);
  return (($c1 == $c2) ? $c1 : $catMULTIPLE);
}


###########################################################################
### Regular expressions
###

# Use /o in matches for these, so interpolation/compilation occurs just once.
# Use single, not  double, quotes so as not to lose the backslashes.
# But note that \\ and \' are interpolated in single-quoted strings.
# "\b" prevents two words from running up against one another
# These regexps are intended not to include any leading or trailing space

### Reserved words

# can appear in a type
my $c_reserved_type_word_re = '\b(char|const|double|enum|extern|float|int|long|register|short|signed|static|struct|union|unsigned|void|volatile)\b';
# can't appear in a type
my $c_reserved_nontype_word_re = '\b(asm|auto|break|case|continue|default|do|else|entry|for|fortran|goto|if|return|sizeof|switch|typedef|while)\b';
my $c_plus_plus_reserved_word_re = '\b(asm|bool|catch|class|const_cast|delete|dynamic_cast|false|friend|inline|mutable|namespace|new|operator|private|protected|public|reinterpret_cast|static_cast|template|this|throw|true|try|typeid|using|virtual)\b';

### Literals

# FIX: this regexp is lame-- L,x,U needed for 0x80 << 1LU
my $constant_exp_re = '[-LxU0-9() \t<>+=*|&%!]+';	# note this matches whitespace
# $like constant_exp_re, but supposed to match macro uses too.
my $constant_or_upcase_exp_re = '[-A-Z_LxU0-9() \t<>+=*|&%!]+';

# Numeric literals
# floating-point number (two variants): $1 = exponent, $2 = suffix (fFlL)
my $float_literal_whole_re = '[-+]?\d+\.\d*([eE][-+]?\d+)?([fFlL]?)'; # decimal 2.
my $float_literal_frac_re = '[-+]?\d*\.\d+([eE][-+]?\d+)?([fFlL]?)'; # fraction .2
# integer regexp: $1 = number, $2 = suffix (uUlL)
my $hex_literal_re = '(0x[0-9a-fA-F]+)([uUlL]?[uUlL]?)';
my $dec_oct_literal_re = '(\d+)([uUlL]?[uUlL]?)';

# Character and string literals
my $char_literal_contents_re = '(\\\\?.|\\\\[0-7][0-7][0-7])';
my $char_literal_re = "L?'" . $char_literal_contents_re . "'";
my $non_escaped_double_quote_re = '(^|[^\\\\])(\\\\\\\\)*\"';
# non-greedy '.*?' because '.*' matches too much, skips over intervening quotes
my $string_literal_re = 'L?\"(|.*?[^\\\\])(\\\\\\\\)*\"'; # string literal

### Types

# Types and declarations/definitions.
# These should be $identifier_re, not "\w+"
my $identifier_re = '\b[a-zA-Z_]\w*\b';	# 0 groups
my $type_specifier_re = $identifier_re . '(?:\s+' . $identifier_re. ')*'; # 0 groups
my $type_re = $type_specifier_re . '(?:\s*(?:\*|\[\s*\]))*'; # 0 groups
# Use $type_declarator_re instead.
# $type_identifier_re = $type_re . '\s*' . $identifier_re;

# Declarators are actually rather more complicated than this:  see H&S p. 85.
my $type_qualifier_re = '\b(?:const|volatile)\b'; # 0 groups
my $pointer_declarator_prefix_re = '\*(?:\s*' . $type_qualifier_re . ')*'; # 0 groups
my $pointer_declarator_prefixes_re = '(?:' . $pointer_declarator_prefix_re . '\s*)*'; # 0 groups
my $array_declarator_suffix_re = '\[(?:' . $constant_or_upcase_exp_re . ')?\]'; # 0 groups
my $array_declarator_suffixes_re = '(?:\s*' . $array_declarator_suffix_re . ')*'; # 0 groups
# $function_declarator_suffix_re = ...;
# declaratorsuffix = $array_declarator_suffix_re plus $function_declarator_suffix_re
my $declarator_unparenthesized_re = $pointer_declarator_prefixes_re
  . $identifier_re . $array_declarator_suffixes_re; # 0 groups
my $declarator_parenthesized_re = $pointer_declarator_prefixes_re
  . '\(' . $declarator_unparenthesized_re . '\)' . $array_declarator_suffixes_re; # 0 groups
my $declarator_re = '(' . $declarator_parenthesized_re . '|'
  . $declarator_unparenthesized_re . ')'; # 1 group: the declarator
# Use this in preference to $type_identifier_re
# 2 groups: $1 = type specifier, $2 = declarator
my $type_declarator_unparen_re = '(' . $type_specifier_re . ')\s*' . $declarator_re;
my $type_declarator_re = '(' . $type_specifier_re . ')\s*' . $declarator_re;

# # This isn't going to work, because of looping.  Break the loop somehow.
# $simple_declarator_re = $identifier_re;
# $arraydeclarator = $directdeclarator . '\s*\[(' . $constant_exp_re . ')?\]';
# $direct_declarator_re = '(' . $arraydeclarator . '|' . $simple_declarator_re . ')';
# $pointer_declarator_re = '\*(\s*' . $type_qualifier_re . ')*\s*' . $direct_declarator_re;
# $declarator_re = '(' . $pointer_declarator_re . '|' . $direct_declarator_re . ')';
# type plus identifier:  $1 = type, $5 = identifier

# Does not handle enum, struct, union, and function types
my $numeric_type_word_re = '\b(short|signed|unsigned|long|int|char|float|double)\b';
my $numeric_type_re = $numeric_type_word_re . '(\s+' . $numeric_type_word_re . ')*';
my $non_numeric_type_re = '\b(void)\b';
my $builtin_type_base_re = "($numeric_type_re|$non_numeric_type_re)";
my $type_suffix_re = '(\s*(\*|\[\d*\]))*'; # note contains leading whitespace
my $builtin_type_re = $builtin_type_base_re . $type_suffix_re;


###########################################################################
### Types
###

# Perhaps reserve 0 for unrecognized (non-built-in) type.
# No, with new scheme it's important that it be 0
my $typeFAIL = 0;			# does not parse as a valid type
my $typeBOOL = 1;
my $typeCHAR = 2;			# ought to have typeWCHAR as well
my $typeUCHAR = 3;
my $typeSCHAR = 4;
my $typeSHORT = 5;
my $typeUSHORT = 6;
my $typeINT = 7;
my $typeUINT = 8;
my $typeLONG = 9;
my $typeULONG = 10;
my $typeFLOAT = 11;
my $typeDOUBLE = 12;
my $typeLDOUBLE = 13;
my $typeSTRING = 14;
my $typeUNKNOWN = 15;		# we know it's some type, but don't know which
my $typeUNSPECIFIED = 16;		# declared w/o a type (e.g., as function arg)

my %type_num = ('short' => $typeSHORT, 'short int' => $typeSHORT,
	     'signed short' => $typeSHORT, 'signed short int' => $typeSHORT,
	     'unsigned short' => $typeUSHORT, 'unsigned short int' => $typeUSHORT,
	     'int' => $typeINT, 'signed int' => $typeINT, 'signed' => $typeINT,
	     'unsigned int' => $typeUINT, 'unsigned' => $typeUINT,
	     'long' => $typeLONG, 'long int' => $typeLONG,
	     'signed long' => $typeLONG, 'signed long int' => $typeLONG,
	     'unsigned long' => $typeULONG, 'unsigned long int' => $typeULONG,
	     'char' => $typeCHAR,
	     'unsigned char' => $typeUCHAR,
	     'signed char' => $typeSCHAR,
	     'float' => $typeFLOAT,
	     'double' => $typeDOUBLE,
	     'long double' => $typeLDOUBLE,
	     'char *' => $typeSTRING, 'char*' => $typeSTRING);

my @type_name_array = ('typeFAIL', 'bool',
		    'char', 'unsigned char', 'signed char',
		    'short', 'unsigned short',
		    'int', 'unsigned int',
		    'long', 'unsigned long',
		    'float', 'double', 'long double',
		    'char *',
		    'TYPEunknown');

# For determining whether a Perl variable has numeric type.
# This is incredibly disgusting; do something about it.
sub is_number
{
  my ($arg) = check_args(1, "is_number", caller, @_);
  $arg =~ /^\d+$/;
}

sub type_name
{
  my ($type) = check_args(1, "type_name", caller, @_);
  if (is_number($type))
    { return $type_name_array[$type]; }
  else
    { return $type; }
}

sub type_to_num
{
  my ($type) = check_args(1, "type_to_num", caller, @_);
  # print "type = $type; type_num{type} = $type_num{$type} \n";
  $type =~ s/\s+/ /og; # compress multiple spaces to just one
  if (defined($type_num{$type}))
    { return $type_num{$type}; }
  else
    { return $type; }
}


### Numeric types

# This doesn't yet do the right thing.
sub infer_int_type
{
  my ($int) = check_args(1, "infer_int_type", caller, @_);
  if ($int =~ /^0[xX]/)
    # Hex
    { # return first of ($typeUINT $typeLONG $typeULONG) in which the number fits
      return $typeUINT; }
  elsif ($int =~ /^0/)
    { return $typeINT; }	# was unsigned int in non-ANSI C.
  else
    { # return first of ($typeINT $typeLONG $typeULONG) in which the number fits
      return $typeINT; }
}

sub type_integral_p
{ my ($type) = check_args(1, "type_integral_p", caller, @_);
  return (($type == $typeBOOL)
	  || ($type == $typeCHAR) || ($type == $typeUCHAR) || ($type == $typeSCHAR)
	  || ($type == $typeSHORT) || ($type == $typeUSHORT)
	  || ($type == $typeINT) || ($type == $typeUINT)
	  || ($type == $typeLONG) || ($type == $typeULONG));
}

### Type manipulation: arrays, pointers, functions

sub type_dereference
{ my ($type) = check_args(1, "type_dereference", caller, @_);
  if ($type == $typeSTRING)
    { return $typeCHAR; }
  if ($type =~ /(\*|\[\])\s*$/)
    { return $PREMATCH; }
  return $typeUNKNOWN;
}

# A function type looks like ( ),( ),( )->( )
# The full parentheses are necessary (but I don't think they are sufficient)
# to avoid misparsing nested function types.  Maybe that doesn't happen...

# sub type_apply ...


### Type conversions

# Perhaps these should be arrays instead.

sub type_unsigned
{
  my ($type) = check_args(1, "type_unsigned", caller, @_);
  if (($type == $typeCHAR) || ($type == $typeSCHAR))
    { return $typeUCHAR; }
  elsif ($type == $typeSHORT)
    { return $typeUSHORT; }
  elsif ($type == $typeINT)
    { return $typeUINT; }
  elsif ($type == $typeLONG)
    { return $typeULONG; }
  else
    { return $type; }
}

sub type_signed
{
  my ($type) = check_args(1, "type_signed", caller, @_);
  if (($type == $typeCHAR) || ($type == $typeUCHAR))
    { return $typeSCHAR; }
  elsif ($type == $typeUSHORT)
    { return $typeSHORT; }
  elsif ($type == $typeUINT)
    { return $typeINT; }
  elsif ($type == $typeULONG)
    { return $typeLONG; }
  else
    { return $type; }
}

sub type_long
{
  my ($type) = check_args(1, "type_long", caller, @_);
  if ($type == $typeCHAR)
    { return $typeLONG; }
  elsif ($type == $typeUCHAR)
    { return $typeULONG; }
  elsif ($type == $typeSCHAR)
    { return $typeLONG; }
  elsif ($type == $typeSHORT)
    { return $typeLONG; }
  elsif ($type == $typeUSHORT)
    { return $typeULONG; }
  elsif ($type == $typeINT)
    { return $typeLONG; }
  elsif ($type == $typeUINT)
    { return $typeULONG; }
  elsif ($type == $typeLONG)
    { return $typeLONG; }
  elsif ($type == $typeULONG)
    { return $typeULONG; }
  else
    { return $type; }
}

# The "usual binary conversions"; H&S p. 176
# except that if types are identical, it returns them.
# Can also return short, ushort.
sub type_lub
{ my ($t1, $t2) = check_args(2, "type_lub", caller, @_);
  # This test works whether $t1, $t2 are numbers or strings
  if ($t1 eq $t2)
    { return $t1; }
  if (!is_number($t1))
    { $t1 = $typeUNKNOWN; }
  if (!is_number($t2))
    { $t2 = $typeUNKNOWN; }
  if ($t1 > $t2)
    { ($t1, $t2) = ($t2, $t1); }
  # If either $t1 or $t2 is a string, its numeric equivalent is zero
  if ($t1 == 0)			# 0 == $typeFAIL
    { return $typeFAIL; }
  if ($t2 == $typeUNKNOWN)
    { return $typeUNKNOWN; }
  if (($t2 == $typeLDOUBLE) || ($t2 == $typeDOUBLE) || ($t2 == $typeFLOAT)
      || ($t2 = $typeULONG) || ($t2 = $typeLONG)
      || ($t2 == $typeUINT) || ($t2 == $typeINT)
      || ($t2 == $typeUSHORT)  || ($t2 == $typeSHORT))
    { return $t2; }
  # Otherwise, differing char types.
  return $typeSHORT;
}

### Parsing types

# FIX: GJB
# Given a basetype and declarator string, return a type and an identifier.
sub parse_declarator
{ my ($basetype, $declarator) = check_args(2, "parse_declarator", caller, @_);
  if (!($declarator =~ /$identifier_re/o))
    { mdie("no word in declarator $declarator"); }
  my $id = $MATCH;
  my $prefix = $PREMATCH;
  my $suffix = $POSTMATCH;
  while ($id =~ /^$type_qualifier_re$/o)
    { if (!($suffix =~ /$identifier_re/o))
	{ mdie("no non-type-qualifier word in declarator $declarator"); }
      $id = $MATCH;
      $prefix .= $PREMATCH;
      $suffix = $POSTMATCH; }
  if (($suffix =~ /$identifier_re/o) && !($PREMATCH =~ /\[/))
    { mdie("multiple words in declarator $declarator"); }
  return ("$prefix($basetype)$suffix", $id);
}

# FIX: GJB
# Given a type string, return a type
sub parse_type
{ my ($type) = check_args(1, "parse_type", caller, @_);
  return $type;
}


###########################################################################
### Variables
###

## Integers:

## Five different kinds of line counts that we care about are:
# (physical,logical,ncnb_phys,cpp_phys,cpp_phys_code)
# We care about these five line counts, %cppcmdcount, $cpp_cmds
# in each of the 8 possible kinds of file-types
# Dimension 1: header file vs code file (use regexp-s)
# Dimension 2: method of inclusion: (input,arg,#include<>,#include"")
#              maybe only care about first 2 kinds vs. last 2 kinds
# Note: #include"" or <> is only our filetype if the file was included
# from another file we parsed and it was not given as an input/arg file
# Generalize the variables for each of these to be lists of eight values

# This enumeration gives indices into the lists

# 2 (1st dim) times 4 (2nd dim) file types
my $c_ft = 2 * 4;

my @ft_ALL = (0..$c_ft-1);

my ($ft_HEAD_INPUT, $ft_HEAD_ARG, $ft_HEAD_INCB, $ft_HEAD_INCQ,
    $ft_CODE_INPUT, $ft_CODE_ARG, $ft_CODE_INCB, $ft_CODE_INCQ) = @ft_ALL;

my %InclusionMethod_to_Index = 
  ("FromCmdLine" => $ft_HEAD_ARG,
   "FromStdin" => $ft_HEAD_INPUT,
   "FromInclude<>" => $ft_HEAD_INCB,
   "FromInclude\"\"" => $ft_HEAD_INCQ);

my $ft_HEAD_Start = $ft_HEAD_INPUT;
my $ft_CODE_Start = $ft_CODE_INPUT;

# make slices for common uses
my @ft_CODE = ($ft_HEAD_INPUT..$ft_HEAD_INCQ);
my @ft_HEAD = ($ft_CODE_INPUT..$ft_CODE_INCQ);
my @ft_NOT_INCLUDED = ($ft_HEAD_INPUT,$ft_HEAD_ARG,$ft_CODE_INPUT,$ft_CODE_ARG);
my @ft_INCLUDED = ($ft_HEAD_INCB,$ft_HEAD_INCQ,$ft_CODE_INCB,$ft_CODE_INCQ);
my @ft_CODE_NOT_INCLUDED = ($ft_CODE_INPUT,$ft_CODE_ARG);
my @ft_CODE_INCLUDED = ($ft_CODE_INCB,$ft_CODE_INCQ);
my @ft_HEAD_NOT_INCLUDED = ($ft_HEAD_INPUT,$ft_HEAD_ARG);
my @ft_HEAD_INCLUDED = ($ft_HEAD_INCB,$ft_HEAD_INCQ);

my @rg_logl_lines = (0) x $c_ft;
my @rg_phys_lines = (0) x $c_ft;
my @rg_ncnb_lines = (0) x $c_ft;
my @rg_cp_phys_lines = (0) x $c_ft;
my @rg_cp_phys_code_lines = (0) x $c_ft;

my @rg_cpp_cmds = (0) x $c_ft;

my @rg_cppcmdcounts = { "define" => 0 } x $c_ft;

#my $logical_lines = 0;		# line continuation doesn't increment
#my $physical_lines = 0;		# as they appear to tools
#my $ncnb_physical_lines = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines = 0;	# cpp physical lines
#my $cpp_physical_code_lines = 0; # cpp physical lines
#
## Not-include file version of the above
#my $logical_lines_ni = 0;	# line continuation doesn't increment
#my $physical_lines_ni = 0;	# as they appear to tools
#my $ncnb_physical_lines_ni = 0;	# non-comment, non-blank lines
#my $cpp_physical_lines_ni = 0;	# cpp physical lines
#my $cpp_physical_code_lines_ni = 0; # cpp physical lines


### These variables (cppBLAH) now get summed
# from the rg_XXX variables, above.
# See compute_global_cpp_sums

my $cpp_cmds;			# total preprocessor commands
my $cpp_cmds_ni;		# total preprocessor commands

# Initialize cppcmdcount{"define"} so that we don't get uninitialized values
# when we try processing the macros (in case there were no macros)
my %cppcmdcount = (); # number of uses of each cpp command
# cppcmdcount_ni is like cppcmdcount, but only for files listed on cmd line
# ni == "not includes"
my %cppcmdcount_ni = (); # number of uses of each cpp command


my $symtab_scopes = 0;		# the number of scopes, less the global scope
## Strings:
my $line = "";			# current line
# $lastline = "";			# the prior line
# $mname = 0;
# $margs = 0;
# $mdef = 0;

my $cBuiltinMacros = 0;		# The number of macros that we define
				# before parsing-- need to be sure not
				# to use the first $cBuiltinMacros elements of 
				# @mXXXXX arrays
my $cMacrosInTables = 0;
# Highly unlikely filename, used for $mfile[$i] for builtin macros
my $szBuiltInFakeFile = "%Built In%";

# %files_lines is a hash from filename to a list of elements like:
# (start_line, function_name, end_line)
my %files_lines;

# %functions is a hash from function name to a list of lists of (file,start,end)
my %functions;


# If remove "current" from these names, look for other vars of those names.
my $current_file;		# the current file name
my $current_ft_index;		# the index of the @ft_'s for the current file

# current_line_no is now a function
#my $current_line_no;		# the current line number
my $current_function;		# the current function
my $current_function_start_line; # the first line of the current function
				# (sometimes function headers span lines)

# cached values for which_function
# FIX: perhaps we can simulate static function variables
# by putting functions that need them after a "package" declaration
# to change their scope.  We might then need to access globals explicitly,
# but it could be worth it-- definitely if we move to separate files
my $wf_last_filename = "%EMPTY CACHE%";
my $wf_last_line_no = -1;
my $wf_last_index = -1;

# @files contains the list of files we want to process
# %files tells where the file got added
my @files;
my %files;
# files that are included should be pushed onto both @files and
# @files_included -- the latter is used only to prevent multiple inclusion
# @files, not this-- but that doesn't work right now for some reason.
my @files_included;

# Output field separator
my $outOFS;

# @include_path is a list of places to look for included files
use vars '@include_path';


## Note that the %macrosXXX are annotations per macro,
## whereas @mXXXX arrays are annotations per macro *definition*

# perhaps make %macros proper just index into other arrays.

# FIX: this data structure is especially HACKY
my %macros = ();	  # for each macro, list of indexes for info about it
			  # (first list element is number of following elements)

my %macros_c_undefs = ();	# hashes macro names to the number of times they
				# are #undef-d

# enumeration for the macros_uses indices
my ($i_usage_code, $i_usage_cpp) = (0..1);

my %macros_uses = ();		# hashes macro names to an array
                                # listing the number of times they are
                                # used in (code,cpp_directives)

# count of uses is half the number of keys in %macros_file_line_uses
my %macros_file_line_uses = ();	# hashes macro names to an array
				# where consecutive elements
                                # list the filename and line
				# on which it appears

# can compute the number of uses at global scope with macros_uses and
# the length of the list in macros_used_in_functions
my %macros_used_in_functions = (); # hashes macro names to list of 
				# file/functions that use it.  Will
				# contain same function name
				# repeatedly if the macro is used more
				# than once in that function.

# Also want to have summary info true about all definitions...
# FIX: This data structure of parallel arrays needs to be improved
use vars qw(@mname @margs @mbody @mfile @mline @mplines @mpclines
	    @mbody_noc %mfreevars @mfreefuns
	    @mdependenton @mexpansionuses @mtype @mcategory @mevilness);

# These are for aggregate information.  Keep it for all macros, or just
# those multiply defined?  Or put it in the other arrays?  (No.)
use vars qw(%mntype %mncategory);

# Macros which expand to their argument or the empty list, for function arg decls.
my %fun_decl_arg_macros;

## Debugging; should add more
my $fDebugCmdProcessing = $false;
my $fDebugCommentRemoval = $false;
my $debug_scopes = $false;
my $debug_type_match = $false;
my $debug_parse_function = $false;

## Command-line processing
use vars qw($opt_i $opt_I $opt_h $opt_v $opt_t $opt_d
	    $opt_D $opt_M $opt_S $opt_F $opt_C $opt_E 
	    $opt_u $opt_1 $opt_A $opt_a);
my $fIgnoreIncludes = $false;


###########################################################################
### Main loop routines
###

# These indicate the pass, for getline_handle_preprocessor_command.
# Since they're dynamically bound with "local", can't declare them with "my".
use vars qw($finding_macro_defs $getting_macro_call_types $merge_cpp_if_branches);
$finding_macro_defs = $false;
$getting_macro_call_types = $false;
$merge_cpp_if_branches = $false;

# For getline():
# These can't be declared with "my" because they're dynamically bound
use vars qw($getline_nocomment $getline_simplify $getline_nocpp $getline_physical_lines $getline_physical_code_lines);
$getline_nocomment = $false;
$getline_simplify = $false;
$getline_nocpp = $false;
my @getline_ungotlines = ();
#gd# my @getline_ungotdependenton = ();

my @dependenton = ();
# Need a stack of old dependentons, for use by ungetline?  Or maybe just
# let peek_line take an optional argument.  No, I decided against having
# peek_line do any macro processing.


### Read files, save info about macros
sub find_macro_definitions
{
  check_args(0, "find_macro_definitions", caller, @_);
  if ($finding_macro_defs)
    { mdie("Called find_macro_definitions, but already finding macrodefs"); }
  local $finding_macro_defs = $true;
  my $ifiles = 0;
# Do not use a foreach, since we're pushing on to the end of @files,
#   and the list foreach uses does not get updated
#  foreach $this_file (@files)
  for (; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      $current_ft_index = compute_current_ft_index($current_file);

      print STDERR "file: \"$current_file\"" if $opt_v;  
      if (!open(INPUT,$current_file)) {
	print STDERR " -- failed open\n" if $opt_v;
	next; # skip to next file if open fails
      } else {
	print STDERR "\n" if $opt_v;
      }

      # Commented out to quiet compiler
      # $files{$current_file} = 1;
      if (@dependenton > 0)
	{ mdie("In \#if at beginning of file: @dependenton"); }
      while ($line = getline())
	{
	  # Amazingly enough, all the work is done by getline, which
	  # calls process_macro_definition.
	}
      if (@dependenton > 0)
	{ mdie("Still in \#if at end of file: @dependenton"); }
      close(INPUT);
    }
}

# Given a macro definition (everything after "#define", with no leading,
# trailing space), enter it into the appropriate global arrays
sub process_macro_definition
{
  my ($def,$macro_physical_lines,$macro_physical_code_lines) = check_args(3, "process_macro_definition", caller, @_);
  # print "process_macro_definition <<$def>>\n";
  my ($name, $args, $body) = macroparse($def);
  # print STDERR "PARSED: $name\n";
  if (!defined($args)) { $args = ""; }
  # print "parsed: |$name|$args|$body|\n";
  # Do not just use $cppcmdcount{"define"}, since our builtins require
  # some space in the @mXXXXX arrays
  my ($thisnum) = next_available_macro_index();

  # initialize all the parallel arrays here,
  # so that we don't have to check the defined-ness later
  if (!defined($macros{$name}[0])) {
    $macros{$name}[0] = 0;
    $macros_c_undefs{$name} = 0;
    $macros_uses{$name} = [0,0];
    $macros_used_in_functions{$name} = [];
    $macros_file_line_uses{$name} = [];
  }


  $macros{$name}[0] += 1;
  $macros{$name}[$macros{$name}[0]] = $thisnum;
  # print "def number $macros{$name}[0]:";
  # for ($i = 1; $i <= $macros{$name}[0]; $i++)
  #   { print " $macros{$name}[$i]"; }
  # print "\n";
  $mname[$thisnum] = $name;
  $margs[$thisnum] = $args;
  $mbody[$thisnum] = $body;

  # We track both the physical lines in a macro definition
  # (mplines) which is the extent of the macro (where it appears
  # in the file) and the physical code lines (mpclines)
  # which does not count comment only lines in a macro definition
  # eg.
  # --begin, non-inclusive--
  # #define BOOL int /* we do not
  #                     have a built
  #                     in type so we
  #                     use bool */
  # --end, non-inclusive--
  # would count as 4 physical lines, 1 ncnb (non-comment,non-blank)
  # line, 1 cpp_physical_code_line, and 4 cpp_physical_lines

  $mplines[$thisnum] = $macro_physical_lines;
  $mpclines[$thisnum] = $macro_physical_code_lines;
  # FIX: this is a hack
  # @mdependenton[$thisnum] = @dependenton;
  { my $i;
    $mdependenton[$thisnum][0] = @dependenton;
    for $i (0..$#dependenton)
      { $mdependenton[$thisnum][$i] = $dependenton[$i]; } }
  if (!defined($current_file))
    { mdie("undefined current_file"); }
  $mfile[$thisnum] = $current_file;
  $mline[$thisnum] = current_line_no();
  # PERLNOTE: be careful not to do
  # $mexpansionuses[$thisnum] = ();  ##WRONG
  # you'll get a wierd error message at the point of use
  @{$mexpansionuses[$thisnum]} = ();
}


# process_macro_undefinition is called to handle #undef-s
sub process_macro_undefinition {
  my ($cpp_cmd_args) = check_args(1,"process_macro_undefinition",caller,@_);

  # Pull out first word
  $cpp_cmd_args =~ /^(\w+)\b/;
  my $macro_name  = $1;

  $macros_c_undefs{$macro_name}++;
}

# Given a macro name, try to merge the dependentons for all its definitions,
# and return a single dependenton or $false.
# Hack: optionally takes an additional @dependenton to merge with the macros.
sub macro_dependenton
{
  my ($macro_name, @dependenton) = check_args_at_least(1, "macro_dependenton", caller, @_);
  my @indices = @macros{$macro_name};
  shift(@indices);
  my @result = ($false);
  # scratch indices, since I must pass in at least one index.
  my $extraindexmin = next_available_macro_index() + 10;
  my $extraindexmax = $extraindexmin-1;
  if (@dependenton > 0)
    { $extraindexmax++;
      # FIX: this is a hack
      # @mdependenton[$extraindexmax] = @dependenton;
      { my $i;
	$mdependenton[$extraindexmax][0] = @dependenton;
	for $i (0..$#dependenton)
	  { $mdependenton[$extraindexmax][$i] = $dependenton[$i]; } }
      push(@indices, $extraindexmax); }
MDLOOP:
  if (@indices == 1)
    { @result = @mdependenton[$indices[0]]; # protect from undef below
      goto MDDONE; }
  my $index1;
  my $index2;
  for $index1 (0..$#indices-1)
    { for $index2 ($index1+1..$#indices)
	{ my @merged = merge_dependenton($index1, $index2);
	  if ((@merged == 1) && !$merged[0])
	    { goto MDDONE; }
	  else
	    { $extraindexmax++;
	      # FIX: this is a hack
	      # @mdependenton[$extraindexmax] = @merged;
	      { my $i;
		$mdependenton[$extraindexmax][0] = @merged;
		for $i (0..$#dependenton)
		  { $mdependenton[$extraindexmax][$i] = $merged[$i]; } }
	      goto MDLOOP; } } }

MDDONE:
 { my $i;
   for $i ($extraindexmin..$extraindexmax)
     { undef $mdependenton[$i][0]; } }

  # Is there any point to this??
  if ((@result == 1) && !$result[0])
    { return $false; }
  else
    { return @result; }
}


# Takes an index and a dependenton array.
# If the dependentons are the same for all but the last element, return all
# but thatlast element.  Otherwise return $false.
sub merge_dependenton
{ my($index, @do2) = check_args_at_least(1, "merge_dependenton", caller, @_);
  if (!dependenton_single_difference($index, @do2))
    { return $false; }
  # Return @do1.
  my @do1;
  # FIX: this is a hack
  # @do1 = @mdependenton[$index];
  { my $i;
    for $i (0..$mdependenton[$index][0])
      { $do1[$i] = $mdependenton[$index][$i]; } }
  pop(@do1);
  return @do1;
}


sub dependenton_single_difference
{ my($index, @do2) = check_args_at_least(1, "merge_dependenton", caller, @_);
  my @do1;
  # FIX: this is a hack
  # @do1 = @mdependenton[$index];
  { my $i;
    for $i (0..$mdependenton[$index][0])
      { $do1[$i] = $mdependenton[$index][$i]; } }
  if ((@do2 == 1) && is_num($do2[0]))
    { @do2 = @mdependenton[$do2[0]]; }

  if ($#do1 != $#do2)
    { return $false; }
  { my $i;
    for $i (0..$#do1-1)
      { if ($do1[$i] ne $do2[$i])
	  { return $false; } } }
  if ($do1[$index] ne negate_if_condition($do2[$index]))
    { return $false; }
  return $true;
}


# These dependenton functions take a macro name and a dependenton array and
# compare the macro's dependenton to the one passed in.  Perhaps also permit
# the passed in array to instead itself be a macro name.

## This isn't really enough; we need to canonicalize macro dependence
## information, perhaps even make it order-independent.
sub dependenton_identical
{
  my ($macro_name, @depend) = check_args_at_least(1, "dependenton_identical", caller, @_);
  my @macro_depend = macro_dependenton($macro_name);
  if ($#depend != $#macro_depend)
    { return $false; }
  { my $i;
    for $i (0..$#depend)
      { if ($depend[$i] ne $macro_depend[$i])
	  { return $false; } } }
  return $true;
}




# potential problem:  if arg == "!(!(...))", then  (nif(nif($arg)) ne $arg)
sub negate_if_condition
{
  my ($cond) = check_args(1, "negate_if_condition", caller, @_);
  if ($cond =~ /^!\((.*)\)$/)
    { return $MATCH; }
  else
    { return "!($cond)"; }
}

# Print all the output statistics to the various streams
# FIX: these sub-parts might better be broken up into functions
# FIX: use "select" instead of print FILEHANDLE repeatedly
#FIX: Get stats on number of macros only #undef-d, etc.
sub output_stats
{
  check_args(0, "output_stats", caller, @_);
  
  if (defined($outOFS)) {
    $OFS = $outOFS;
  } else {
    $OFS = " ";
  }

  my $logical_lines = sum_array(@rg_logl_lines);
  my $physical_lines = sum_array(@rg_phys_lines);
  my $ncnb_physical_lines = sum_array(@rg_ncnb_lines);
  my $cpp_physical_lines = sum_array(@rg_cp_phys_lines);
  my $cpp_physical_code_lines = sum_array(@rg_cp_phys_code_lines);  

  my $logical_lines_ni = 
    sum_array(@rg_logl_lines[@ft_NOT_INCLUDED]);
  my $physical_lines_ni =
    sum_array(@rg_phys_lines[@ft_NOT_INCLUDED]);
  my $ncnb_physical_lines_ni =
    sum_array(@rg_ncnb_lines[@ft_NOT_INCLUDED]);
  my $cpp_physical_lines_ni =
    sum_array(@rg_cp_phys_lines[@ft_NOT_INCLUDED]);
  my $cpp_physical_code_lines_ni =
    sum_array(@rg_cp_phys_code_lines[@ft_NOT_INCLUDED]);  
  
  if ($logical_lines == 0) {
    print STDERR "No lines read! Perhaps you meant to use the -i option?\n";
    return;
  } 

  if ($opt_S) {
    my ($h, $v);
    # Dump statistics on frequencies of directives
    printf STATS "#DIRECTIVESNI#: ";
    while ( ($h,$v) = each(%cppcmdcount_ni) ) {
      print STATS "$h ";
    }
    print STATS "\n";
    printf STATS "DIRECTIVESNI: ";
    while ( ($h,$v) = each(%cppcmdcount_ni) ) {
      print STATS "$v ";
    }
    print STATS "\n";
    print STATS "DIRECTIVESNI%LL: ";
    while ( ($h,$v) = each(%cppcmdcount_ni) ) {
      printf STATS "%2.2f ", pct2($v,$logical_lines_ni);
    }
    print STATS "\n";

    print STATS "DIRECTIVESNI%NCNB: ";
    while ( ($h,$v) = each(%cppcmdcount_ni) ) {
      printf STATS "%2.2f ", pct2($v,$ncnb_physical_lines_ni);
    }
    print STATS "\n";

    print STATS "DIRECTIVESNI%PHYS: ";
    while ( ($h,$v) = each(%cppcmdcount_ni) ) {
      printf STATS "%2.2f ", pct2($v,$physical_lines_ni);
    }
    print STATS "\n";
    
    print STATS "#LINES#: physical logical ncnb_phys cpp_phys cpp_phys_code\n";
    print STATS "$physical_lines $logical_lines $ncnb_physical_lines $cpp_physical_lines $cpp_physical_code_lines\n";
    print STATS "#LINESNI#: physical logical ncnb_phys cpp_phys cpp_phys_code\n";
    print STATS "$physical_lines_ni $logical_lines_ni $ncnb_physical_lines_ni $cpp_physical_lines_ni $cpp_physical_code_lines_ni\n";
    # printf STATS "EVILSTATS: $cObsoleted obsoleted (%2.2f%), $cDanger dangerous (%2.2f%), $cEvil evil (%2.2f%), $cIllegal illegal (%2.2f%)\n",
    # pct($cObsoleted), pct($cDanger), pct($cEvil), pct($cIllegal);
    
    # Show categorization
    #print STATS "CATEGORIZATION:";
    #my $catname;
    #foreach $catname (@categoryname) {
    #  print STATS "\t$catname"; 
    #}
    #print STATS "\n";
    ##print STATS "CATEGORIZATION#:";
    # Need to count up total numbers for each categorization.
    # print STATS "CATEGORIZATION: $cppcmdcount{"define"} $cNullDefine $cPreventMI $cSimpleConstant $cSimpleConstantWithDefault $cSimpleStrConstant $cCastedConstant $cSimpleExpression $cWithNullArgs $cWithArgs $cUncategorized\n";
    print STATS "\n";
  }
  
  # -M = dump the macro stats
  if ($opt_M) {
    my $name;
    select MACROS;
    # FIX: add function/global uses
    print  "#MACROS#: name cDefs cUndefs cCodeUses cCppUses (%functionsThatUseIt)\n";
    foreach $name (sort keys %macros) {
      #print STDERR "MNAME=$name, @{$macros{$name}}\n";
      my $i = $macros{$name}[1];
      die "i not defined for $name" if (!defined($i));
      next if ($mfile[$i] eq $szBuiltInFakeFile);
      die if (!defined($macros_uses{$name}));
      die if (!defined($macros_c_undefs{$name}));
      die if (!defined($macros_uses{$name}));
      die if (!defined($macros_used_in_functions{$name}));

      # FIXPERL: cperl mode doesn't count , as a statement continuer
      # in a print

      print "$name", $macros{$name}[0], $macros_c_undefs{$name},
      $macros_uses{$name}[$i_usage_code], 
      $macros_uses{$name}[$i_usage_cpp], "\n%" .
        join("\n%",@{$macros_used_in_functions{$name}}),
        "\n";
    }
  }

  if ($opt_D) {
    select DEFINES;
    my $name;
# don't want extra lines-- harder for postprocessing tools
#    print  "\n";
    # FIX: add $mncategory, $mntype
    print "#DEFINITIONS#: name iDef file line args plines pclines (%macrosUsedInExpansion)\n";
    foreach $name (sort keys %macros) {
      # Could also print number of times it's defined.
      my $iDef = 1;
      for ( ; $iDef <= $macros{$name}[0]; $iDef++ ) {
	my $i = $macros{$name}[$iDef];
	if ($mfile[$i] ne $szBuiltInFakeFile) {
	  #print STDERR "NAME=$name,", join(", ",@{$macros{$name}}),"\n";
	  print "$name", $iDef, $i, $mfile[$i], $mline[$i], count_macro_args($margs[$i]),
	  $mplines[$i], $mpclines[$i], "\n%" . 
	    join("\n%",@{$mexpansionuses[$i]}), "\n";
	}
      }
    }
  }
  
  # -F = dump the function information
  if ($opt_F) {
    my $filename;
    foreach $filename (sort keys %files_lines) {
      print FUNCTIONS "file: $filename\n", join("\n ",@{$files_lines{$filename}}), "\n";
    }
    my $function;
    foreach $function (sort keys %functions) {
      my $info;
      print FUNCTIONS "function: $function ";
      foreach $info (@{$functions{$function}}) {
	print FUNCTIONS join(', ',@$info);
      }
      print FUNCTIONS "\n";
    }
    
    # FIXPERL: Why does this give me an unitialized variable warning?
    # undef $OFS if (defined($OFS));
  }
}


# pct2(x) returns an integer corresponding to a pct of the first arg of the 2nd arg
sub pct2 {
  my ($x,$w) = check_args(2, "pct2", caller, @_);
  if ($w <= 0) { 
    print STDERR "pct2: Divisor out of range: $x / $w\n";
    return 0;
  }
  if ($x < 0 || $x > $w) {
    print STDERR "pct2: Percentage out of range: $x / $w\n";
  }
  return (100*$x/$w);
}


# sum_array just sums all the elements of an array
# pass in a slice if you only want part of the array summed
sub sum_array {
  check_args_at_least(0,"sum_array", caller, @_);
  my $sum = 0;
  my $i = 0;
  for (; $i <= $#_; $i++) {
    $sum += $_[$i];
  }
  return $sum;
}

# FIX: Comment this better
sub test_typedecl_regexp
{
  check_args(0, "test_typedecl_regexp", caller, @_);
  my $ifiles = 0;
#  foreach $this_file (@files)
  for (; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      $current_ft_index = compute_current_ft_index($current_file);
      if ($opt_v)
	{ print STDERR $current_file . "\n"; }
      open(INPUT,$current_file) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$current_file} = 1;
      if (@dependenton > 0)
	{ mdie("In \#if at beginning of file: @dependenton"); }
      while ($line = getline())
	{ if ($line =~ /^$type_specifier_re/o)
	    { print "ts: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re/o)
	    { print "td: <<$MATCH>> $line"; }
	  if ($line =~ /^$type_declarator_re\s*[,=;\(]/o)
	    { print "td+: $line"; }
	}
      if (@dependenton > 0)
	{ mdie("Still in \#if at end of file: @dependenton"); }
      close(INPUT);
    }
}



###########################################################################
### Parsing
###

my $incomment = $false;		# in /* */ style comment
my $instring = $false;
my $uiv_seen_code = $false;

# Shouldn't be in a character constant across lines.
# my $incharconst = $false;
use vars '$commaop';		# not "my" because dynamically bound
$commaop = $true;		# whether commas should be operators or not
				# (they shouldn't in arglists, initializers)


# Uses globals $getline_nocomment and $getline_simplify.
#   If $getline_nocomment is set, then comments are stripped from result.
#   If $getline_simplify is set, then character and string literals are
#     replaced by 'a' and "", respe respectively.  That lets us do a simple
#     syntactic check for parens, braces, commas, etc., obviating the need
#     for has_token, which redoes all this work anyway.
# If calls to ungetline have been made, those strings are returned (uses
#   global @getline_ungotlines), without any processing of comments or
#   literals, but with macro preprocessor command processing.  peek_line
#   avoids macro preprocessor command processing by setting $getline_nocpp.
# To simplify an arbitrary string, use updateinvars.

# Read the next logical line from <INPUT>, until no continuation char
#   and not in string or comment.
# Result ends with newline.
# With argument, doesn't pop (actually, shift) from getline_ungotlines.
#
# FIX: when simplifying (2nd pass), we need to remove the chars betwen < & >
# on a #include line-- they act like quotes -- MERNST do this in updateinvars
sub getline
{ my ($dont_pop) = check_args_range(0, 1, "getline", caller, @_);
  if (!defined($dont_pop))
    { $dont_pop = $false; }
  $getline_physical_lines = 0;
  $getline_physical_code_lines = 0;

  if ($instring || $incomment)
    { mdie("Bad instring $instring or incomment $incomment"); }

  my $result;
  if ((@getline_ungotlines > 0) && (!$dont_pop))
    { # print "popping getline_ungotlines $getline_ungotlines[$#getline_ungotlines]"; # no newline: it ends with one
      # print "all ungotlines: <<", join(">><<", @getline_ungotlines), ">>\n";
      #gd# @dependenton = shift(@getline_ungotdependenton);
      #gd# return shift(@getline_ungotlines);
      $result = shift(@getline_ungotlines);
      $getline_physical_lines++;
    }
  else
    { if (not ($result = <INPUT>)) #do not update physical lines -- failed read
	{ return $result; }
      $getline_physical_lines++;
      if ($finding_macro_defs) {
	$rg_logl_lines[$current_ft_index]++;
      }

      $result = updateinvars($result);
      # perhaps check for $mname and mention it in message if it's set
      while ($incomment || $instring || ($result =~ m/\\$/))
	{
	  # splice lines
	  while ($result =~ m/\\$/)
	    {			# block to localize match data
	      { if ($result =~ m/\\\Z(?!\n)/) # backslash, end of string, no newline
		  { evilprint("evil: file ends with backslash (no newline)\n"); } }
	      $result = $PREMATCH;	# remove backslash and possibly newline
	      my $nextline;
	      if ($nextline = <INPUT>)
		{ $getline_physical_lines++;
		  # Not a logical line-- do not increment it
		  $nextline = updateinvars($nextline);
		  $result = append_lines($result, $nextline);
		  # The append_lines trims trailing spaces, prettying the message.
		  if ($nextline =~ m/^\s*$/)
		    {		# No \n at end: $result ends in a newline
		      evilprint("dangerous: blank line follows continuation character:\n    $result"); }
		}
	      else
		# Already removed backslash and newline from result.
		# (Should I add them back?)
		{ evilprint("dangerous: file ends with continuation character:\n    $result\n"); } }

	  while ($incomment)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $getline_physical_lines++;
		  if ($finding_macro_defs) {
		    $rg_logl_lines[$current_ft_index]++;
		  }
		  $nextline = updateinvars($nextline);
		  $result = append_lines($result, $nextline); }
	      else
		{ evilprint("dangerous: file ends in comment:\n    $result");
		  $incomment = $false; } }

	  # Not "while ($instring) ..." because processing continuation lines
	  # takes priority over simple concatenation.
	  if ($instring)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $getline_physical_lines++;
		  if ($finding_macro_defs) {
		    $rg_logl_lines[$current_ft_index]++;
		  }
		  $nextline = updateinvars($nextline);
		  # Strict ANSI C does not permit newlines in string constants;
		  # perhaps warn.
		  # Not "$result = append_lines($result, $nextline);" because in string.
		  $result = $result . $nextline;
		}
	      else
		{ evilprint("dangerous: file ends in string:\n    $result\n");
		  $instring = $false; } }
	} }

  #print STDERR "GETLINE $getline_physical_lines, $finding_macro_defs: $result";
  if ($finding_macro_defs) {
    $rg_phys_lines[$current_ft_index] += $getline_physical_lines;
  }

  # FIX: maybe we should have variables $firstPass, $secondPass, or $pass_num
  #      instead of checking $finding_macro_defs, or $getting_macro_call_types

  # look for uses only on the second pass,
  if ($getting_macro_call_types) {
    # and also only if -a is set or this is a project file
    # don't do it if -u is set (user want to ignore usage)
    if (!$opt_u && ($opt_a || !current_file_was_included())) {
      analyze_for_macro_use($result);
    }
  }

  if (($result =~ /^\#/) && !$getline_nocpp)
    { # Preprocessor line; usually just return "\n";
      if ($finding_macro_defs) {
	$rg_cp_phys_lines[$current_ft_index] +=
	  $getline_physical_lines;
	$rg_cp_phys_code_lines[$current_ft_index] +=
	  $getline_physical_code_lines;
      }
      return getline_handle_preprocessor_line($result);
    }

  if ($result eq "")
    { mdie("empty getline result"); }
  # print "getline returning <<$result>>\n"; # $result ends in newline
  return $result;
}

# Users shouldn't use this, because they won't be able to correctly set
# getline_ungotdependenton.
# sub ungetline
# {
#   my ($ungotline) = @_;
#   check_args(0, "ungetline", caller, @_);
#   push (@getline_ungotlines, $ungotline);
# }

#gd# This clever saving and restoring of @dependenton is neat and all that, but
#gd# perhaps misguided.  Instead, change the contract of peek_line to never do
#gd# any preprocessor processing, and have getline do it when the line is gotten
#gd# for real.
sub peek_line
{
  my ($arg) = check_args(1, "peek_line", caller, @_);
  if (!defined($arg))
    { $arg = 1; }

  #gd# if (@getline_ungotlines != @getline_ungotdependenton)
  #gd#   { mdie("different lengths for ungot{lines,dependenton} " . scalar(@getline_ungotlines) . " @getline_ungotlines ||| " . scalar(@getline_ungotdependenton) . " @getline_ungotdependenton"); }

  if ($arg <= @getline_ungotlines)
    { # We have previously peeked at the line in question
      my $index = @getline_ungotlines-$arg;
      #gd#       return($getline_ungotlines[$index], $getline_ungotdependenton[$index]);
      return($getline_ungotlines[$index]); }
  else
    { if ($arg < (@getline_ungotlines + 1))
	{ # Recursively fill up the arrays
	  # Actually, this should never happen:  why  would one look two
	  # lines ahead before checking the next line?
	  mdie("Why look far ahead when you haven't looked near?  $arg " . scalar(@getline_ungotlines))
;
	  peek_line($arg-1); }
      if ($arg != (@getline_ungotlines + 1))
	{ mdie("This can't happen"); }

      # Do the real work.
      #gd# local @dependenton = @dependenton; # tricky!
      #gd# if (@getline_ungotdependenton == 0)
      #gd#   { @dependenton = $getline_ungotdependenton[$#getline_ungotdependenton]; }
      my $nextline;
      { local $getline_nocpp = $true;
	# print "peeking about to call getline\n";
	$nextline = getline("don't pop"); }
      # print "peeking found $nextline";
      #gd# $getline_ungotdependenton[$#getline_ungotdependenton+1] = @dependenton;
      push (@getline_ungotlines, $nextline);
      #gd# return($nextline, @dependenton);
      # print "peek_line($arg) returning $nextline";
      return($nextline); }
}


# Takes a simplified line as its argument; returns a string containing the
# unbalanced braces (empty string if all braces are balanced).
sub brace_change
{ my ($line) = check_args(1, "brace_change", caller, @_);
  # print "brace_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\{\}]/)
    { $result_chars .= $MATCH;
      if ($MATCH eq "\{")
	{ $result_num++; }
      elsif ($MATCH eq "\}")
	{ $result_num--; }
      else
	{ mdie("What match? $MATCH"); }
      $line = $POSTMATCH; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Takes a simplified line as its argument; returns a string containing the
# unbalanced parens (empty string if all parens are balanced).
# Perhaps this should also check for braces (and complain or err if any are
# found before parens balance).
sub paren_change
{ my ($line) = check_args(1, "paren_change", caller, @_);
  # print "paren_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\(\)]/)
    { $result_chars .= $MATCH;
      if ($MATCH eq "\(")
	{ $result_num++; }
      elsif ($MATCH eq "\)")
	{ $result_num--; }
      else
	{ mdie("What match? $MATCH"); }
      $line = $POSTMATCH; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Return index of first close paren which doesn't match a preceding open
# paren in the argument string, and the argument string.  Ignores strings, braces, etc.
# Optional second argument says where to start (right after the open, usually).
# Optional third argument says whether to read lines to try to balance (in which
# case the second return value can differ from the first).
sub find_close_paren
{ my ($exp, $pos, $read) = check_args_range(1, 3, "find_close_paren", caller, @_);
  if (!defined($pos))
    { $pos = 0; }
  if (!defined($read))
    { $read = $false; }
  # print "find_close_paren: $exp\n";
  my $opens = 1;
  my $brace_pos;			# undefined if no brace found
  { my $open_pos = index($exp, "\{", $pos);
    my $close_pos = index($exp, "\}", $pos);
    $brace_pos = ($open_pos == -1) ? $close_pos : ($close_pos == -1) ? $open_pos : min($open_pos, $close_pos);
    if ($brace_pos == -1)
      { undef($brace_pos); } }

  while ($opens > 0)
    { my $next_open = index($exp, "\(", $pos);
      my $next_close = index($exp, "\)", $pos);
      # print "next_open $next_open next_close $next_close\n";
      if (($next_close != -1)
	  && (($next_open == -1) || ($next_close < $next_open)))
	{ if (defined($brace_pos) && ($next_close > $brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  $opens--;
	  $pos = $next_close+1; }
      elsif (($next_open != -1)
	     && (($next_close == -1) || ($next_open < $next_close)))
	{ if (defined($brace_pos) && ($next_open > $brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  $opens++;
	  $pos = $next_open+1;
	  # print "open paren at $next_open, opens = $opens, pos = $pos\n";
	}
      else
	{ if (!(($next_open == -1) && ($next_close == -1)))
	    { mdie("bad values for next_open $next_open and next_close $next_close"); }
	  # print "didn't find next paren, opens = $opens\n";
	  if (!$read)
	    { mdie("insufficient closing parens in $exp"); }
	  if (defined($brace_pos))
	    { mdie("Found brace before matching paren in $exp"); }
	  my $nextline = getline();
	  # print "*** read in find_close_paren: $nextline";
	  if ($nextline =~ /[\{\}]/)
	    { if (!defined($brace_pos))
		{ $brace_pos = length($exp); }
	      $brace_pos += length($PREMATCH);
	      if (!(substr($exp . $nextline, $brace_pos, 1) =~ /[\{\}]/))
		{ mdie("I just found a brace at position $brace_pos of $exp$nextline"); } }
	  # print "find_close_paren appending $nextline";
	  $exp .= $nextline; } }
  return ($pos - 1, $exp);
}


# updateinvars exists for the purposes of getline, but may be called by others,
#	particularly to remove comments or simplify string/character literals.
# Obeys global variables $getline_nocomment and $getline_simplify; see their
#	documentation at getline.
# Result differs from input only if one of them is set.
# All backslash line continuations have already been processed.
sub updateinvars
{
  my ($remaining) = check_args(1, "updateinvars", caller, @_);
  my $result;
  my $computeresult = ($getline_nocomment || $getline_simplify);
  $uiv_seen_code = $false;

  if ($computeresult)
    { $result = ""; }
  else
    { $result = $remaining; }

  # print "updateinvars ($computeresult) $remaining"; # $remaining ends w/newline
  while ($remaining)
    { if ($incomment)
	{ if ($remaining =~ /\*\//)
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $PREMATCH . $MATCH; }
	      $remaining = $POSTMATCH;
	      $incomment = $false; }
	  else
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $remaining; }
	      goto UIV_RETURN; } }
      elsif ($instring)
	{ $uiv_seen_code = $true;
	  # print "in string, processing $remaining";
	  if ($remaining =~ m/$non_escaped_double_quote_re/o)
	    # Found a non-escaped double quote
	    { # print "non-escaped double quote: $result|$remaining|$PREMATCH|$MATCH|$POSTMATCH\n";
	      if ($computeresult)
		{ if ($getline_simplify)
		    { $result .= "\""; }
		  else
		    { $result .= $PREMATCH . $MATCH; } }
	      # print "post-nonescdquote: $result|$remaining\n";
	      $remaining = $POSTMATCH;
	      $instring = $false; }
	  else
	    { # print "$current_file:@{[ current_line_no() ]}: in string after line $_[0]";
	      if ($computeresult && !$getline_simplify)
		{ $result .= $PREMATCH . $MATCH; }
	      goto UIV_RETURN; } }
      # If not instring, \" suffices instead of the more complicated
      # regexp that checks for leading backslashes.
      elsif ($remaining =~ m/\/[\*\/]|[\'\"]/) #'HACKCOLOR
	{ my $match = $MATCH;
	  my $postmatch = $POSTMATCH;
	  if ($computeresult)
	    { $result .= $PREMATCH; }
	  if ($match eq "\'")
	    { if ($postmatch =~ m/^$char_literal_contents_re\'/o)
		{ if ($computeresult)
		    { if ($getline_simplify)
			{ $result .= "'a'"; }
		      else
			{ $result .= "'" . $MATCH; } }
		  $remaining = $POSTMATCH; }
	      else
                # No newline, since $_[0] has one.
		{ evilprint("illegal: bad character constant $match$postmatch\n    in $_[0]");
		  if ($postmatch =~ /\'/)
		    { if ($computeresult)
			{ if ($getline_simplify)
			    { $result .= "'a'"; }
			  else
			    { $result .= "'" . $MATCH; } }
		      $remaining = $POSTMATCH; }
		  else
		    { $remaining = $postmatch; } } }
	  elsif ($match eq "\"")
	    { if ($computeresult)
		{ $result .= $match; }
	      $remaining = $POSTMATCH;
	      $instring = $true; }
	  elsif ($match eq "//")
	    { if ($PREMATCH !~ /^\s*$/)
		{ $uiv_seen_code = $true; }
	      if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      goto UIV_RETURN; }
	  elsif ($match eq "/*")
	    { $remaining = $POSTMATCH;
	      if ($PREMATCH !~ /^\s*$/)
		{ $uiv_seen_code = $true; }
	      if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      $incomment = $true; }
	  else
	    { mdie("updateinvars: what match?  $match in $_[0]\n"); } }
      else
	{ if ($remaining !~ /^\s*$/)
	    { $uiv_seen_code = $true; }
	  if ($computeresult)
	    { $result .= $remaining; }
	   goto UIV_RETURN; }
    }
  
  UIV_RETURN: 
  if ($uiv_seen_code) {
    if ($finding_macro_defs) {
      $rg_ncnb_lines[$current_ft_index]++;
    }
    $getline_physical_code_lines++;
    #print STDERR "SC: $result" if $finding_macro_defs;
  }
  return $result;
}

# All backslash line continuations have already been processed; no
# nonterminated strings, comments, or character constants.
# Result does NOT end in newline
sub remove_comments
{
  my ($input) = check_args(1, "remove_comments", caller, @_);
  local $getline_nocomment = $true;
  local $getline_simplify = $false;
  my $result = updateinvars($input);
  if ($instring || $incomment)
    { mdie("Bad string passed to remove_comments: instring $instring incomment $incomment"); }
  return $result;
}


# This isn't needed any longer, because a simplified string has no
# comments, strings, or character literals to confuse a simplistic check.
# (Don't remove it yet, though, just in case we need it later.)
# # Assumes no comments
# sub has_token
# {
#   my ($token, $line) = @_;
#   check_args(1, "has_token", caller, @_);
#   if (!defined($token)) { mdie("undefined token, line $line\n"); }
#   if (!defined($line)) { mdie("undefined line, token $token\n"); }
# 
#   # Check for character constants to avoid processing " in one.
# 
#   # If not instring, I think \" suffices instead of the more complicated
#   # regexp that checks for leading backslashes.
#   while (($line =~ m/[\"\']/) #'HACKCOLOR
# 	 # should regexp-quote $token
# 	 || ($line =~ m/\Q$token\E/))
#     { my $match = $MATCH;
#       $line = $POSTMATCH;
#       print "has_token($token) matched $match before $line\n";
#       if ($match eq $token)
# 	{ return $true; }
#       elsif ($match eq "\"")
# 	{ if ($line =~ /$non_escaped_double_quote_re/o)
# 	    { $line = $POSTMATCH; }
# 	  else
# 	    { mdie("Didn't find end of string literal $line.\n"); } }
#       elsif ($match eq "'")
# 	{ if ($line =~ /^$char_literal_contents_re\'/o)
# 	    { $line = $POSTMATCH; }
# 	  else
# 	    { mdie("Didn't find end of character literal $line.\n"); } }
#       else
# 	{ mdie("What match $match in $line\n"); } }
#   return $false;
# }


# Returns the line that should be the getline result, usually "\n";
sub getline_handle_preprocessor_line
{
  my ($line) = check_args(1, "getline_handle_preprocessor_line", caller, @_);
  if ($line =~ /^\#\s*$/)
    { # null preprocessor command; do nothing
      return "\n";
    }
  # Maybe also check for (0 === 1), or macro that
  # always expands to 0; but that is probably overkill.
  elsif ($line =~ /^\#\s*ifdef\s+(0|\(0\))\s*$/)
    { discard_to_endif();
      return "\n"; }
  elsif ($line =~ m/^\#\s*($identifier_re)\s*/o)
    { # Found a real preprocessor command
      my $cpp_cmd = $1;
      $line = $POSTMATCH;
      $line =~ s/\s+$//;	# remove trailing whitespace
      return getline_handle_preprocessor_command($cpp_cmd, $line); }
  else
    { mdie("Strange preprocessor line $line"); }
}

# This is a catchall for everything that has to be done to a preprocessor line.
# It's a bit gross to do it this way, but it seems most expedient.
# Always do:
#  * set @dependenton
# Sometimes do:
#  * if $finding_macro_defs, then in first pass, so
#      * for each use of the preprocessor, set $cppcmdcount
#      * for each #define, call process_macro_definition
#  * if $getting_macro_call_types, then in second pass, so
#      * at present, do no extra work
#  * if $merge_cpp_ if_branches, then try to merge #if ... #else ... #endif
#
# Control the action via the following variables: ...
sub getline_handle_preprocessor_command
{
  # $cpp_cmd and $cpp_cmd_arg contain no leading or trailing space.
  my ($cpp_cmd, $cpp_cmd_arg) = check_args(2, "getline_handle_preprocessor_command", caller, @_);

  if ($finding_macro_defs) {
    # handle @rg_cpp_cmds and @%rg_cppcmdcounts
    update_cpp_directives_for($cpp_cmd);
  }

  if ($cpp_cmd eq "if")
    { push(@dependenton, $cpp_cmd_arg);
      # print "if @{[ current_line_no() ]} $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifdef")
    { push(@dependenton, "defined($cpp_cmd_arg)");
      # print "ifdef @{[ current_line_no() ]} $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifndef")
    { push(@dependenton, "!defined($cpp_cmd_arg)");
      # print "ifndef @{[ current_line_no() ]} $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "endif")
    { if (@dependenton == 0)
	{ mdie("improperly nested \#endif"); }
      # print "endif @{[ current_line_no() ]} $dependenton[$#dependenton]; ";
      pop(@dependenton);
      # print "now dependent on @dependenton.\n";
    }
  elsif ($cpp_cmd eq "else")
    { if (@dependenton == 0)
	{ mdie("improperly nested \#else"); }
      my $last = pop(@dependenton);
      push(@dependenton, negate_if_condition($last)); }
  elsif ($cpp_cmd eq "elif")
    { if (@dependenton == 0)
	{ mdie("improperly nested \#elif"); }
      my $last = pop(@dependenton);
      push(@dependenton, negate_if_condition($last)); }
  elsif ($cpp_cmd eq "define")
    { if ($finding_macro_defs)
	{ process_macro_definition($cpp_cmd_arg,$getline_physical_lines,$getline_physical_code_lines); }
    }
  elsif ($cpp_cmd eq "include")
    {
      # Only want to handle #include directives on the pass
      # where we're looking for macro definitions--
      # when we're getting_macro_call_types, #include "ctype.h" becomes
      # #include "" in updateinvars, so we can't do it there again, anyway
      if (!$fIgnoreIncludes && $finding_macro_defs) {
	if ($cpp_cmd_arg =~ /(?:<(.*)>|\"(.*)\")/) {
	  my $angled_include = $false;
	  my $include_file;
	  if ($1 ne "") {
	    $angled_include = $true;
	    $include_file = $1;
	  } else {
	    $include_file = $2;
	  }
	  my $complete_filename = complete_include_pathname($include_file);
	  # Check to see if we're already reading this file anyway

	  # if we resolved the filename to a real file,
	  # and we've not already added the file to our list we need to parse
	  if (defined($complete_filename) 
	      && scalar(grep($_ eq $complete_filename, @files_included)) == 0) {
	    # FIX: may want to insert this where we are
	    # or do some sort of recursive reading of *all* included files
	    # WIERD: Why does this cause a problem in parsing a macro argument
	    #      when I use @files instead of @files_included
	    push @files, $complete_filename;
	    push @files_included, $complete_filename;
	    $files{$complete_filename} = "FromInclude" . 
	      ($angled_include? "<>" : '""');
	    # print STDERR "Adding \"$complete_filename\" as $files{$complete_filename}\n";
	  }
	}
      }
    }
  elsif ($cpp_cmd eq "undef")
    { process_macro_undefinition($cpp_cmd_arg)
    }
  else
    { # Some other cpp command
      # print "unhandled cpp command \#$cpp_cmd $cpp_cmd_arg\n";
    }
  return "\n";
}


# Read and discard lines until we find the matching #endif
# No return value.
sub discard_to_endif
{
  check_args(0, "discard_to_endif", caller, @_);
  my $if0depth = 1;
  my $line;
  while ($if0depth > 0)
    { if (not ($line = <INPUT>))
	{ mdie("File ends in \#ifdef 0"); }
      if ($finding_macro_defs) {
	$rg_logl_lines[$current_ft_index]++;
      }
      # I'll trust that no comment or string contains anything that
      # looks like a preprocessor command.  Strictly speaking, I should
      # use getline and/or updateinvars, because anything in an #ifdef
      # is supposed to be a sequence of valid tokens, but #ifdef 0 often
      # contains non-syntactic constructs.  (Maybe eventually use
      # getline/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($line =~ m/^\#\s*if(n?def)\b/o)
	{ $if0depth++; }
      elsif ($line =~ m/^\#\s*endif\b/o)
	{ $if0depth--; } }
  return undef;
}

# This handles
#     #if...
#     #elsif ...
#     #else
#     #if...
#     #endif
#     #endif
# and returns, instead, a single merged string when possible.
# It does not handle other types of nesting, such as
#     #if...
#     #if...
#     #else
#     #endif
#     #if
#     #else
#     #endif
#     #endif
# should it be able to do the latter?

# Returns a merged string.
# Returns the undefined value if
#  * cpp commands are too far separated
#  * series of cpp commands not one of those handled
#  * parts are different, not brace-unbalanced, or differently brace-unbalanced

sub cpp_merged_branches
{
  check_args(0, "cpp_then_part", caller, @_);
  # print "cpp_merged_branches\n";

  my @parts = ();

  my $prev_sizes = 0;		# sum of all previous sizes

  { my $size_limit = 10;
    my $num_endifs = 0;		# number of extra #endif commands
    my $next_line;

THENPART:
    { my $this_result = "";
      my $this_size = 0;
      $next_line = peek_line($prev_sizes+1);
      while (!($next_line =~ /^\#\s*els(e|if)\b/))
	{ if (($this_size > $size_limit) || ($next_line =~ /^\#/))
	    { return undef; }
	  $this_result .= $next_line;
	  $this_size++;
	  $next_line = peek_line($prev_sizes+$this_size+1); }
      push(@parts, $this_result);
      $prev_sizes += $this_size + 1;
    }
    # print "cpp_merge_branches: thenpart $parts[$#parts]\n";

    if ($next_line =~ /^\#\s*elsif/)
      { goto THENPART; }

ELSEPART:
    { my $this_result = "";
      my $this_size = 0;
      $next_line = peek_line($prev_sizes+1);
      while (!($next_line =~ /^\#\s*endif\b/))
	{ if (($this_size == 0) && ($next_line =~ /^\#\s*if(n?def)?\b/))
	    # if the first thing is #if, go back to then part
	    { $num_endifs++;
	      goto THENPART; }
	  if (($this_size > $size_limit) || ($next_line =~ /^\#/))
	    { return undef; }
	  $this_result .= $next_line;
	  $this_size++;
	  $next_line = peek_line($prev_sizes+$this_size+1); }
      push(@parts, $this_result);
      $prev_sizes += $this_size + 1;
    }
    # print "cpp_merge_branches: elsepart $parts[$#parts]\n";

    while ($num_endifs > 0)
      { $next_line = peek_line(++$prev_sizes);
	if (!($next_line =~ /^\#\s*endif\b/))
	  { return undef; }
	$num_endifs--; }
  }

  # Variable @parts holds the desired values; maybe merge them.

  # Check whether all the parts are the same (modulo whitespace, maybe)
  { my $first_part = $parts[0];
    if ($getline_simplify) { $first_part =~ s/\s+/ /; }
    my $all_same = $true;
    my $index = 1;
    while ($all_same && ($index <= $#parts))
      { my $other_part = $parts[$index];
	if ($getline_simplify) { $other_part =~ s/\s+/ /; }
	$all_same = ($first_part eq $other_part);
	$index++; }
    if ($all_same)
      { my $i;
	for $i (1..$prev_sizes)
	  { # put it in a variable for the convenience of the print below
	    my $discarded = getline();
	    # print "discarding $discarded";
	  }
	# print "returning one of ", scalar(@parts), " identical parts: $first_part";
	return $first_part; } }

  # Check whether the parts are all equally brace_unbalanced
  { my $firstbrace_change = brace_change($parts[0]);
    if ($firstbrace_change ne "")
      { my $index = 1;
	my $all_same = $true;
        while ($all_same && ($index <= $#parts))
	  { $all_same = ($firstbrace_change eq brace_change($parts[$index]));
	    $index++; }
	if ($all_same)
	  { my $i;
	    for $i (1..$prev_sizes)
	      { # put it in a variable for the convenience of the print below
		my $discarded = getline();
		# print "discarding $discarded";
	      }
	    # print "merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n";
	    return merge_brace_unbalanced_lines($firstbrace_change, @parts); } } }
  return undef;
 }


# All of the lines are identically brace-unbalanced
sub merge_brace_unbalanced_lines
{ my ($braces, @lines) = check_args_at_least(3, "merge_brace_unbalanced_lines", caller, @_);

  my $pieces = length($braces)+1;

  my @split_lines = ();
  { my $i;
    for $i (0..$#lines)
      { my @this_pieces = split(/[\{\}]/, $lines[$i]);
	# Does this work?  Don't risk it...
	# $split_lines[$i] = @this_pieces;
	{ my $piece;
	  for $piece (0..$#this_pieces)
	    { $split_lines[$i][$piece] = $this_pieces[$piece]; } }
	if ($pieces != @this_pieces)
	  { mdie("should have $pieces, not ", scalar(@this_pieces), ", pieces: $lines[$i]"); } } }

  my $result = "";
  { my $piece;
    for $piece (0..$pieces-1)
      { { my $i;
	  for $i (0..$#lines)
	    { if (!defined($split_lines[$i][$piece]))
		{ my $p;
		  for $p (0..$pieces)
		    { my $i;
		      for $i (0..$#lines)
			{ print "$p $i <<$split_lines[$i][$p]>>\n"; } }
		  mdie("piece $piece, index $i not defined"); }
	      $result .= $split_lines[$i][$piece]; } }
	if ($piece != $pieces)
	  { $result .= substr($braces, $piece, $piece+1); } } }
  $result;
}



sub is_cpp_command
{ my ($line) = check_args(1, "is_cpp_command", caller, @_);
  $line =~ /^\#/;
}

# Watch out: this removes the trailing newline.
sub trim_whitespace
{
  my ($result) = check_args(1, "trim_whitespace", caller, @_);
  $result =~ s/^\s+//;
  $result =~ s/\s+$//;
  # if ($result =~ /^\s+(.*)$/) { $result = $1; }
  # # (.*)\s+ only gets rid of last space
  # if ($result =~ /^(.*[^\s])\s+$/) { $result = $1; }
  return $result;
}


# This pretties things up but changes contents of line-spanning strings,
# so don't call it if ARG1 ends inside a string.
sub append_lines
{
  my ($arg1, $arg2) = check_args(2, "append_lines", caller, @_);
  # "+", not "*", so don't introduce spaces where there were none before
  # Do I need \Z instead of $?  It seems I don't...
  $arg1 =~ s/[ \t\n]+$/ /;
  $arg2 =~ s/^[ \t\n]+/ /;
  $arg1 . $arg2;
}

# Return an array of three elements: name, args, def.
# None have leading or trailing whitespace
sub macroparse
{ my ($line) = check_args(1, "macroparse", caller, @_);
  # print "macroparse $line\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($line =~ m/^(\w+)(\([^\)]*\))?\s*(.*)\s*$/);
  if ($#result != 2)		# ($# == 2) => 3 elements
    { mdie("Problem parsing macro `$line'\n"); }
  @result;
}


# Recursive descent?  Something simpler?
#   exp = (exp) | num | var | exp op exp     -- no functions
# To tokenize, just split at word beginning and end and at number beginning
# 	and end (which may be a bit tricky to tease apart from operator, with
#	leading +/-, but standard says literals have no leading sign -- it's
#       a unary operator).


# Arguments: string
# Returns: type (or 0 if unsuccessful parse)
#          remaining string?
# Side-effects: %parsevars, %parsefuns, %parsetypes which are lists of all
# the variables, functions, types encountered during the parse
my %parsevars = ();
my %parsefuns = ();
my %parsetypes = ();

# Should check @parsexxxs for reserved words; if we find any, I misparsed.

sub parse_expression
{
  my ($exp) = check_args(1, "parse_expression", caller, @_);
  # Could use undef instead...
  %parsevars = ();
  %parsefuns = ();
  %parsetypes = ();
  # print "parse_expression $exp\n";
  my ($type, $remaining) = parse_exp(remove_comments($exp));
  # print "parse_expression $remaining\n";
  if ($remaining =~ /^\s*$/)
    { return $type; }
  else
    { return $typeFAIL; }
}


sub parse_exp_nocommaop
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, "parse_exp_nocommaop", caller, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $false;
  return parse_exp($exp, $ignoretypes);
}

sub parse_exp_commaop
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, "parse_exp_commaop", caller, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  local $commaop = $true;
  return parse_exp($exp, $ignoretypes);
}


# Takes a
# Like parse_expression, but doesn't reset @parsexxxs.
# Returns two values:  the expression's type and the remaining string.
# Every call should be followed by   "if (!$type) { return($typeFAIL,$exp); }"
# See H&S p. 181.
sub parse_exp
{
  my ($exp, $ignoretypes) = check_args_range(1, 2, "parse_exp", caller, @_);
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  # If ignoretypes is set, then we don't try to infer types, look up types
  # of unknown functions, or set symbol tables.  We do still compute types
  # for literals and return a type, I think.

  # Perhaps remember length of @parsexxxs, so we can restore them if failure.
  # But right now we never fail unless everything fails, so never mind...

  # First, cope with open parens

  # Cast
  if ($exp =~ /^\s*\(\s*($builtin_type_re)\s*\)/)
    { # print "Found cast $1\n";
      my ($casttype) = $1;
      my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      my $casttypenum = type_to_num($casttype);
      if (!is_number($casttypenum))
	{ $parsetypes{$casttypenum} = $true; }
      return parse_exp_follower($casttypenum, $remaining); }
  # Type in parens followed by (what looks like) paren, number, or identifier
  if ($exp =~ /^\s*\(\s*($type_re)\s*\)\s*([0-9a-z\(])/)
    { my ($casttype) = $1;
      $parsetypes{$casttype} = $true;
      # print "Found cast $1 $2\n";
      my ($type, $remaining) = parse_exp($2 . $POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($casttype,$remaining); }

  # Parens as grouping
  if ($exp =~ m/^\s*\(/)
    { my ($type, $remaining) = parse_exp_commaop($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      if ($remaining =~ m/^\s*\)/)
	{ return parse_exp_follower($type, $POSTMATCH); }
      else
	{ return($typeFAIL,$exp); } }

  # Unary prefix operators
  if ($exp =~ /^\s*(\+\+|--|[-~!+&*])/)
    { my ($type, $remaining) = parse_exp($POSTMATCH);
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($type,$remaining); }
  # [^\)] was [ \ta-zA-Z0-9*]
  if ($exp =~ /^\s*sizeof\s*\(\s*([^\)]+)\)/)
    { my $sizeoftype = $1;
      $sizeoftype =~ s/\s+$//;
      my $remaining = $POSTMATCH;
      if (!($sizeoftype =~ /^$type_re$/o))
	{ mdie("sizeof($sizeoftype) doesn't look like a type"); }
      return parse_exp_follower(type_to_num($sizeoftype),$remaining); }

  # Literals
  $exp =~ s/^\s+//;		# remove leading space

  # Literal string
  if ($exp =~ /^$string_literal_re/)
    # String contains no non-escaped double-quote
    # Should look for a following string, to concatenate the two.
    # Perhaps special-case:  look for symbol (which is macro with typeSTRING)
    # or literal string.
    { return ($typeSTRING, $POSTMATCH); }

  # Literal character
  if ($exp =~ /^$char_literal_re/o)
    { return parse_exp_follower($typeCHAR, $POSTMATCH); }

  # Literal floating-point
  # This precedes integer because an integer matches the first part of a float
  if (($exp =~ /^$float_literal_whole_re/o)
      || ($exp =~ /^$float_literal_frac_re/o))
    { my ($type) = $typeDOUBLE;
      if (($2 eq "f") || ($2 eq "F"))
	{ $type = $typeFLOAT; }
      elsif (($2 eq "l") || ($2 eq "L"))
	{ $type = $typeLDOUBLE; }
      return parse_exp_follower($type,$POSTMATCH); }

  # Literal integer (octal)
  # Don't need leading [-+]? because they are always unary operators, never
  # part of the literal itself.
  if (($exp =~ /^$hex_literal_re/o)  # hex (regexp failed with \d for 0-9)
      # hex precedes octal/decimal because the "0" looks like a leading integer
      || ($exp =~ /^$dec_oct_literal_re/o)) # octal or decimal
    { # print "Found integer $1\n";
      my ($remaining) = $POSTMATCH;
      my ($type) = infer_int_type($1);
      # print "inferred type ", type_name($type), "\n";
      if ($2 =~ /[uU]/)
	{ $type = type_unsigned($type); }
      if ($2 =~ /[lL]/)
	{ $type = type_long($type); }
      # print "parse_exp_follower($type,$remaining)\n";
      return parse_exp_follower($type,$remaining); }

  # Variable
  elsif ($exp =~ /^$identifier_re/o)
    { my ($var) = $MATCH;
      my ($remaining) = $POSTMATCH;
      categorize_macro_name($var); # huh??
      my $vartype = $mntype{$var};
      if (!defined($vartype))
	# Need to do a MUCH better job here; in particular, infer a type.
	# Perhaps return a negative number, an index into a list of things
	# whose types need to be inferred.
	{ $vartype = $typeUNKNOWN; }
      # Perhaps do something different if the categorization was successful.
      if ($remaining =~ /^\s*\(/)
	{ $parsefuns{$var} = $true;
	  return parse_arglist($vartype, $POSTMATCH);
	}
      else
	{ $parsevars{$var} = $true;
	  return parse_exp_follower($vartype, $remaining); }
    }
  else
    { # print "Couldn't match $exp\n";
      return ($typeFAIL, $exp); }
}


# $arglist already has leading paren stripped.
sub parse_arglist
{
  my ($ftype, $arglist) = check_args(2, "parse_arglist", caller, @_);

  # Need a notation for function types; maybe just -> in front.
  while (!($arglist =~ /^\s*\)/))
    { my ($thisargtype, $comma) = parse_exp_nocommaop($arglist);
      if (!$thisargtype) { return($typeFAIL, $arglist); }
      # push $thisargtype somewhere
      if ($comma =~ /^\s*,/)
	{ $arglist = $POSTMATCH; }
      elsif ($comma =~ /^\s*\)/)
	{ $arglist = $comma; }
      else
	{ mdie("Neither comma nor close paren followed well-formed arg $arglist\n");
	  return($typeFAIL, $arglist); } }
  return parse_exp_follower($ftype,$POSTMATCH);
}

# $initializer already has leading brace stripped
sub parse_array_initializer
{
  my ($initlist) = check_args(1, "parse_array_initializer", caller, @_);

  # print "parse_array_initializer $initlist"; # $initlist ends in newline

  while (!($initlist =~ /^\s*\}/))
    { my ($thisinittype, $comma);
      # print "current initlist = $initlist"; # $initlist ends in newline
      if ($initlist =~ /^\s*\{/)
	{ ($thisinittype, $comma) = parse_array_initializer($POSTMATCH);
	  # transform subinittype from array to scalar type
	}
      else
	{ ($thisinittype, $comma) = parse_exp_nocommaop($initlist);
	  # print "parse_exp_nocommaop returned ($thisinittype) $comma\n";
	}
      if (!$thisinittype) { return($typeFAIL, $initlist); }
      # push $thisinittype somewhere
      if ($comma =~ /^\s*,/)
	{ $initlist = $POSTMATCH; }
      elsif ($comma =~ /^\s*\}/)
	{ return ($thisinittype, $POSTMATCH); }
      else
	{ mdie("Neither comma nor close brace followed well-formed init $initlist\n");
	  return($typeFAIL, $initlist); } }
  # don't call parse_exp_follower
  return ($typeUNKNOWN,$POSTMATCH);
}

# Returns a success boolean, the post-closeparen string, and the declarations.
# These might be:
#   * identifiers or type decls (if in definition)
#   * types or type decls (if in declaration)
# so don't try to distinguish; just return them literally.
sub parse_function_decl_args
{
  my ($text) = check_args(1, "parse_function_decl_args", caller, @_);
  # print "parsing arg decls in $text\n";

  my @arg_decls = ();

  if ($text =~ /^\s*\)/)
    # No arguments
    { return ($true, $POSTMATCH, @arg_decls); }

  # I have no way of preferring to parse as a typedecl vs. as
  # a type vs as a bare identifier (don't know if this is function
  # definition or declaration, so perhaps pass that information in.
  # Disambiguate later.
  # print "looking for type or type declarator in $text\n";
  while ($text =~ /^\s*(($type_declarator_re)|($type_re))\s*[,\)]/o)
    { push(@arg_decls, $1);
      $text = $POSTMATCH;
      if (substr($MATCH, -1) eq "\)")
	{ # print "parse_function_decl_args returning ", join(', ', @arg_decls), "\n";
	  return ($true, $text, @arg_decls); }
      # print "new text $text\n";
    }
  mdie("Couldn't parse function arg declaration $text");
}

# Need this be global?
my %argnametype;

# Side effects global %argnametype;
# Return an associative array of names to types and the remaining string
# after the open brace.
sub parse_KandR_function_arg_decls
{
  my ($argdecls) = check_args(1, "parse_KandR_function_arg_decls", caller, @_);
  %argnametype = ();
  while (!($argdecls =~ /^\s*\{/))
    { # print "parsing K&R function arg decls $argdecls\n";
      if (!($argdecls =~ /^\s*$type_declarator_re\s*([,;])/))
	{ mdie("Couldn't parse K&R-style type declarator $argdecls\n"); }
      my $typespec = $1;
      my $declarator = $2;
      my $nextchar = $LAST_PAREN_MATCH;
      $argdecls = $POSTMATCH;
      my ($type, $identifier) = parse_declarator($typespec, $declarator);
      $argnametype{$identifier} = $type;
      while ($nextchar eq ",")
	{ if (!($argdecls =~ /^\s*$declarator_re\s*([,;])/))
	    { mdie("Couldn't parse declarator following comma after '$typespec $declarator $nextchar': $argdecls\n"); }
	  $declarator = $1;
	  $nextchar = $LAST_PAREN_MATCH;
	  $argdecls = $POSTMATCH;
	  ($type, $identifier) = parse_declarator($typespec, $declarator);
	  $argnametype{$identifier} = $type; } }

  # This doesn't work; rematch the open brace
  # print "after K&R, remainder $POSTMATCH\n";
  # return $POSTMATCH;
  if (!($argdecls =~ /^\s*\{/))
    { mdie("didn't find open brace previously found in $argdecls\n"); }
  return $POSTMATCH;
}


sub parse_exp_follower
{
  my ($type, $follow) = check_args(2, "parse_exp_follower", caller, @_);
  $follow =~ s/^\s+//;		# remove leading space

  if (!defined($type)) { mdie("type undefined $follow\n"); }

  # Should this be eq to avoid failing when $type is a string?
  if ($type eq $typeFAIL)
    # This isn't quite right since the failure occurred earlier.
    # Perhaps mdie in this case instead.
    { return($type, $follow); }

  # Array subscript
  if ($follow =~ /^\[/)
    { my $subscript = $POSTMATCH;
      my ($subscrtype, $closebracket) = parse_exp($subscript);
      if (!$subscrtype) { return($typeFAIL,$subscript); }
      if (!(type_integral_p($subscrtype) || ($subscrtype == $typeUNKNOWN)))
	# This shouldn't happen; perhaps mdie instead.
	{ mdie("Non-integral type ", type_name($subscrtype), " in subscript\n");
	  return ($typeFAIL, $follow); }
      if ($closebracket =~ /\s*\]/)
	{ my ($remaining) = $POSTMATCH;
	  return parse_exp_follower(type_dereference($type), $remaining); }
      else
	{ return ($typeFAIL, $follow); } }

  # Function call (might this be some other use of parens??)
  if ($follow =~ /^\(/)
    { return parse_arglist($type, $POSTMATCH); }

  # Unary postfix operators
  if ($follow =~ /^(\+\+|--)/)
    { return parse_exp_follower($type, $POSTMATCH); }
  # Structure selectors
  if ($follow =~ /^\s*(\.|->)\w+\b/)
    { return parse_exp_follower($typeUNKNOWN, $POSTMATCH); }

  # Binary operators:  multi-char operators must precede single-char ones
  if (($follow =~ /^(<<|>>|[<=>!]=|&&|\|\||[-*\/%+&^|<>])/)
      || ($commaop && ($follow =~ /^(,)/)))
    { my $op = $1;
      my $arg2 = $POSTMATCH;
      if ($op eq ",")
	{ # print "found a comma operator, commaop = $commaop\n";
	}
      my ($type2, $remaining) = parse_exp($arg2);
      if (!$type2) { return ($typeFAIL, $arg2); }
      if (bool_op_p($op))
	{ return parse_exp_follower($typeBOOL, $remaining); }
      elsif ($op eq ",")
	{ return parse_exp_follower($type2, $remaining); }
      else
	{ return parse_exp_follower(type_lub($type, $type2), $remaining); } }

  # Ternary operator ?:
  if ($follow =~ /^\?/)
    { my $then = $POSTMATCH;
      my ($thentype, $colon) = parse_exp($then);
      if (!$thentype) { return ($typeFAIL, $then); }
      if (!($colon =~ /^\s*:/)) { return ($typeFAIL, $colon); }
      my ($elsetype, $remaining) = parse_exp($POSTMATCH);
      if (!$elsetype) { return ($typeFAIL, $colon); }
      return (type_lub($thentype, $elsetype), $remaining); }

  return ($type, $follow);
}

sub bool_op_p
{
  my ($op) = check_args(1, "bool_op_p", caller, @_);
  return ($op =~ /[<=>!]=|&&|\|\||<|>/);
}


### Get types for macro calls

# This is a bit disappointing because it's so heuristic; my inclination is
# really to get it right rather than approximate.

# Find all uses of a macro, to determine types of its arguments.
# (If it isn't used, it can be eliminated -- this will be true of many in
# standard header files, perhaps.)
# Do a rough parse of each file:
#  recognize binding forms:
#     variable declarations, function definitions, function declarations
#     Can use etags to find function defintiions, but it doesn't find
#	global variables.
#  recognize function calls, check whether they are macros
# Cope with macro definitions like "#define local static" and with
#    typedefs like "typedef unsigned long  ulg;" (the latter not to use
#    the raw type, but to permit type_lub to do a better job, maybe).

sub get_macro_call_types
{
  check_args(0, "get_macro_call_types", caller, @_);
  local $getting_macro_call_types = $true;
  local $getline_nocomment = $true;
  local $getline_simplify = $true;
  local $merge_cpp_if_branches = $true;
  my $ifiles = 0;
#  foreach $this_file (@files)
  for (; $ifiles <= $#files; $ifiles++)
    { $current_file = $files[$ifiles];
      # FIX: don't assert this
      die if defined($files_lines{$current_file});
      @{$files_lines{$current_file}} = ();
      $current_ft_index = compute_current_ft_index($current_file);
      if ($opt_v) {
	print STDERR "file: \"$current_file\" ($files{$current_file})"; 
      }
      # do not do the second pass on included files
      if ( current_file_was_included() && !$opt_A) {
	print STDERR " -- skipping (use -A option to not skip)\n" if $opt_v;
	next;
      } elsif (!open(INPUT,$current_file)) {
	print STDERR " -- open failed\n" if $opt_v;
	next;
      } else {
	print STDERR "\n" if $opt_v;
      }
      # Commented out to quiet compiler
      # $files{$current_file} = 1;
      if (@dependenton > 0)
	{ mdie("In \#if at beginning of file: @dependenton"); }
      # Perhaps I should use a variant of getline that insists that parens
      # are balanced, too; that might let me more reasonably cope with
      # breaks across lines.
      if ($symtab_scopes != 0)
	{ mdie("Bad brace depth $symtab_scopes.\n"); }
      my $in_extern_C = $false;
      my $line;
      while ($line = getline())
	{
	  my $indented = ($line =~ /^[ \t]/);
	  # print "GOTLINE (indented = $indented) <<$line>>\n";
	  # The line number $. isn't quite right, as we may have peeked ahead
	  # print "line @{[ current_line_no() ]}: $line"; # no newline, since $line contains one
	  if ($line =~ /^\s*$/)
	    { # empty line; possibly was originally a preprocessor command
	    }
	  elsif ($line =~ m/^\#/o)
	    { mdie("getline shouldn't return preprocessor lines: $line"); }
	  else
	    {			# not empty or a preprocessor line
	      # print "not empty or a preprocessor line $line"; # $line has newline
	      chop($line);	# remove trailing newline
	      # In a scope, must be indented or: close brace, comment, label

	      # Exceptions to indentation checking.
	      # Perhaps should strip labels here rather than just overlook them.
	      if ((!$indented)
		  && (($line =~ m/^($identifier_re\s*:)/o)
		      || (($symtab_scopes == 1)
			  && ($line =~ m/^(\}|\"|0\};)/))))
		{ # print "setting line to indented: $line\n";
		  $indented = $true; }
	      # Checks for any improperly unindented line.  Later, we
	      # make sure that every properly unindented line was processed.
	      if ((!$indented) && ($symtab_scopes != 0))
		{ mdie("Non-indented line $line at bracedepth $symtab_scopes"); }

	      # Check for improper indentation later, complaining only
	      # about lines containing definitions/declarations.  (Maybe
	      # should do more checking?)

	      # Look for:  typedef,
	      #   function definition/declaration (only at symtab_scopes == 0)
	      #   variable definition/declaration,
	      #   function call (of a macro),
	      #   brackets (to keep track of scopes),
	      #   string/char literals (to avoid catching too much).
	      # These can span multiple lines, especially function definitions.

PROCESSLINE:
	      if (!defined($line))
		{ mdie("PROCESSLINE: line undefined.\n"); }
	      # print "PROCESSLINE $line\n";
	      $line = simple_macro_substitute($line);
	      if ($line =~ /^\s*$/)
		{		# do nothing; maybe this was a preprocessor directive
		  # print "empty line @{[ current_line_no() ]}:\n";
		}
	      elsif ($line =~ /^\s*typedef\s+/)
		{		# process typedefs
		  # print "typedef line @{[ current_line_no() ]}: $line\n";
		  $line = $POSTMATCH;
# This is wrong because typedefs can have semicolons inside braces.
#		  my $semi_pos;
# 		  # use index(), because ($line =~ /;/) gave trouble here
# 		  while (-1 == ($semi_pos = index($line, ";")))
# 		    {		# print "no semicolon, so appending a line to $remaining\n";
# 		      $line = append_lines($line, getline()); }
# 		  my $typedef = substr($line, 0, $semi_pos-1); # omits "typedef", ";"
# 		  # process_typedef($typedef);
# 		  $line = substr($line, $semi_pos+1);
# 		  print "after typedef $PREMATCH, set line to $line\n";
		  goto PROCESSLINE;
		}
	      elsif (($line =~ /^$type_specifier_re\s*$/o)
		     # this call to peek_line ignores the @dependenton argument
		     && (peek_line(1) =~ /^$declarator_re\s*\(/o))
		{ # Function definition split over multiple lines
		  $current_function_start_line = current_line_no() - 1;
		  $line .= " " . getline();
		  # Can't do a forward jump, so start over.
		  goto PROCESSLINE; }
	      elsif (($line =~ /^\s*($type_declarator_re)\s*([,=;\(])/o)
		     # must check this second, to get "int (*foo) (arg1, arg2)"
		     || ($line =~ /^($identifier_re)\s*(\()/o))
		{
		  # problem: we don't know whether we matched $identifier_re
		  # or $type_declarator_re.  So we have to rematch, which is
		  # wasteful.
		  my $nextchar = $LAST_PAREN_MATCH;
		  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";") || ($nextchar eq "\(")))
		    { mdie("what nextchar? '$nextchar'\n"); }
		  my $remaining = $POSTMATCH;
		  my $typespec;
		  my $declarator;
		  { my $identifier_or_typedecl = $1;
		    # Do the easy case first here; order doesn't matter.
		    if ($identifier_or_typedecl =~ /^$identifier_re$/)
		      { $typespec = "((int))";
			$declarator = $identifier_or_typedecl; }
		    elsif ($identifier_or_typedecl =~ /^$type_declarator_re$/o)
		      { $typespec = $1;
			$declarator = $2; }
		    else
		      { mdie("must be identifier or type declarator: $identifier_or_typedecl\n"); } }
		  if ($debug_type_match)
		    { print "matched type declarator <$typespec><$declarator>\n"; }
		  # print "maybe matched type declarator <$1><$2><$3><$4><$5><$6><$7><$8><$9> <<", defined($macros{$6}[0]), (defined($macros{$6}[0]) ? (">><<$macros{$6}[0] $macros{$6}[1] |$mname[$macros{$6}[1]]|$margs[$macros{$6}[1]]|$mbody[$macros{$6}[1]]|$mfile[$macros{$6}[1]]|$mline[$macros{$6}[1]]|") : ""), ">>\n";

		  # Fallthroughs below depend on the fact that this is the last
		  # clause in the elsif chain: there's nothing else we would
		  # try to do here if we didn't have a type declarator.

		  if (($typespec eq "Call") && ($declarator eq "UPDATE_HASH"))
		    { # gzip-1.2.4/deflate.c line 633 (I don't want to give up
		      # on complete parsing yet, but don't want to mdie here).
		      # print "rejected special case";
		    }
		  elsif ($typespec =~ /$c_reserved_nontype_word_re/o)
		    { # "else if (...)", "return foo;", "sizeof(buf)", etc.
		      # print "rejected typespec $typespec\n";
		    }
		  elsif ($declarator =~ /$c_reserved_nontype_word_re/o)
		    {
		      # print "rejected declarator $declarator\n";
		    }
		  elsif (($nextchar eq "(")
			 # Implied by "defined($macros{$declarator}[0])"
			 # && ($declarator =~ /^$identifier_re$/o)
			 && defined($macros{$declarator})
			 # FIX: might not need below line, now that we have above line
			 && defined($macros{$declarator}[0])
			 && (!macro_dependenton($declarator, @dependenton)))
		    { # The function being defined is actually a macro.
		      # Try to expand it, else fall through.
		      my $identifier = $declarator;

		      my $close_paren_pos;
		      # if parens aren't balanced, read enough text to balance them.
		      ($close_paren_pos, $remaining) = find_close_paren($remaining, 0, $true);

		      # Case 1:
		      # There is only one expansion for the macro.  Expand it.
		      # This isn't quite right if the dependentons aren't
		      # compatible.
		      if (exists $macros{$identifier} && 
			  $macros{$identifier}[0] == 1)
			{ # ... expand macro ...;
			  # goto PROCESSLINE;
			}

		      # Case 2: macro that takes a single arg and either
		      # returns it or returns nothing, which can be used to
		      # construct either a K&R or ANSI function declaration
		      # by passing in a parenthesized list as the argument.
		      if (is_fun_decl_arg_macro($identifier))
			{
			  mdie("shouldn't find fun_decl_arg_macro any more");
			  # ... expand macro ...;
			  # For now, hack it.
			  if (!($declarator =~ /^$identifier_re$/))
			    { mdie("can't have pointer or array declarators"); }
			  # print "expanding empty-paren macro from $line";
			  $line = $typespec . " " . $nextchar
			    . substr($remaining, 0, $close_paren_pos-1)
			      . substr($remaining, $close_paren_pos+1);
			  # print "expanded empty-paren macro to $line";
			  goto PROCESSLINE;
			}

		      # fall through, but don't reset line, because we want
		      # to consider this a call or process arguments, etc.

		      # print "rejected macro $identifier\n";

		    }
		  else
		    { # This actually is a valid type specifier and declarator
		      my ($type, $identifier) = parse_declarator($typespec, $declarator);

		      if (($line =~ /^\s/)
			  && ($symtab_scopes == 0)
			  # accept indented declaration/definition in #if at top scope
			  # (want to reject function defs but not decls; how to do?)
			  && (@dependenton == 0))
			{
			  # print "potential indentation problem; nextchar '$nextchar', line $line\n";
			  # Hack for gzip-1.2.4/deflate.c.
			  # If a few improperly indented lines containing no braces
			  # are followed by a property unindented line, don't mdie.
			  my $proper_follows = $false;
			  { my $follow;
			    for $follow (1..7)
			      { my $next = getline($follow);
				if ($next =~ /^[^\s]/)
				  { $proper_follows = $true;
				    last; }
				if ($next =~ /[\{\}]/)
				  { last; } } }
			  if (!$proper_follows)
			    { mdie("Indented line at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line"); }
			  # print "Overlooked indented line @{[ current_line_no() ]} at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line";
			}
		      # print "found typespec '$typespec' declarator '$declarator' nextchar '$nextchar' remaining '$remaining' on line @{[ current_line_no() ]}\n";
		      # If no semicolon, then the definition must span lines.
		      if (($nextchar ne ";") && ($nextchar ne "("))
			# Only need to check the new stuff, not the whole thing.
			{ while (!($remaining =~ /;/))
			    {	# print "no semicolon, so appending a line to $remaining\n";
			      $remaining = append_lines($remaining, getline()); } }
		      # print "found semicolon (or nextchar is open paren) in $remaining\n";

		      if ($nextchar eq "(")
			{ $line = process_function_definition_or_declaration($type, $identifier, $remaining);
			  goto PROCESSLINE;
			}
		      else
			{
PROCESSVARDEF:
			  # variable definition or declaration
			  # print "variable definition or declaration <<$identifier>> $type\n";
			  # $nextchar = "," or "=" or ";"
			  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";")))
			    { mdie("what nextchar? '$nextchar'"); }

			  # This should logically happen here, but hold off
			  # in case there is trouble.
			  # symtab_add($identifier, $type);
			  if ($nextchar eq ";")
			    { symtab_add($identifier, $type);
			      $line = $remaining;
			      goto PROCESSLINE; }
			  elsif ($nextchar eq ",")
			    {
ATCOMMA:
			      if ($remaining =~ /^\s*$declarator_re\s*([,=;])/o)
				{ # First, add the previous thing.
				  symtab_add($identifier, $type);
				  # Now cope with this one.
				  $declarator = $1;
				  $nextchar = $LAST_PAREN_MATCH;
				  $remaining = $POSTMATCH;
				  ($type, $identifier) = parse_declarator($typespec, $declarator);
				  goto PROCESSVARDEF; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*([,\)])/o)
				{ # We're in the middle of a function declarator
				  # Skip to next brace or semicolon

				  # It looks like we ignore the type
				  # declarator we just found.  And, we don't do
				  # symtab_add($identifier, $type);
				  # which was deferred from above.  What's up?
				  $remaining = $POSTMATCH;
				  if ($remaining =~ /[\{;]/)
				    { if ($MATCH eq ";")
					{ $remaining = $POSTMATCH; }
				      else
					{ $remaining = $MATCH . $POSTMATCH; } }
				  elsif ($remaining =~ /\)/)
				    { $remaining = $POSTMATCH; }
				  else
				    { mdie("No semicolon or brace after function declarator?  It can't be!\n"); }
				  $line = $remaining;
				  goto PROCESSLINE; }
			      else
				{ mdie("Found '$typespec $declarator' ($nextchar) but no following var in $remaining\n"); } }
			  elsif ($nextchar eq "=")
			    {	# Skip over an expression and continue processing from there.
			      # print "skipping expression $remaining\n";
			      my $postexp = skip_expression_nocommaop($remaining);
			      if ($postexp eq "")
				{ # do nothing; done with this line, because
				  # parsing of the expression failed
				  mdie("Failed to parse initializer $remaining\n"); }
			      elsif ($postexp =~ /\s*;/)
				{ $line = $POSTMATCH;
				  goto PROCESSLINE; }
			      elsif ($postexp =~ /\s*,/)
				{ $remaining = $POSTMATCH;
				  goto ATCOMMA; }
			      else
				{ mdie("After skipping well-formed initializer, didn't find comma or semicolon.\n"); } }
			  else
			    { mdie("Bad nextchar $nextchar.\n"); } }
		    } }

	      # Alternative to variable $indented is making sure that loops
	      #   back to PROCESSLINE append a space to the front of lines
	      #   that were oringally indented, but a portion of which must
	      #   be reprocessed.  (Actually, that wouldn't even be enough,
	      #   since we want to treat bar as unindented in unindented
	      #   "foo; bar;".) This isn't foolproof, but probably close
	      #   enough.
	      if ((!$indented)
		  && (!($line =~ /^\s*$/))
		  # Hack.   Should really expand it and try again.
		  && (!($line =~ /^($identifier_re)\s*\(/) && defined($macros{$1})))
		{ mdie("properly unindented line was never processed: $line"); }

	      # Line didn't match $type_declarator_re
	      # Parse it looking for:
	      #  * open and close braces to keep track of scopes
	      #  * strings and chars so we can skip over them
	      #    (or maybe simplify_line will do away with them).
	      #  * open parens, because maybe they indicate a function call
	      #  * semicolon: try again
	      if ($line =~ "^extern \"\" {")
		{ if ($symtab_scopes != 0)
		    { mdie("extern \"C\" not at top level"); }
		  if ($in_extern_C)
		    { mdie("extern \"C\" inside extern \"C\""); }
		  $line = $POSTMATCH;
		  $in_extern_C = $true;
		}
	      while ($line =~ m/[\({}\"\';]/) #'HACKCOLOR
		# Found brace, open paren, quote, comment, or semicolon
		{		# print "Found brace, open paren, quote, comment, or semicolon: $MATCH$POSTMATCH\n";
		  my $match = $MATCH;
		  $line = $POSTMATCH;
		  if ($match eq "{")
		    { enter_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq "}")
		    { if (($symtab_scopes == 0) && $in_extern_C)
			{ $in_extern_C = $false; }
		      else {
			# if we were in a function, we need to save some info
			if ($symtab_scopes == 1 && defined($current_function)) {
			  my $end_line = current_line_no();
			  # update our per-file list of function locations
			  push @{$files_lines{$current_file}}, 
			  ($current_function_start_line,"$current_function",
			   $end_line);
			  #print STDERR "FN: $current_function $current_file [$current_function_start_line,", current_line_no(), "]\n";
			  # update our per-function list of [file,startline,endline]
			  push @{$functions{$current_function}}, 
			  [$current_file, $current_function_start_line, 
			   current_line_no() ];
			}
			exit_scope();
		      }
		      goto PROCESSLINE; }
		  elsif ($match eq ";")
		    { goto PROCESSLINE; }
		  elsif ($match eq "(")
		    { if ($PREMATCH =~ /$identifier_re\s*$/o)
			{ # found something that looks like a function call
			  # process it
			}
		      else
			{ # This paren doesn't represent a function call;
			  # look for another brace, open paren, quote, comment
			}
		    }
		  elsif ($match eq "\"")
		    { if ($line =~ /$non_escaped_double_quote_re/o)
			{ $line = $POSTMATCH; }
		      else
			{ mdie("Didn't find end of string literal $line.\n"); } }
		  elsif ($match eq "'")
		    { if ($line =~ /^$char_literal_contents_re\'/o)
			{ $line = $POSTMATCH; }
		      else
			{ mdie("Didn't find end of character literal $line.\n"); } }
		  else
		    { mdie("What match '$match' '$line'?\n"); } }
	    }
	  # done with this line; get another
	}
      # done with this file; read another
      if (@dependenton > 0)
	{ mdie("Still in \#if at end of file: @dependenton"); }
      # print "closing file $current_file\n";
      close(INPUT);
    }
}


# This should perhaps do more:  substitute for macros with only one definition,
# or those that expand to either nothing or a keyword like const, etc.
sub simple_macro_substitute
{ my ($text) = check_args(1, "simple_macro_substitute", caller, @_);

  my $fdmacro;
  # Using "for" instead of foreach gives me 'Use of "" without parens is ambiguous'!
  foreach $fdmacro (keys %fun_decl_arg_macros)
    { if ($text =~ /\b$fdmacro\s*\(/)	# no /o here, as $fdmacro varies
	{ my $prematch = $PREMATCH;
	  my $postmatch = $POSTMATCH;
	  my $close_paren_pos;
	  ($close_paren_pos, $postmatch) = find_close_paren($postmatch, 0, $true);
	  # print "close paren at $close_paren_pos in $postmatch\n";
	  my $result = $prematch . substr($postmatch, 0, $close_paren_pos)
	    . substr($postmatch, $close_paren_pos+1);
	  # print "simple_macro_substitute $text\n ===> $result\n";
	  return $result; } }
  return $text;
}


# Returns several values:
#   Remaining line to reprocess, ...
sub process_function_definition_or_declaration
{
  my ($type, $identifier, $remaining)
    = check_args(3, "process_function_definition_or_declaration", caller, @_);

  # found (start of) function definition or prototype
  # Only need to check the new stuff, not the whole thing.
  while (!($remaining =~ /\)/))
    { # print "no close paren, so appending a line to $remaining\n";
      $remaining = append_lines($remaining, getline()); }
  if (!($remaining =~ /\)/))
    { mdie("There must be a close paren.\n"); }
  # print "found function $identifier; remaining $remaining\n";
  # process the args:  create the scope, eat the following
  # open brace, etc.  $remaining includes everything after
  # the original open paren.
  # Three possibilities:
  #   function declaration (K&R or ANSI)
  #   K&R-style function definition
  #   ANSI-style function definition
  # odd; "my ($success, $remaining) = ..." doesn't work.
  my @arg_decls;
  { my $success;
    ($success, $remaining, @arg_decls) = parse_function_decl_args($remaining);
    # print "parse_function_decl_args => ", join(', ', @arg_decls), "; remaining = $remaining\n";
    if (!defined($remaining))
      { mdie("remaining not defined after parse_function_decl_args => @arg_decls"); }
    # Do something here before returning?
    if (!$success)
      { return $remaining; } }
  # $remaining is what follows the close paren
  while ($remaining =~ /^\s*$/)
    {				# print "no semi or brace, so appending a line to $remaining\n";
      $remaining = getline(); }

  my @arg_names;		# These two will be set from arg_decls when
  my @arg_types;		#   we know whether this was a def or decl.
  # $remaining is nonempty; if first character is
  # semicolon, then this is a declaration, else a definition
  if ($remaining =~ /^\s*;/)
    {				# declaration
      # gzip-1.2.4/sample/sub.c line 51
      #   puts a prototype in scope 1.
      if ($symtab_scopes != 0)
				# Print to EVIL, maybe.
	{ # print "Function definition or prototype $MATCH at bracedepth $symtab_scopes.\n";
	}

      # enter this in the global symbol table, perhaps
      # (to be done)
      $remaining = $POSTMATCH;
      # set @arg_{names,types}; arg_decls is a list of
      # strings, each a type or a type declarator
      { my $i;
	for $i (0..$#arg_decls)
	  { my $decl = $arg_decls[$i];
	    if ($decl =~ /^$type_declarator_re$/)
	      { my $type_specifier = $1;
		my $declarator = $2;
		($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
	    elsif ($decl =~ /^$type_re$/)
	      { $arg_types[$i] = parse_type($decl);
		# leave $arg_names[$i] undefined
	      }
	    else
	      { mdie("Can't parse as type or type declarator: $decl\n"); } } }
    }
  else
    {				# function definition
      # print "found function definition $identifier; remaining $remaining\n";
      $current_function = $identifier;
      if (!defined($current_function_start_line)) {
	$current_function_start_line = current_line_no() - 1;
      }
      if ($symtab_scopes != 0)
	{ mdie("Function definition at bracedepth $symtab_scopes.\n"); }
      if ($remaining =~ /^\s*\{/)
	{			# ANSI-style definition
	  $remaining = $POSTMATCH;

	  # set @arg_{names,types}; arg_decls is a list of
	  # strings, each an identifier or a type declarator
	  { my $i;
	    for $i (0..$#arg_decls)
	      { my $decl = $arg_decls[$i];
		if ($decl =~ /^$identifier_re$/)
		  { $arg_names[$i] = $decl;
		    # leave $arg_types[$i] undefined
		  }
		elsif ($decl =~ /^$type_declarator_re$/)
		  { my $type_specifier = $1;
		    my $declarator = $2;
		    ($arg_types[$i], $arg_names[$i]) = parse_declarator($type_specifier, $declarator); }
		else
		  { mdie("Can't parse as identifier or type declarator: $decl\n"); } } }
	}
      else
	{			# K&R-style definition
	  if (!($remaining =~ /^\s*$type_declarator_re\s*([,;])/))
	    # If zero arguments, we parsed it as an ANSI-style declaration
	    { mdie("Didn't find first type+declarator in K&R-style $remaining\n"); }

	  # set @arg_{names,types}; arg_decls is a list of
	  # strings, each an identifier or a type declarator
	  { my $i;
	    for $i (0..$#arg_decls)
	      { my $decl = $arg_decls[$i];
		if (!($decl =~ /^$identifier_re$/))
		  { mdie("K&R-style function definition, but non-identifier arg declarator $decl"); }
		$arg_names[$i] = $decl;
		# leave $arg_types[$i] undefined
	      } }

	  # Only need to check the new stuff, not the whole thing.
	  while (!($remaining =~ /\{/))
	    {			# print "no brace, so appending a line to $remaining\n";
	      $remaining = append_lines($remaining, getline()); }
	  $remaining = parse_KandR_function_arg_decls($remaining);
	  # Make sure that the argument list matches the declarators

	  if ($debug_parse_function)
	    { print "parse_KandR_function_arg_decls returned\n";
	      my $key;
	      my $value;
	      while (($key, $value) = each %argnametype)
		{ print "  $key=$value\n"; }
	      print " remaining $remaining\n"; }

	  { { my $i;
	      foreach $i (0..$#arg_names)
		{		# print "arg names: ", @arg_names, "\narg types: ", @arg_types, "\n";
		  my $thistype = $argnametype{$arg_names[$i]};
		  if (!defined($thistype))
		    { mdie("No K&R-style declarator for $arg_names[$i]\n"); }
		  $arg_types[$i] = $thistype;
		  delete $argnametype{$arg_names[$i]};
		} }
	    # argnametype should be empty now
	    { my $name;
	      for $name (keys %argnametype)
		{ mdie("K&R-style declarator, but no argument, for $name $argnametype{$name}"); } }
	  }
	}
      # print "Done parsing function definition to open brace\n";

      # function definition: $remaining is everything after
      # the open brace, and @arg_names and @arg_types are set.
      # Two things to do:
      #  1. add function's type to the global symbol table
      #  2. enter a scope

      # 1. add function's type to the global symbol table
      # (to be done).  Actually, this should be easy since
      # we are at global scope now.  Perhaps have separate
      # tables for guesses and for what we know for sure.
      # We'll have declarations for everything but macros.
      # Watch out that it isn't already in the global
      # symbol table (make sure it is compatible if so).

      # 2. enter a scope
      enter_scope();
      { my $i;
	for $i (0..$#arg_names)
	  { symtab_add($arg_names[$i], $arg_types[$i]); } }

      # Done with function definition
    }

  # We just coped with a function definition or declaration.
  # Process the rest of the line (if def, this is anything
  # after the open brace).
  return $remaining;
}


# Returns two values the remaining string, or the empty string if failure.
# This is actually for skipping initializers.
sub skip_expression_nocommaop
{
  my ($input) = check_args(1, "skip_expression_nocommaop", caller, @_);
  my ($type, $remaining);

  # print "skipping expression $input\n";

  if ($input =~ /^\s*\{/)
    { ($type, $remaining) = parse_array_initializer($POSTMATCH);
      # print "parse_array_initializer returned $type $remaining\n";
    }
  else
    { ($type, $remaining) = parse_exp_nocommaop($input, "ignore types"); }
  if (!$type)
    { return ""; }
  else
    { return $remaining; }
}


### Symbol table
# FIX: Improve the representation of the symbol table
# The symbol table is two parallel arrays:
my @symtab_identifiers = ();
my @symtab_types = ();
# $scopemarker in the @identifiers array indicates a scope boundary
my $scopemarker = "scope marker";	# contains space, as no real variable can

# Perhaps have a different structure (an associative array?) for the global
# level and only use this for nested scopes.


sub show_symtab
{
  my ($text) = check_args(1, "show_symtab", caller, @_);
  if ($#symtab_identifiers != $#symtab_types)
    { mdie("symtab_identifiers and symtab_types arrays have different lengths ($#symtab_identifiers != $#symtab_types)\n"); }
  print "{SYMBOL TABLE $text at line @{[ current_line_no() ]}:\n";
  # perhaps print out in opposite direction
  { my $i;
    for ($i = $#symtab_identifiers; $i >= 0; $i--)
      { if ($symtab_identifiers[$i] eq $scopemarker)
	  { print " --------\n"; }
	else
	  { print " ", $symtab_identifiers[$i], "\t", type_name($symtab_types[$i]), "\n"; } } }
  print "}\n";
}

sub enter_scope
{
  check_args(0, "enter_scope", caller, @_);
  push(@symtab_identifiers, $scopemarker);
  push(@symtab_types, 0);
  $symtab_scopes++;
  if ($debug_scopes) { show_symtab("entered scope $symtab_scopes"); }
}

sub exit_scope
{
  check_args(0, "exit_scope", caller, @_);
  if ($debug_scopes) { show_symtab("exiting scope $symtab_scopes"); }
  if ($#symtab_identifiers == -1)
    { mdie("Trying to exit scope but empty symtab_identifiers array at beginning.\n"); }
  while ($scopemarker ne pop(@symtab_identifiers))
    { pop(@symtab_types);
      if ($#symtab_identifiers == -1)
	{ mdie("Trying to exit scope, but didn't find scopemarker.\n"); } }
  pop(@symtab_types);
  # It's possible that ($#symtab_identifiers == -1), if global scope is empty.
  if ($debug_scopes) { show_symtab("exited scope $symtab_scopes"); }
  $symtab_scopes--;
  if ($symtab_scopes == 0) {
    undef $current_function; 
    undef $current_function_start_line;
  }
}

# sub symtab_scopes
# {
#   check_args(0, "symtab_scopes", caller, @_);
#   my $result = 1;
#   my $id;
#   for $id (@symtab_identifiers)
#     { if ($id eq $scopemarker)
# 	{ $result++; } }
#   return $result;
# }

sub symtab_add
{
  my ($identifier, $type) = check_args(2, "symtab_add", caller, @_);
  if (!defined($identifier))
    { mdie("symtab_add: undefined identifier, type $type"); }
  if (!defined($type))
    { mdie("symtab_add: undefined type, identifier $identifier"); }
  push (@symtab_identifiers, $identifier);
  push (@symtab_types, $type);
}

sub symtab_lookup
{
  my ($var) = check_args(1, "symtab_lookup", caller, @_);
  { my $i;
    for ($i = $#symtab_identifiers; $i >= 0; $i--)
      { if ($var eq $symtab_identifiers[$i])
	  { return $symtab_types[$i]; } } }
  return $typeFAIL;
}



###########################################################################
### Check and categorize macros
###

# Need a routine that assigns a type to a literal.
# (Useful for turning macros into const variables.)

# # FIsNumConst(string)  returns 1 iff string matches a numeric const regexp
# sub FIsNumConst {
#   my ($str) = @_;
#   check_args(1, "FIsNumConst", caller, @_);
#   if ($str =~ /^\(?-?\d+\.?\d*\)?$/ || # decimal 2.
#       $str =~ /^\(?-?\d*\.?\d+\)?$/ || # fraction .2
#       $str =~ /^0x[\d|a-f|A-F]+$/ ||   # hex
#       $str =~ /^-?\d+[ulUL]$/) {       # trailing L for long, U for unsigned
#     return 1;
#   } else {
#     return 0;
#   }
# }

#
sub test_categorize_macro
{ my ($body) = check_args(1, "test_categorize_macro", caller, @_);
  $mbody[1000] = $body;
  $mname[1000] = "dummy";
  $margs[1000] = "(arg)";
  undef $mcategory[1000];
  categorize_macro(1000);
  print $categoryname[$mcategory[1000]] . "\n";
}

# Takes macro name as argument; categorizes each of the macro's definitions
sub categorize_macro_name
{ my ($name) = check_args(1, "categorize_macro_name", caller, @_);
  # Below line illustrates that the usage further below ends up added
  # $macros{$name} to the hash
  # print STDERR "CMN: $name ", defined($macros{$name})?"T":"F", "\n";
  # The usage was: $macros{$name}[0];
  # but has since been replaced by checking if $macros{$name} exists
  if (defined($mntype{$name}))
    { return; }
  if (!defined($macros{$name}))
    { # We called this on a non-macro (we try for every name in a definition).
      # note that accessing $macros{$name}[0] ends up adding $name to the
      # hash %macros, even though the value is undefined
      return; }
  my $numdefs = $macros{$name}[0];
  # if the assertion below gets tripped, it's likely that
  # somewhere we're mistakenly adding to %macros unintentionally
  die "numdefs not defined for $name" if !defined($numdefs);
  # Use this block instead to help debug the above problem
  #if (!defined($numdefs)) {
  #  print STDERR "numdefs not defined for $name\n";
  #  delete $macros{$name};
  #  return;
  #}
  my $type;
  my $category;
  { my $i;
    for ($i = 1; $i <= $numdefs; $i++)
      { if (!defined($mcategory[$macros{$name}[$i]]))
	  { categorize_macro($macros{$name}[$i]);
	    if (!defined($type))
	      { $type = $mtype[$i];
		$category = $mcategory[$i]; }
	    else
	      { $type = type_lub($type, $mtype[$i]);
		$category = category_lub($category, $mcategory[$i]); } } } }
  $mntype{$name} = $type;
  $mncategory{$name} = $category;
}


#FIXMERNST: need to fix this code-- I think it's broken (categories are wrong)
# Takes index into macro arrays as argument
sub categorize_macro
{ my ($index) = check_args(1, "categorize_macro", caller, @_);

  # print "Categorizing $index $mname[$index]$margs[$index] $mbody[$index]\n";

  if (defined($mcategory[$index]))
    { # print "Already categorized! $mcategory[$index] $categoryname[$mcategory[$index]]\n";
      return; }
  $mcategory[$index] = $catINPROCESS;

  my $body = remove_comments($mbody[$index]);
  $mbody_noc[$index] = $body;
  $fDebugCommentRemoval && print STDERR "body = '$mbody[$index]'\nbody_noc = '$body'\n";

  my $category;
  my $type;
  if ($body eq "")
    # Null define
    { $category = $catNULLDEFINE; }
#!    elsif ($body =~ /^\".*\"$/)
#!      # String
#!      { # print "found string";
#!        $category = $catLITERAL;
#!        $type = $typeSTRING; }
  else
    { my $remaining;
      ($type, $remaining) = parse_exp($body);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*$/))
	# Expression
	{ $category = $catEXP;
	  # print "category = $category; found expression $body\n";
	  { my $arg;
	    foreach $arg (split(/[\(, \t]*/, $margs[$index]))
	      { delete $parsevars{$arg};
		if (defined($parsetypes{$arg}))
		  { $category = $catTYPEARG;
		    goto CATEGORIZED; }
		delete $parsefuns{$arg}; } }
	  # print "category postargs = $category\n";
	  # Assume the functions and types are well-defined if not macros
	  # If they are macros, should check 'em, not just fail.
	  { my $fun;
	    foreach $fun (keys %parsefuns)
	      { if (defined $macros{$fun})
		  # This is actually fine most of the time; fix later.
		  { $category = $catMACROFUN;
		    goto CATEGORIZED; } } }
	  # print "category postfun = $category\n";
	  { my $type;
	    foreach $type (keys %parsetypes)
	      { if (defined($macros{$type}))
		  # This may be fine; fix later.
		  { $category = $catMACROTYPE;
		    goto CATEGORIZED; } } }
	  # print "category posttype = $category\n";
	  # For each free variable, check its type.
	  { my $var;
	    foreach $var (keys %mfreevars)
	      { # print "examining free var $var ($mname[$index])\n";
		if (defined($macros{$var}))
		  { my $varclass;
		    my $i;
		    foreach $i ($macros{$var})
		      { if ($mcategory[$i] == $catNOTYET)
			  { categorize_macro($i); }
			if (!defined($varclass))
			  { $varclass = $mcategory[$i]; }
			elsif ((($mcategory[$i] == $catLITERAL)
				|| ($mcategory[$i] == $catCONSTANT)
				|| ($mcategory[$i] == $catSOMECONSTANT))
			       && (($varclass == $catLITERAL)
				   || ($varclass == $catCONSTANT)
				   || ($varclass == $catSOMECONSTANT)))
			  { $varclass = $catSOMECONSTANT; }
			elsif ($varclass != $mcategory[$i])
			  { $category = $catFAILURE;
			    goto CATEGORIZED; }
			else
			  { mdie("Huh?"); } }
		    if (!(($varclass == $catLITERAL)
			  || ($varclass == $catCONSTANT)
			  || ($varclass == $catSOMECONSTANT)))
		      { $category = $catFAILURE; # should be more specific here
			goto CATEGORIZED; } }
		else
		  # This is a free variable.  Should check whether it is a global
		  # (which would be OK; a local would be bad).
		  { $category = $catEXPFREE; # should be more specific here
		    goto CATEGORIZED; }
	      } }
	  # print "category postfree = $category\n";
	  $category = $catSOMECONSTANT;
	  # print "category = $category\n";
	}
      else
	# Should do some evilness processing here, to justify the failed
	# categorization.
	{ # Not an expression, apparently
	  $category = $catFAILURE;
	  # FIXMERNST: need to call this
#	  check_macro_body($body);
	}
    }

 CATEGORIZED:
  # print "categorized as $category = $categoryname[$category]\n";
  if ($opt_C)
    { # print defined($index), " ", defined($mfile[$index]), " ", defined($mline[$index]), " ", defined($category), " ", defined($categoryname[$category]), " ", defined($mname[$index]), " ", defined($margs[$index]), " ", defined($mbody[$index]), "\n";
     # print "$mfile[$index]:$mline[$index]: $category = $categoryname[$category]: $mname[$index]$margs[$index] $mbody[$index]\n";
#      if (!defined($mfile[$index])) {
#	print STDERR "mfile[index] not defined\n"
#      } elsif (!defined($mline[$index])) {
#	print STDERR "mline[index] not defined\n"
#      } elsif (!defined($categoryname[$category])) {
#	print STDERR "categoryname[category] not defined\n";
#      }
      print CATEG "$mfile[$index]:$mline[$index]: $categoryname[$category]";
      if (($category == $catEXP)
	  || ($category == $catEXPFREE)
	  || ($category == $catLITERAL)
	  || ($category == $catCONSTANT)
	  || ($category == $catSOMECONSTANT))
	{ print CATEG "(", type_name($type), ")"; }
      print CATEG ": $mname[$index]$margs[$index] $mbody[$index]\n"; }
  $mcategory[$index] = $category;


#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: NullDefine: $name\n";
#     }
#   }
}


# Return true for a macro that takes a single arg and either returns it or
# returns only open and close parens, which can be used to construct either
# a K&R or ANSI function declaration by passing in a parenthesized list as
# the argument.
sub is_fun_decl_arg_macro
{ my ($identifier) = check_args(1, "is_fun_decl_arg_macro", caller, @_);

#  print STDERR "is_fun_decl_arg_macro: $identifier $macros{$identifier}[0] ", join(', ',(map {$margs[$macros{$identifier}[$_]]} (1..$macros{$identifier}[0]))), "\n";

  # don't require only 2 definitions-- require > 1 and
  # check that all definitions
  # return either the single arg or "()"
  # __P in /usr/include/{sys/cdefs,ctype}.h is defined 5 times

  die "is_fun_decl_arg_macro: $identifier" if (!exists $macros{$identifier});

  # FIX: use $m_i = $macros{$identifier}
  my $cMacroDefs = $macros{$identifier}[0];

  # Check to make sure the macro has multiple
  # definitions-- do this first for speed efficiency
  if ($cMacroDefs == 1) {
#    print STDERR "=> false0\n";
    return $false;
  }

  my $one_expanded_to_just_parens = $false;
  my $one_expanded_to_itself = $false;

  foreach (1..$macros{$identifier}[0]) {
    if (count_macro_args($margs[$macros{$identifier}[$_]]) != 1) {
#      print STDERR "=> false1 at $_\n";
      return $false;
    }
    my $args = $margs[$macros{$identifier}[$_]];
    my $body = $mbody[$macros{$identifier}[$_]];
    #FIX: better way to remove comments?
    # Remove comments
    $body =~ s%//.*$%%g;
    $body =~ s%/\*.*?\*/%%g;
    #FIX: better way to remove l/t whitespace?
    # Remove leading/trailing whitespace
    $body =~ s%^\s*%%g;
    $body =~ s%\s*$%%g;


    my $expands_to_just_parens = $false;
    my $expands_to_itself = $false;
    # FIX: can this be $body ne "()"?
    if ($body =~ /\(\s*\)/) {
      $expands_to_just_parens = $true;
      $one_expanded_to_just_parens = $true;
    } elsif ($args =~ /^\(\s*\Q$body\E\s*\)$/) {
      $expands_to_itself = $true;
      $one_expanded_to_itself = $true;
    }

#    if ($body !~ /\(\s*\)/ && $args !~ /^\(\s*\Q$body\E\s*\)$/ ) {
    if (!$expands_to_just_parens && !$expands_to_itself) {
#      print STDERR "=> false2 at $_: \"$body\",\"$args\"\n";
      return $false;
    }

  }
#  print STDERR "=> true\n";

  # only return true if we got at least one definition of each kind
  if ($one_expanded_to_itself && $one_expanded_to_just_parens) {
    return $true;
  }

#  print STDERR "false3\n";
  return $false;
}

# # Uses $lastline global, too
# sub categorize_macro
# { my ($name, $args, $fullbody) = @_;
#   check_args(1, "categorize_macro", caller, @_);
#   if ($fullbody =~ m!^(.*?)\s*(/\*.*\*/\s*)*(//.*)?$!) {
#     # $1 matches non-commented part w/ leading,trailing ws removed
#     $body = $1;
#   } else {
#     $body = $fullbody;
#   }
#   $fDebugCommentRemoval && print STDERR "fullbody = '$fullbody'\nbody = '$body'\n";
#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: PreventMI: $name\n";
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: NullDefine: $name\n";
#     }
#   }
#   # Must have a body
#   elsif ($body =~ /^\".*\"$/) {
#     $cSimpleStrConstant++;
#     $fShowCategorization &&
#       print CATEG "$current_file:@{[ current_line_no() ]}: SimpleStrConstant: $name $fullbody\n";
#   }
#   # If the type contains a trailing *, the constant is usually (not always!) 0
#   elsif ($body =~ /^\(\(\w+(\s+\**)?\)\s*(.*)\)$/ && FIsNumConst($2)) {
#       $cCastedConstant++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: CastedConstant: $name $fullbody\n";
#     }
#   elsif (FIsNumConst($body) ||
# 	 $body =~ /^'(\\?.|\\[0-7][0-7][0-7])'$/) { # single character constant 'g'
#     # is it just a number, possibly like "(4.566)" or "7" or "0x5FaB" or "'g'"
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cSimpleConstantWithDefault++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: SimpleConstantWithDefault: $name $fullbody\n";
#     }
#     else {
#       $cSimpleConstant++;
#       $fShowCategorization &&
# 	print CATEG "$current_file:@{[ current_line_no() ]}: SimpleConstant: $name $fullbody\n";
#     }
#   }
#   elsif ($body =~ /^(L|x|\d|\(|\s|\)|\<|\>|\+|\-|\=|\*|\||\&|\%|\!)*$/) {
#     # is it a numeric expression?
#     $cSimpleExpression++;
#     $fShowCategorization &&
#       print CATEG "$current_file:@{[ current_line_no() ]}: SimpleExpression: $name $fullbody\n";
#   }
#   else {
#     $cUncategorized++;
#     $fShowCategorization &&
#       print CATEG "$current_file:@{[ current_line_no() ]}: Uncategorized: $name $fullbody\n";
#   }
# }

#FIX: what is this for?  Nobody calls it.
sub checkmacrodef
{
}

# Report "evil" CPP macros:
#  Illegal macros:
#   Unterminated string
#   Wrong length character constant
#   Unterminated character constant
#   Pasting via comments (syntactically legal, but no pasting occurs in ISO C)
#  Potentially dangerous macros:
#   Unbalanced parens, braces, and brackets
#   Pasting via ##
#   Stringization via #
#   Arguments but no body
#  Turned off testing for:
#   Empty string


# Perhaps pass in macro name, for better error messages.

# returns zero if it was ok
# otherwise $EVIL $DANGER $OBSOLETE $ILLEGAL
# (each individual bits)
sub check_macro_body
{ my ($body) = check_args(1, "check_macro_body", caller, @_);
  my $result = 0;
  if ($#_ != 0) { mdie("Wrong number of arguments to check_macro_body."); }
  # print "check_macro_body: $body\n";
  # FIX: These variables do not appear to be used
  my $indquote = $false;
  my $insquote = $false;
  my $incomment = $false;
  my @nesting = ();
  while ($body =~ m/[\]\[(){}\"\'\#]|\/\/|\/\*|\*\//) #'HACKCOLOR
    # Found paren, quote, cpp directive, or comment
    { my $match = $MATCH;
      my $body = $POSTMATCH;
      # print "$match ||| $body\n";
      if ($match =~ /[\[\(\{]/)
        { push(@nesting,$match); }
      elsif ($match =~ /[\]\)\}]/)
	{ if ($#nesting == -1)
	    { $result |= $DANGER;
	      evilprint("dangerous: close $match without open\n    $body\n"); }
	  else
	    { my $popped = pop(@nesting);
	      if ((($match eq "\]") && ($popped ne "\["))
		  || (($match eq "\)") && ($popped ne "\("))
		  || (($match eq "\}") && ($popped ne "\{")))
		{ $result |= $DANGER;
		  evilprint("dangerous: $popped matched by $match:\n    $body\n"); } } }
      elsif ($match eq "\"")
        { if ($body =~ m/$non_escaped_double_quote_re/o)
            # Empty string OK only if that is the entire body.
            { if ($false	# turn off the test for now
		  && ((length($PREMATCH) + length($1) + length($2)) == 0)
		  && (length($body) > 2))
                { $result |= $DANGER;
		  evilprint("dangerous: empty string:\n    $body\n"); }
              $body = $POSTMATCH; }
          else
           { $result |= $ILLEGAL;
	     evilprint("illegal: unterminated string $MATCH:\n    $body\n"); } }
      elsif ($match eq "\'")
        { if (($body =~ m/^\\''/) || ($body =~ m/\'/))
	    { # do this first because we're going to do more matching
	      $body = $POSTMATCH;
	      my $char = $PREMATCH . $MATCH;
              chop($char);	# remove trailing '
	      # Perhaps don't bother with this test; getline already checked
	      # for illegal character constants.
	      if (! ($char =~ m/^$char_literal_contents_re$/o))
	        { $result |= $ILLEGAL;
		  evilprint("illegal: bad character constant $char:\n    $body\n"); }
    	       }
          else
            { $result |= $ILLEGAL;
	      evilprint("illegal: unterminated character constant $MATCH:\n    $body\n");
              $body = ""; } }
      elsif ($match eq "#")
	{ if (substr($POSTMATCH, 0, 1) eq "#")
	    { $result |= $DANGER;
	      evilprint("dangerous: ## pasting:\n    $body\n");
	      $body = substr($body, 1); }
	  # This list from GNU C preprocessor manual
	  # It's not complete, since #assert introduces new preprocessor commands.
	  elsif ($POSTMATCH =~ m/(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|system|unassert|warning)\b/)
	    { $result |= $DANGER;
	      evilprint("dangerous: preprocessor directive #$MATCH:\n    $body\n"); }
	  else
	    { $result |= $DANGER;
	      evilprint("dangerous: stringization:\n    $body\n"); } }
      elsif ($match eq "/*")
	# This test probably fails for a/**//**/b.  Oh, well.
        { my $postmatch = $POSTMATCH;
	  my $precedingabuts = ($PREMATCH =~ m/\w$/);
	  while (not ($postmatch =~ m!\*/!))
	    { my $nextline;
	      if ($nextline = getline())
		# Get some more text, and look for the comment close there.
		{ $body = append_lines($body, $nextline);
		  $postmatch = append_lines($POSTMATCH, $nextline);
		}
	      else
		{ $result |= $EVIL;
		  evilprint("evil: unterminated comment:\n    $body\n");
		  $body = "";
		  $postmatch = ""; } }
	  # print "Setting $body to $POSTMATCH; $PREMATCH; $MATCH.\n";
	  # Redo this because the one in the while test is considered
	  #   in the block, so we lost the (localized) match data.
	  $postmatch =~ m/\*\//;
	  $body = $POSTMATCH;
	  if ($precedingabuts && ($body =~ m/^\w/))
	    { $result |= $OBSOLETE;
	      evilprint("obsoleted: comment pasting:\n    $body\n"); } }
      elsif ($match eq "//")
        { # print "$current_file:@{[ current_line_no() ]}: evil: //-style comment:\n    $body\n";
          $body = ""; }
      elsif ($match eq "*/")
	# $body doesn't give me the whole thing; why?  ($body only contains
	#   what follows the match at this point.)
        { $result |= $EVIL;
	  evilprint("evil: comment terminator */ not in comment:\n    $body\n"); }
      else
        { mdie("$current_file:@{[ current_line_no() ]}: ???: match = $match before $body:\n    $body\n"); }
        }
  if ($#nesting != -1)
    { $result |= $EVIL;
      evilprint("evil: no match for ", @nesting, ":\n    $body\n"); }
  return $result;
}


###########################################################################
### Miscellaneous
###

# like die, but with file and line number prefix
# May also redefine this so that it doesn't die, but just prints a 
# warning to a severe error stream
# Still use regular die for real fatal errors
sub mdie {
  my ($msg) = check_args_at_least(1,"mdie",caller,@_);
  print STDERR "$current_file:@{[ current_line_no() ]}: ", @_, "\n";
  exit -1;
}

# Print a message to the EVIL stream, with file and line number prefix
sub evilprint {
  my ($msg) = check_args_at_least(1,"evilprint",caller,@_);
  unshift @_, "$current_file:@{[ current_line_no() ]}: ";
  print EVIL @_;
  return undef;
}

# Return the current line number-- hopefully we can just compute
# this off of $. and @getline_ungotlines
sub current_line_no {
  check_args(0,"current_line_no",caller,@_);
  return ($. - $#getline_ungotlines - 1);
}

# return the index into the @ft_ arrays for the current filename
# consider how it was included, and whether it's a header or code
sub compute_current_ft_index {
  my ($filename) = check_args(1,"compute_current_ft_slice",caller,@_);

  my $offset = current_file_is_header()? $ft_HEAD_Start: $ft_CODE_Start;

  die "compute_current_ft_index can't determine an index for an inclusion method" 
    if !exists $InclusionMethod_to_Index{$files{$filename}};

  return $offset + $InclusionMethod_to_Index{$files{$filename}};
}


# Tell us if the current file was added by a #include directive
# (as opposed to passed in to evilmacros on the cmd line or in STDIN w/ -i )
sub current_file_was_included {
  check_args(0,"current_file_not_included",caller,@_);
  if ($files{$current_file} =~ /^FromInclude/) { return $true; }
  return $false;
}

# Tell if the current filename looks like a header file
sub current_file_is_header {
  check_args(0,"current_file_not_included",caller,@_);
  if ($current_file =~ /.[hH].?.?$/) { return $true; }
  return $false;
}

# Return the number of arguments, given a macro argument
# declaration.  Just counts number of commas, and adds 1,
# or zero if we were passed "".
sub count_macro_args {
  my ($arg_decl) = check_args(1,"count_macro_args",caller,@_);
  my $retval;

  if ($arg_decl eq "") {
    $retval = 0;
  } else {
    # count the number of commas, by deleting commas
    # (tr returns the number of deletions or substitutions)
    $retval = ($arg_decl =~ tr/,//d) + 1;
  }
  #print STDERR "cma: $retval for $arg_decl\n";
  return $retval;
}

# Return the next available macro index for 
# the @mXXXX arrays
sub next_available_macro_index {
  check_args(0,"next_available_macro_index",caller,@_);
  return $cMacrosInTables++;
}

# Initialize the macros structures for the builtin macros of gcc
# FIX: Should generalize so that it works for non-gcc compilers
# Also, it'd be great to parse Makefile-s and look for -DMACROS 
# and have a way of adding them in as well.
# This list is not necessarily comprehensive even for gcc
# I got it with:
# uni,p1:~/macros% strings /usr/lib/gcc-lib/i486-linux/2.7.2/cpp | more
# and looked for "__"
sub initialize_builtin_macros {
  check_args(0,"initialize_builtin_macros",caller,@_);
  my @empty_def_macros = (
    qw(__LINE__ __DATE__ __FILE__ __BASE_FILE__ __INCLUDE_LEVEL__ __VERSION__ 
     __SIZE_TYPE__ __PTRDIFF_TYPE__  __WCHAR_TYPE__ __USER_LABEL_PREFIX__ 
     __REGISTER_PREFIX__ __IMMEDIATE_PREFIX__ __TIME__ __STDC__ 
     __STDC_VERSION__ __OBJC__) );

  my @string_def_macros = (
    qw(__BASE_FILE__  __VERSION__ __SIZE_TYPE__  __PTRDIFF_TYPE__ 
       __WCHAR_TYPE__  __DATE__  __TIME__ ) );

  my @num_def_macros = ( qw( __STDC__  __OBJC__ ) );

  foreach (@empty_def_macros) {
    $macros{$_} = [1,$cBuiltinMacros];
    $mname[$cBuiltinMacros] = $_;
    $margs[$cBuiltinMacros] = "";
    $mbody[$cBuiltinMacros] = "";
    $mfile[$cBuiltinMacros] = $szBuiltInFakeFile;
    $cBuiltinMacros++;
  }

  foreach (@string_def_macros) {
    $macros{$_} = [1,$cBuiltinMacros];
    $mname[$cBuiltinMacros] = $_;
    $margs[$cBuiltinMacros] = "";
    $mbody[$cBuiltinMacros] = "\"\"";
    $mfile[$cBuiltinMacros] = $szBuiltInFakeFile;
    $cBuiltinMacros++;
  }

  foreach (@num_def_macros) {
    $macros{$_} = [1,$cBuiltinMacros];
    $mname[$cBuiltinMacros] = $_;
    $margs[$cBuiltinMacros] = "";
    $mbody[$cBuiltinMacros] = "1";
    $mfile[$cBuiltinMacros] = $szBuiltInFakeFile;
    $cBuiltinMacros++;
  }

  # This works:
  # print "HERE:", join(',',@$macros{"__LINE__"}), "\n";

  $cMacrosInTables = $cBuiltinMacros;

  return undef;
}


# analyze_for_macro_use($logl_line)
# looks for macros in $logl_line and saves the file,line#

# This won't be quite right since we currently don't look through
# include-s in order note that this is still subject to differences
# from the actual parse by cpp, since not all files are included by
# all files, but we work with a global (to the project) macro
# defintions list
#
# We can do better by ensuring that before we count a macro usage,
# double check to make sure the current file includes a (or is the)
# file which defines the macro (and if it is the file, then make sure
# that the macro was defined on an earlier line number than we're at)
# 
# None of this is done for now, but probably should be later
# Currently, we err on the side of reporting too many uses of macros

# Note: another possible way to do this is with gjb's
# make-inclkude-for-defs-file -- see that in ~gjb/bin/share for eg.
sub analyze_for_macro_use {
  my ($line) = check_args(1,"analyze_for_macro_use",caller,@_);

  die "Shouldn't be analyzing for macro use when finding defs!" 
    if $finding_macro_defs;

  # study $line;  # use this if you're gonna do lots of pattern matches

  # it's interesting whether the use is of a system macro or a project
  # macro
#  foreach $macro (keys %macros) {
#    if ($line =~ /\b\Q$macro\E\b/) {
#    if (index($line,$macro) >= $[) {
#      #print STDERR "AFMU: $macro in $line";
#    }

  my $word;

  my $cpp_line = $false;
  my $cpp_defining_macro_name;

  if (substr($line,0,1) eq "#") {
    $cpp_line = $true;
  }

  # FIX: does this handle #define /* */ TEST properly?
  # ie. have comments been removed for us already by getline
  if ($line =~ /^\# *define\s+(\w+)\b/) {
    $cpp_defining_macro_name = $1;
    #print STDERR "Defining $cpp_defining_macro_name\n";
  }

  foreach $word (split /\W+/,$line) {
    if (defined($macros{$word}) && (!defined($cpp_defining_macro_name) ||
				    $cpp_defining_macro_name ne "$word")) {
      # Need to remember that this macro was used on a code line, or not
      # and that the macro was used on a preprocessor line, or not
      # and that the macro was used in the current function, if any
      # and that the macro was used globally, if it wasn't in a function
      # FIX: do we want to include information about a macro's expansion
      # including another macro?  (like dependent-macros)
      $macros_uses{$word}[$cpp_line? $i_usage_cpp:$i_usage_code ]++;

      if (defined($cpp_defining_macro_name)) {
	my $mi = mindex_from_name_file_line($cpp_defining_macro_name,
					    $current_file,
					    current_line_no());
	push @{$mexpansionuses[$mi]}, $word;
	# print STDERR "Macro $cpp_defining_macro_name expands to something with $word-- using index $mi\n";
      }
      push @{$macros_file_line_uses{$word}}, ($current_file,current_line_no());
    }
  }
}    

#FIX: write this
sub compute_macros_used_in_functions {
  check_args(0,"compute_macros_used_in_functions",caller,@_);

  my ($macro,$uses_ref);

  while ( ($macro,$uses_ref) = each %macros_file_line_uses) {
    my $i = 0;
    # FIX: this is a bit of a hack; we need to empty the cache
    # when we start looking at a different macro's uses, since
    # we can't just continue from our last point if the use
    # happens to be in the same file
    $wf_last_filename = "%EMPTY CACHE%";
    # print STDERR "Handling $macro\n";
    for ( ; $i+1 <= $#{$uses_ref}; $i+=2 ) {
      my ($file,$line) = @{$uses_ref}[$i,$i+1];
      my $function_name;
      if (!($function_name = which_function($file,$line))) {
	$function_name = "%global%";
      }
      # print STDERR "USEIN: $function_name\n";
      push @{$macros_used_in_functions{$macro}}, "$file:$line:$function_name";
    }
  }
}

# return the index into the @mXXX arrays for the macro definition described
sub mindex_from_name_file_line {
  my ($name,$file,$line) = check_args(3,"mindex_from_name_file_line",caller,@_);
  
  my $cDefs = $macros{$name}[0];
  my $i = 1;

  while ( $i <= $cDefs ) {
    my $mi = $macros{$name}[$i];
    my $c_phys_lines = $mplines[$mi];
    my $first_phys_line = $mline[$mi];

    #if ($name eq "NEXTBYTE" || $name eq "NLENGTH") {
    #  print STDERR "l,c,f: $line,$c_phys_lines,$first_phys_line\n";
    #}
    
    #FIX: I'm not convinced about why it needs to be $first_phys_line-1
    if ($mfile[$mi] eq $file && 
	($line >= $first_phys_line-1 && $line <= $first_phys_line + $c_phys_lines)) {
      return $mi;
    }
    $i++;
  }

  die "couldn't find mindex for $name $file $line";

  return undef;
}


# Note: which_function can only be used after a complete second parse
# if you want to be sure you get things right
# use the $files_lines{$filename} list to find what function we're in,
# if any
sub which_function {
  my ($filename, $line_no) = check_args(2,"which_function",caller,@_);

  my $i = 0;

  my $listref = $files_lines{$filename};

  # FIXPERL: what is the implementation of lists? vector or linked-list?
  # FIXPERL: any way to do c-style static lexical variables?
  if ($filename eq $wf_last_filename &&
      $line_no >= $wf_last_line_no) {
    # we're moving forward in the same file, so use our old $wf_last_index
    $i=$wf_last_index;
  }

  # $$listref[i] is starting line of function,
  # $$listref[i+1] is name of function w/ leading "{"
  # $$listref[i+2] is ending line of function,
  # $$listref[i+3] is the information for the next function linearly

  # so if $line_no is between $$listref[i] and $$listref[i+2], inclusively,
  # we return $$listref[i+1]

  # first step through the list to the interesting case

  if (!defined($listref)) {
    print STDERR "no function information for $filename, $line_no";
    return undef;
  }

  if ($#{$listref} < $[ || $line_no < $$listref[0]) {
    return undef;
  }

  while ( $i <= $#{$listref} && $line_no > $$listref[$i]) {
    # print STDERR "Looking at fn $$listref[$i+1] ($$listref[$i],$$listref[$i+2]) for line $line_no in $filename\n";
    $i += 3;
    }

  if ($i >= 3) {
    $i -= 3;
  }
  
  # three possibilities:
  # 1) $i > $#{$listref} => return undef, since it's past all the fns listed
  # 2) $line_no is in the range $$listref[$i] thru $$listref[$i+2] (inclusive),
  #      so return $$listref[$i+1]
  # 3) $line_no > $$listref[$i] => return undef since we're past the line we want

  my $fn_name;			# starts out undefined

  if ($line_no >= $$listref[$i] && $line_no <= $$listref[$i+2]) {
    $fn_name = $$listref[$i+1];
  } elsif ($line_no > $$listref[$i+2]) {
    # undef
  } elsif ($line_no < $$listref[$i]) {
    # undef
  } else {
    die "Uexpected case in which_function: $filename:$line_no, @$listref[$i,$i+2]:\
$i $#{$listref}\n";
  }

  # FIX: remove these debug messages
#  if (defined($fn_name)) {
#    print STDERR "function at $filename:$line_no => $fn_name\n";
#  } else {
#    print STDERR "function at $filename:$line_no => %NONE%";
#  }
    

  ($wf_last_filename, $wf_last_line_no ) = ($filename,$line_no);
  $wf_last_index = $i;

  return $fn_name;
}


###########################################################################
### data structure ops for orthogonal file types
###

sub update_cpp_directives_for {
  my ($cpp_cmd) = check_args(1,"update_cpp_directives_for",caller,@_);

  #FIXPERL: emacs cperl mode requires the space between $ and { below
  #to correctly not parse the { as an open block

  # This code avoids warnings about using uninitialized values
  no strict 'refs';  #FIX: Must I do this?
  if (!defined($ {$rg_cppcmdcounts[$current_ft_index]}{$cpp_cmd})) {
    $ {$rg_cppcmdcounts[$current_ft_index]}{$cpp_cmd} = 0;
  }
  $ {$rg_cppcmdcounts[$current_ft_index]}{$cpp_cmd}++;
  
  $rg_cpp_cmds[$current_ft_index]++;
  #print STDERR "GOTCPP: $cpp_cmd, for $current_ft_index, so have $rg_cpp_cmds[$current_ft_index]\n";
}

# compute $cpp_cmds, $cpp_cmds_ni
# %cppcmpdcount, %cppcmdcount_ni
sub compute_global_cpp_sums {
  check_args(0,"compute_global_cpp_sums",caller,@_);
  
  $cpp_cmds = sum_array(@rg_cpp_cmds[@ft_ALL]);
  $cpp_cmds_ni = sum_array(@rg_cpp_cmds[@ft_NOT_INCLUDED]);
  
  my $hashref;
  my $key;

  my $i = 0;
  no strict 'refs';  #FIX: Must I do this?
  foreach $hashref (@rg_cppcmdcounts[@ft_ALL]) {
    #  for (;  $i < $#rg_cppcmdcounts; $i++) {
    #    foreach $key (keys %{$rg_cppcmdcounts[$i]}) {
    foreach $key (keys %{$hashref}) {
      if (!defined($cppcmdcount{$key})) {
	$cppcmdcount{$key} = 0;
      }
      $cppcmdcount{$key} += $ {$hashref}{$key};
      #print STDERR "KEY=$key, adding ", $ {$hashref}{$key}, "\n";
    }
  }

  foreach $hashref (@rg_cppcmdcounts[@ft_NOT_INCLUDED]) {
    #  for (;  $i < $#rg_cppcmdcounts; $i++) {
    #    foreach $key (keys %{$rg_cppcmdcounts[$i]}) {
    foreach $key (keys %{$hashref}) {
      if (!defined($cppcmdcount_ni{$key})) {
	$cppcmdcount_ni{$key} = 0;
      }
      $cppcmdcount_ni{$key} += $ {$hashref}{$key};
      #print STDERR "KEY=$key, adding ", $ {$hashref}{$key}, "\n";
    }
  }
}

  



###########################################################################
### #include handling
###


# FIX: Should optionally query system for the path
# With gcc, this means compiling a minimal program with gcc -v -c
# and parsing the output.
sub get_include_path {
  check_args(0,"getincludepath",caller,@_);
  @include_path = ( 
		   "/usr/local/include",		
		   "/usr/local/.contrib/gcc-2.7.2/i586-unknown-linux/include",
		   "/usr/local/.contrib/gcc-2.7.2/lib/gcc-lib/i586-unknown-linux/2.7.2/include",
		   "/usr/include",
#FIX: Should I include "."?  If so, then we have to be careful about
# multiple inclusions of header files in the project, since they will
# by pushed onto @files, and also exist in @files already (w/o complete
# pathname) from stdin
#		   ".",
		  );
  return undef;
}

# Search through @include_path's directories and find the first
# directory that has $file in it
sub complete_include_pathname {
  my ($file) = check_args(1,"complete_include_pathname",caller,@_);
  my $complete_file_try;
  my $complete_file = undef;
  foreach (@include_path) {
    $complete_file_try = $_ . "/$file";
    if (-f $complete_file_try) {
      $complete_file = $complete_file_try;
      last;
    }
  }
  # print STDERR "Found $file to be $complete_file\n";
  # returns undefined if never set
  return $complete_file;
}




###########################################################################
### Testing
###

#$current_file = "test.c";

# This comes before the main loop so we can avoid executing it (the main loop).

# { my $argdecls = "int argc;char **argv;{";
#   if ($argdecls =~ /^\s*$type_declarator_re\s*([,;])/)
#     { print "$1|$3|$7|$9|$POSTMATCH\n"; } }

# print "<<" . parse_expression ("(uch)get_byte()") . "\n";
# print "<<" . parse_expression ("get_byte()") . "\n";
# print "<<" . parse_expression ("(uch)get_byte") . "\n";
# print "<<" . parse_expression ("(strcmp((s1),(s2)) == 0)") . "\n";
# print "<<" . parse_expression ("strcmp((s1),(s2))") . "\n";
# print "<<" . parse_expression ("((s1),(s2))") . "\n";
# print "<<" . parse_expression ("(s1),(s2)") . "\n";
# print "<<" . parse_expression ("(s1)") . "\n";
# print "<<" . parse_expression ("s1,s2") . "\n";
# print "<<" . parse_expression ("strcmp(s1,s2)") . "\n";
# print "<<" . parse_expression ("'\\'") . "\n";
# print "<<" . parse_expression ("(1L << (n))") . "\n";
# print "<<" . parse_expression ("(1 << (n))") . "\n";
# print "<<" . parse_expression ("(1 << n)") . "\n";
# print "<<" . parse_expression ("(unsigned)(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("\"foo\"") . ">>\n";
# print "<<" . test_categorize_macro("\"\\037\\235\"") . ">>\n";
# print "<<" . test_categorize_macro("\"\037\235\"") . ">>\n";
# if (parse_expression ("\"foo\"")) { print "FOO is true "; } else { print "false"; }
# if (0) { print "ZERO is true "; } else { print "false"; }
# print type_name(parse_expression("0400")) . "\n";
# print type_name(parse_expression("0x8000")) . "\n";
# print type_name(parse_expression("33 ? 55 : 0x8000")) . "\n";
# print type_name(parse_expression("tab_prefix[i]")) . "\n";
# print defined($type_num["foo"]);
# print "foo" + 0;
# print type_name(1);
# print type_name(parse_expression("flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("block_start >= 0L")) . "\n";
# print type_name(parse_expression("(char*)&window[(unsigned)block_start]")) . "\n";
# print type_name(parse_expression("(char*)NULL, (long)strstart - block_start, (eof)")) . "\n";
# print type_name(parse_expression("&window")) . "\n";
# print type_name(parse_expression("(char*)NULL")) . "\n";
# print type_name(parse_expression("NULL")) . "\n";
# print type_name(parse_expression("(long)strstart - block_start")) . "\n";
# print type_name(parse_expression("(eof)")) . "\n";
# print type_name(parse_expression("(uch)get_byte()")) . "\n";
# test_categorize_macro("(uch)get_byte()");
# print type_name(parse_expression("memset ((voidp)(s), 0, (n))")) . "\n";
# print type_name(parse_expression("((char_type *)(&d_buf[DIST_BUFSIZE-1]))")) . "\n";
# print type_name(parse_expression("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))")) . "\n";
# print type_name(parse_expression("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))")) . "\n";
# print type_name(parse_expression("malloc((size_t)(items)*(size_t)(size))")) . "\n";
# test_categorize_macro("memset ((voidp)(s), 0, (n))");
# test_categorize_macro("((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
# test_categorize_macro("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
# test_categorize_macro("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
# test_categorize_macro("malloc((size_t)(items)*(size_t)(size))");
# $foo = "x"; $foo =~ /x/; print defined($POSTMATCH), defined($POSTMATCH), defined($POSTMATCH), "\n";
# print ("" eq "\n"), "\n";
# test_categorize_macro("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
# print type_name(parse_expression("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))")) . "\n";
# print type_name(parse_expression("inptr < insize")) . "\n";
# print type_name(parse_expression("inbuf[inptr++]")) . "\n";
# # This is failing because of the function call, I suppose.
# print type_name(parse_expression("fill_inbuf(0)")) . "\n";
# print scalar("int fill_inbuf(eof_ok)" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# "abaababb" =~ /(((a+)(b+))*)/; print "<<$1>><<$2>><<$3>><<$4>><<$MATCH>>\n";
# print scalar("static char  *license_msg[] =" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# print scalar("static char *license_msg[] =" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# print scalar("static char" =~ /^\s*$type_specifier_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_unparenthesized_re$/o), "\n";
# print scalar("*" =~ /^$pointer_declarator_prefix_re/o), "\n";
# print scalar("license_msg" =~ /^\s*$identifier_re/o), "\n";
# print scalar("[]" =~ /^\s*$array_declarator_suffix_re/o), "\n";
# print scalar("char" =~ /^$type_re$/o), "\n";
# print scalar("char" =~ /^$type_specifier_re$/o), "\n";
# print scalar("char" =~ /^$identifier_re$/o), "\n";
# print type_name(parse_expression("(ct_data near *)0")), "\n";
# print scalar("(ct_data near *)" =~ /^\s*\(\s*$type_re\s*\)\s*$/o), "\n";
# print parse_array_initializer("bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};\n"), "\n";
# print scalar("(*sig_type)" =~ /^$declarator_re$/o), "\n";
# print scalar("char z_suffix[MAX_SUFFIX+1];" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# print scalar("z_suffix[MAX_SUFFIX+1]" =~ /^$declarator_re$/o), "\n";
# print scalar("[MAX_SUFFIX+1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print scalar("[1]" =~ /^$array_declarator_suffix_re$/o), "\n";
# print join(' -- ', parse_declarator("char", "z_suffix[MAX_SUFFIX+1]")), "\n";
# my @foo = (3,4,5,6); my @bar = @foo; $foo[0] = "new"; print @foo, "\n", @bar, "\n";
# exit;


###########################################################################
### Main loop
###

# This is at the end of the file so that constants and variables can be
# introduced and set near where they are used rather than at the top of the
# file (before the main loop).  This is especially nice for globals that
# are only used by one or two routines.


use Getopt::Std;
getopts($getopts_option_letters);

usage() if ($opt_h);

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    push @files,$_;
    $files{$_} = "FromStdin";
  }
}

if ($opt_a && ($opt_u || $opt_1)) {
  die "Option -a is incompatible with options -u or -1";
}


# using a default directory-- only open the files that
# aren't explicitly given
if ($opt_d) {
  my ($dir,$prefix) = split /:/,$opt_d;

  if (!defined($prefix) || $prefix eq "") {
    $prefix = "";
  } else {
    $prefix .= ".";
  }

  if ($dir !~ /\/$/) {
    $dir .= "/";
  }

  print STDERR "Using $dir with prefix $prefix\n";

  if (!$opt_E) {
    open(EVIL,">$dir/${prefix}evil") || die "Failed opening $!";
  }

  if (!$opt_S) {
    open(STATS,">$dir/${prefix}stat") || die "Failed opening $!";
  }

  if (!$opt_D) {
    open(DEFINES,">$dir/${prefix}def") || die "Failed opening $!";
  }

  if (!$opt_M) {
    open(MACROS,">$dir/${prefix}mac") || die "Failed opening $!";
  }

  if (!$opt_F) {
    open(FUNCTIONS,">$dir/${prefix}func") || die "Failed opening $!";
  }

  if (!$opt_C) {
    open(CATEG,">$dir/${prefix}catg") || die "Failed opening $!";
  }
}

if ($opt_E) { open(EVIL,">$opt_E") || die "Failed opening $opt_E"; }
  else { open(EVIL,">-") || die "Failed opening stdout!"; }
if ($opt_S) { open(STATS,">$opt_S") || die "Failed opening $opt_S"; }
if ($opt_F) { open(FUNCTIONS,">$opt_F") || die "Failed opening $opt_F"; }
if ($opt_D) { open(DEFINES,">$opt_D") || die "Failed opening $opt_D"; }
if ($opt_M) { open(MACROS,">$opt_M") || die "Failed opening $opt_M"; }
if ($opt_C) { open(CATEG,">$opt_C") || die "Failed opening $opt_C"; }
if ($opt_I) { $fIgnoreIncludes = $true; }
if ($opt_t) { $outOFS = "	"; } # use tab for OFS

# Now set these so we'll actually do the output
# (output_stats uses $opt_X as a guard for printing)
$opt_E = $true;
$opt_S = $true;
$opt_D = $true;
$opt_M = $true;
$opt_F = $true;
$opt_C = $true;


$fDebugCmdProcessing && print "@ARGV";

# Add the rest of the arguments to the files list
foreach $_ (@ARGV) {
  push @files,$_;
  $files{$_} = "FromCmdLine";
}

# Testing
# test_typedecl_regexp(); exit();

get_include_path();
initialize_builtin_macros();

# Begin Processing files

print STDERR "Processing at least ", $#files+1, " files (plus possible \#included files)...\n";

find_macro_definitions();	# also counts other preprocessor usage

# Kind of a hack
{ my $name;
  for $name (keys %macros)
    { if (is_fun_decl_arg_macro($name))
	{ $fun_decl_arg_macros{$name} = $true; } } }
# print "fun_decl_arg_macros: ", join(" ", (keys %fun_decl_arg_macros)), "\n";

# { my $ofdefs;
#   for $ofdefs (1..$macros{"OF"}[0])
#     { print "|", join("|", $mname[$macros{"OF"}[$ofdefs]], $margs[$macros{"OF"}[$ofdefs]], $mbody[$macros{"OF"}[$ofdefs]], $mfile[$macros{"OF"}[$ofdefs]], $mline[$macros{"OF"}[$ofdefs]]), "|\n"; } }


# Print number of definitions for each macro
# { my $name;
#   for $name (sort keys %macros)
#     { print "$name $macros{$name}[0]\n"; } }

get_macro_call_types() if (!$opt_1);

#FIX: should I only print this stuff w/ -v?
print STDERR "Computing various global statistics...\n";

compute_global_cpp_sums();
compute_macros_used_in_functions();

### All the files have been read; now process the macros
# We initialized $cppcmdcount{"define"}, so it will be defined
print STDERR "Processing " . $cppcmdcount{"define"} . " macros\n";
{ my $i;
  # FIX: throughout coode, use explicit for-loop-s instead-- 
  # this builds an array and has extra overhead in both space and time
  for ($i = $cBuiltinMacros; 
       $i <= $cppcmdcount{"define"} + $cBuiltinMacros-1; 
       $i++ )
    { # print "$i: $mbody[$i]\n";
      #   print &parse_expression($mbody[$i]) . ": ";
      #   foreach $var (keys(%parsevars)) { print $var . " "; }
      #   print "\n  $mname[$i]";
      #   if (defined($margs[$i])) { print $margs[$i]; }
      #   print " $mbody[$i]\n";
      categorize_macro($i);
    } }

# 	  # Nothing to check if this is just making the macro defined w/o a body.
# 	  if (defined($mdef) && ($flags = check_macro_body($mdef)) != 0) {
# 	    $cEvil++ if $flags & $EVIL;
# 	    $cIllegal++ if $flags & $ILLEGAL;
# 	    $cObsoleted++ if $flags & $OBSOLETE;
# 	    $cDanger++ if $flags & $DANGER;
# 	  }

#FIX: split output_stats into two pieces-- one for after first pass,
# and one for after second pass
# (at least until we make mdie do something better than die)
output_stats();

#print STDERR "Included files:", join("\n",@files_included), "\n";

exit();

### Local Variables:
### page-delimiter: "^#################################################*\n"
### End:
