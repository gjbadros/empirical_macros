#!/uns/bin/perl -w
# $Id$
# evilmacros

# Report "evil" CPP macros:
#  Illegal macros:
#   Unterminated string
#   Wrong length character constant
#   Unterminated character constant
#   Pasting via comments (syntactically legal, but no pasting occurs in ISO C)
#  Potentially dangerous macros:
#   Unbalanced parens, braces, and brackets
#   Pasting via ##
#   Stringization via #
#   Arguments but no body
#  Turned off testing for:
#   Empty string

# FIX: the options are non-orthogonal ... this is confusing
sub usage {
  die "@_\nUsage: $0 [-ihvDsS] <files>
  -i  use files listed on stdin [one per line] in addition to any on cmd line
  -h  display this help message
  -v  be verbose and list files as they are processed to stderr
  -D [file]  output the names of the macros (and number of times defined)
  -S [file]  output the per directive statistics to file
  -c [file]  show categorizations to file
  -e [file]  send evil macros to file instead of stdout
";
}

# Invoke like this:   evilmacros `find-c`
# or like this:  find-c | evilmacros -i
# Perhaps this should do the searching through subdirectories itself,
# but that is easy to do from the shell.

#Complex execution (use zsh):
# ext=all; p=~/505/data; for i in *(/); do pushd $i; find-c | nice evilmacros -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# alias find-c='find . \( -name UNUSED -o -name CVS -o -name SCCS -o -name RCS \) -prune -o \( -name "*.[chCH]" -o -name "*.[cC][cC]" -o -name "*.[cC][pP][pP]" \) -print'
# ext=all; p=/tmp/mernst/data; for i in *(/); do pushd $i; find-c | nice /homes/rivers/mernst/research/notkin/macros/evilmacros-961223 -i -D$p/$i.def.$ext -e$p/$i.em.$ext -c$p/$i.cat.$ext -S$p/$i.stat.$ext > $p/$i.out.$ext 2> $p/$i.err.$ext; popd; done
# For some reason, adding " >&! ../out-err" doesn't work.
# Probably omit ">! ../out-out", too, so I can see output.
# find-c | evilmacros -i -D../out-def -e../out-evil -c../out-cat -S../out-stat -v >! ../out-out
# Bad idea: it's best to operate on an entire project, so you know all the
# functions, macros, etc.
# evilmacros -D../out-def -e../out-evil -c../out-cat -S../out-stat -v getopt.c

# Harbison & Steele p. 53:
#   ISO C reaffirms that macro bodies must be sequences of well-formed tokens.
# For instance, no unterminated strings permitted.

# Harbison & Steele p. 19 notes:
#   Comments are removed by the compiler before preprocessing or lexical
#   analysis, so line breaks inside comments do not terminate preprocessor
#   commands.
# However, continuation line pasting apparently occurs before comment removal.


###########################################################################
### To do
###

## Temporarily moved into my notes-macros file.



###########################################################################
### Strictures
###

# Use strict requires that for each global, either
#  * all uses are fully qualified with the package name ($main::$true), or
#  * it is declared with "my" or appears in a use vars qw( ... ) declaration.
use strict;

# "use English" lets or requires (I don't know) use of $line or some such
# in place of $. and so forth.)
# Why is it not turned on?
# use English;



###########################################################################
### Constants
###

### Boolean
my $true = (1 == 1);
my $false = (1 == 0);

# some evilness (pasting, stringization) is independent of the others,
# though it may not be able to be classified (actually, stringization
# is pretty easy to classify, when we see that a macro argument follows #).
# In this case evilness is more need-for-preprocessor.

# Also note that some evilness has to do with whole files, or parsing,
# while other has to do with macros that have to be macros.
# Maybe rename the latter from "evil" to "macrofeature" or some such.

# These should probably be merged into failure categories, below
my $OBSOLETE = 1;
my $DANGER = 2;
my $EVIL = 3;
my $ILLEGAL = 4;

# Nonconstant: free var (var, function, etc), expression w/side effect,
#	inconsistent types, etc.
# Statement (??)
# Other unclassifiable: give evilness reason, or name the free var,
#	or do multiple of these.


# Categories

my $catNOTYET = 0;			# shouldn't be used; should be undefined instead
my $catINPROCESS = 1;
my $catMULTIPLE = 2;
my $catNULLDEFINE = 3;
# Expressions
my $catEXP = 4;
my $catEXPFREE = 5;		# expression with free variables
my $catLITERAL = 6;			# also specify the literal
my $catCONSTANT = 7;			# need to also specify the particular value, if possible
my $catSOMECONSTANT = 8;
# Non-expressions
my $catFAILURE = 9;		# shouldn't have just one, should have many
my $catTYPEARG = 10;			# macro argument has a type
# These shouldn't be failures
my $catMACROFUN = 11;
my $catMACROTYPE = 12;

my @categoryname = ('uncategorized', 'being categorized', 'multiply categorized', 'null define', 'expression', 'expression with free variables', 'literal', 'constant', 'some constant', 'failed categorization', 'has type argument', 'macro as function', 'macro as type');

## Needs to be fixed.
## Perhaps give actual constant, so it can be determined.
sub category_lub
{ my ($c1, $c2) = @_;
  check_args(2, "category_lub", caller, @_);
  return (($c1 == $c2) ? $c1 : $catMULTIPLE);
}


###########################################################################
### Regular expressions
###

# Use /o in matches for these, so interpolation/compilation occurs just once.
# Use single, not  double, quotes so as not to lose the backslashes.
# But note that \\ and \' are interpolated in single-quoted strings.
# "\b" prevents two words from running up against one another
# These regexps are intended not to include any leading or trailing space

# FIX: this regexp is lame-- L,x,U needed for 0x80 << 1LU
my $constant_exp_re = '[-LxU0-9() \t<>+=*|&%!]+';	# note this matches whitespace

# Types and declarations/definitions.
# These should be $identifier_re, not "\w+"
my $identifier_re = '\b[a-zA-Z_]\w*\b';	# 0 groups
my $type_specifier_re = $identifier_re . '(?:\s+' . $identifier_re. ')*'; # 0 groups
my $type_re = $type_specifier_re . '(?:\s*(?:\*|\[\s*\]))*'; # 0 groups
# Use $type_declarator_re instead.
# $type_identifier_re = $type_re . '\s*' . $identifier_re;

# Declarators are actually rather more complicated than this:  see H&S p. 85.
my $type_qualifier_re = '\b(?:const|volatile)\b'; # 0 groups
my $pointer_declarator_prefix_re = '\*(?:\s*' . $type_qualifier_re . ')*'; # 0 groups
my $array_declarator_suffix_re = '\[(?:' . $constant_exp_re . ')?\]'; # 0 groups
# $function_declarator_suffix_re = ...;
# declaratorsuffix = $array_declarator_suffix_re plus $function_declarator_suffix_re
my $declarator_unparenthesized_re = '(?:' . $pointer_declarator_prefix_re . '\s*)*'
  . $identifier_re
  . '(?:\s*' . $array_declarator_suffix_re . ')*'; # 0 groups
my $declarator_re = '(\(' . $declarator_unparenthesized_re . '\)|'
  . $declarator_unparenthesized_re . ')'; # 1 group: the declarator
# Use this in preference to $type_identifier_re
# 2 groups: $1 = type specifier, $2 = declarator
my $type_declarator_re = '(' . $type_specifier_re . ')\s*' . $declarator_re;

# # This isn't going to work, because of looping.  Break the loop somehow.
# $simple_declarator_re = $identifier_re;
# $arraydeclarator = $directdeclarator . '\s*\[(' . $constant_exp_re . ')?\]';
# $direct_declarator_re = '(' . $arraydeclarator . '|' . $simple_declarator_re . ')';
# $pointer_declarator_re = '\*(\s*' . $type_qualifier_re . ')*\s*' . $direct_declarator_re;
# $declarator_re = '(' . $pointer_declarator_re . '|' . $direct_declarator_re . ')';
# type plus identifier:  $1 = type, $5 = identifier

# Numeric literals
# floating-point number (two variants): $1 = exponent, $2 = suffix (fFlL)
my $float_literal_whole_re = '[-+]?\d+\.\d*([eE][-+]?\d+)?([fFlL]?)'; # decimal 2.
my $float_literal_frac_re = '[-+]?\d*\.\d+([eE][-+]?\d+)?([fFlL]?)'; # fraction .2
# integer regexp: $1 = number, $2 = suffix (uUlL)
my $hex_literal_re = '(0x[0-9a-fA-F]+)([uUlL]?[uUlL]?)';
my $dec_oct_literal_re = '(\d+)([uUlL]?[uUlL]?)';

# Character and string literals
my $char_literal_contents_re = '(\\\\?.|\\\\[0-7][0-7][0-7])';
my $char_literal_re = "L?'" . $char_literal_contents_re . "'";
my $non_escaped_double_quote_re = '(^|[^\\\\])(\\\\\\\\)*\"';
# non-greedy '.*?' because '.*' matches too much, skips over intervening quotes
my $string_literal_re = 'L?\"(|.*?[^\\\\])(\\\\\\\\)*\"'; # string literal

# Does not handle enum, struct, union, and function types
my $numeric_type_word_re = '\b(short|signed|unsigned|long|int|char|float|double)\b';
my $numeric_type_re = $numeric_type_word_re . '(\s+' . $numeric_type_word_re . ')*';
my $non_numeric_type_re = '\b(void)\b';
my $builtin_type_base_re = "($numeric_type_re|$non_numeric_type_re)";
my $type_suffix_re = '(\s*(\*|\[\d*\]))*'; # note contains leading whitespace
my $builtin_type_re = $builtin_type_base_re . $type_suffix_re;


###########################################################################
### Types
###

# Perhaps reserve 0 for unrecognized (non-built-in) type.
# No, with new scheme it's important that it be 0
my $typeFAIL = 0;			# does not parse as a valid type
my $typeBOOL = 1;
my $typeCHAR = 2;			# ought to have typeWCHAR as well
my $typeUCHAR = 3;
my $typeSCHAR = 4;
my $typeSHORT = 5;
my $typeUSHORT = 6;
my $typeINT = 7;
my $typeUINT = 8;
my $typeLONG = 9;
my $typeULONG = 10;
my $typeFLOAT = 11;
my $typeDOUBLE = 12;
my $typeLDOUBLE = 13;
my $typeSTRING = 14;
my $typeUNKNOWN = 15;		# we know it's some type, but don't know which
my $typeUNSPECIFIED = 16;		# declared w/o a type (e.g., as function arg)

my %type_num = ('short' => $typeSHORT, 'short int' => $typeSHORT,
	     'signed short' => $typeSHORT, 'signed short int' => $typeSHORT,
	     'unsigned short' => $typeUSHORT, 'unsigned short int' => $typeUSHORT,
	     'int' => $typeINT, 'signed int' => $typeINT, 'signed' => $typeINT,
	     'unsigned int' => $typeUINT, 'unsigned' => $typeUINT,
	     'long' => $typeLONG, 'long int' => $typeLONG,
	     'signed long' => $typeLONG, 'signed long int' => $typeLONG,
	     'unsigned long' => $typeULONG, 'unsigned long int' => $typeULONG,
	     'char' => $typeCHAR,
	     'unsigned char' => $typeUCHAR,
	     'signed char' => $typeSCHAR,
	     'float' => $typeFLOAT,
	     'double' => $typeDOUBLE,
	     'long double' => $typeLDOUBLE,
	     'char *' => $typeSTRING, 'char*' => $typeSTRING);

my @type_name_array = ('typeFAIL', 'bool',
		    'char', 'unsigned char', 'signed char',
		    'short', 'unsigned short',
		    'int', 'unsigned int',
		    'long', 'unsigned long',
		    'float', 'double', 'long double',
		    'char *',
		    'TYPEunknown');

# For determining whether a Perl variable has numeric type.
# This is incredibly disgusting; do something about it.
sub is_number
{
  my ($arg) = @_;
  check_args(1, "is_number", caller, @_);
  $arg =~ /^\d+$/;
}

sub type_name
{
  my ($type) = @_;
  check_args(1, "type_name", caller, @_);
  if (is_number($type))
    { return $type_name_array[$type]; }
  else
    { return $type; }
}

sub type_to_num
{
  my ($type) = @_;
  check_args(1, "type_to_num", caller, @_);
  # print "type = $type; type_num{type} = $type_num{$type} \n";
  $type =~ s/\s+/ /og; # compress multiple spaces to just one
  if (defined($type_num{$type}))
    { return $type_num{$type}; }
  else
    { return $type; }
}


### Numeric types

# This doesn't yet do the right thing.
sub infer_int_type
{
  my ($int) = @_;
  check_args(1, "infer_int_type", caller, @_);
  if ($int =~ /^0[xX]/)
    # Hex
    { # return first of ($typeUINT $typeLONG $typeULONG) in which the number fits
      return $typeUINT; }
  elsif ($int =~ /^0/)
    { return $typeINT; }	# was unsigned int in non-ANSI C.
  else
    { # return first of ($typeINT $typeLONG $typeULONG) in which the number fits
      return $typeINT; }
}

sub type_integral_p
{ my ($type) = @_;
  check_args(1, "type_integral_p", caller, @_);
  return (($type == $typeBOOL)
	  || ($type == $typeCHAR) || ($type == $typeUCHAR) || ($type == $typeSCHAR)
	  || ($type == $typeSHORT) || ($type == $typeUSHORT)
	  || ($type == $typeINT) || ($type == $typeUINT)
	  || ($type == $typeLONG) || ($type == $typeULONG));
}

### Type manipulation: arrays, pointers, functions

sub type_dereference
{ my ($type) = @_;
  check_args(1, "type_dereference", caller, @_);
  if ($type == $typeSTRING)
    { return $typeCHAR; }
  if ($type =~ /(\*|\[\])\s*$/)
    { return $`; }
  return $typeUNKNOWN;
}

# A function type looks like ( ),( ),( )->( )
# The full parentheses are necessary (but I don't think they are sufficient)
# to avoid misparsing nested function types.  Maybe that doesn't happen...

# sub type_apply ...


### Type conversions

# Perhaps these should be arrays instead.

sub type_unsigned
{
  my ($type) = @_;
  check_args(1, "type_unsigned", caller, @_);
  if (($type == $typeCHAR) || ($type == $typeSCHAR))
    { return $typeUCHAR; }
  elsif ($type == $typeSHORT)
    { return $typeUSHORT; }
  elsif ($type == $typeINT)
    { return $typeUINT; }
  elsif ($type == $typeLONG)
    { return $typeULONG; }
  else
    { return $type; }
}

sub type_signed
{
  my ($type) = @_;
  check_args(1, "type_signed", caller, @_);
  if (($type == $typeCHAR) || ($type == $typeUCHAR))
    { return $typeSCHAR; }
  elsif ($type == $typeUSHORT)
    { return $typeSHORT; }
  elsif ($type == $typeUINT)
    { return $typeINT; }
  elsif ($type == $typeULONG)
    { return $typeLONG; }
  else
    { return $type; }
}

sub type_long
{
  my ($type) = @_;
  check_args(1, "type_long", caller, @_);
  if ($type == $typeCHAR)
    { return $typeLONG; }
  elsif ($type == $typeUCHAR)
    { return $typeULONG; }
  elsif ($type == $typeSCHAR)
    { return $typeLONG; }
  elsif ($type == $typeSHORT)
    { return $typeLONG; }
  elsif ($type == $typeUSHORT)
    { return $typeULONG; }
  elsif ($type == $typeINT)
    { return $typeLONG; }
  elsif ($type == $typeUINT)
    { return $typeULONG; }
  elsif ($type == $typeLONG)
    { return $typeLONG; }
  elsif ($type == $typeULONG)
    { return $typeULONG; }
  else
    { return $type; }
}

# The "usual binary conversions"; H&S p. 176
# except that if types are identical, it returns them.
# Can also return short, ushort.
sub type_lub
{ my ($t1, $t2) = @_;
  check_args(2, "type_lub", caller, @_);
  # This test works whether $t1, $t2 are numbers or strings
  if ($t1 eq $t2)
    { return $t1; }
  if (!is_number($t1))
    { $t1 = $typeUNKNOWN; }
  if (!is_number($t2))
    { $t2 = $typeUNKNOWN; }
  if ($t1 > $t2)
    { ($t1, $t2) = ($t2, $t1); }
  # If either $t1 or $t2 is a string, its numeric equivalent is zero
  if ($t1 == 0)			# 0 == $typeFAIL
    { return $typeFAIL; }
  if ($t2 == $typeUNKNOWN)
    { return $typeUNKNOWN; }
  if (($t2 == $typeLDOUBLE) || ($t2 == $typeDOUBLE) || ($t2 == $typeFLOAT)
      || ($t2 = $typeULONG) || ($t2 = $typeLONG)
      || ($t2 == $typeUINT) || ($t2 == $typeINT)
      || ($t2 == $typeUSHORT)  || ($t2 == $typeSHORT))
    { return $t2; }
  # Otherwise, differing char types.
  return $typeSHORT;
}

### Declarators

# FIX: GJB
# Given a basetype and declarator string, return a type and an identifier.
sub parse_declarator
{ my ($basetype, $declarator) = @_;
  check_args(2, "parse_declarator", caller, @_);
  if (!($declarator =~ /$identifier_re/o))
    { die "no word in declarator $declarator"; }
  my $id = $&;
  my $prefix = $`;
  my $suffix = $';
  while ($id =~ /^$type_qualifier_re$/o)
    { if (!($suffix =~ /$identifier_re/o))
	{ die "no non-type-qualifier word in declarator $declarator"; }
      $id = $&;
      $prefix .= $`;
      $suffix = $'; }
  if ($suffix =~ /$identifier_re/o)
    { die "multiple words in declarator $declarator"; }
  return ("$prefix($basetype)$suffix", $id);
}


###########################################################################
### Variables
###

## Integers:
my $lines = 0;			# count of lines; line continuation doesn't increment
my $cpp_cmds = 0;			# total preprocessor commands
my $symtab_scopes = 0;		# the number of scopes, less the global scope
## Strings:
my $line = "";			# current line
# $lastline = "";			# the prior line
# $mname = 0;
# $margs = 0;
# $mdef = 0;

my $currentfile;		# the current file name

## Arrays
my %cppcmdcount = ();		# number of uses of each cpp command
# %files: contains each file processed

# perhaps make %macros proper just index into other arrays.

my %macros = ();	  # for each macro, list of indexes for info about it
			  # (first list element is number of following elements)

# Also want to have summary info true about all definitions...
use vars qw(@mname @margs @mbody @mfile @mline
	    @mbody_noc %mfreevars @mfreefuns
	    @mdependenton @mtype @mcategory @mevilness);
# These are for aggregate information.  Keep it for all macros, or just
# those multiply defined?  Or put it in the other arrays?  (No.)
use vars qw(%mntype %mncategory);

# Macros which expand to their argument or the empty list, for function arg decls.
my %fun_decl_arg_macros;

## Debugging; should add more
my $fDebugCmdProcessing = $false;
my $fDebugCommentRemoval = $false;
my $fShowCategorization = $false;
my $debug_scopes = $false;

## Command-line processing
use vars qw($opt_i $opt_h $opt_v $opt_D $opt_S $opt_c $opt_e);



###########################################################################
### Main loop routines
###

# These indicate the pass, for getline_handle_preprocessor_command.
# Since they're dynamically bound with "local", can't declare them with "my".
use vars qw($finding_macro_defs $getting_macro_call_types $merge_cpp_if_branches);
$finding_macro_defs = $false;
$getting_macro_call_types = $false;
$merge_cpp_if_branches = $false;

# For getline():
# These can't be declared with "my" because they're dynamically bound
use vars qw($getline_nocomment $getline_simplify $getline_nocpp);
$getline_nocomment = $false;
$getline_simplify = $false;
$getline_nocpp = $false;
my @getline_ungotlines = ();
#gd# my @getline_ungotdependenton = ();

my @dependenton = ();
# Need a stack of old dependentons, for use by ungetline?  Or maybe just
# let peek_line take an optional argument.  No, I decided against having
# peek_line do any macro processing.


### Read files, save info about macros
sub find_macro_definitions
{
  check_args(0, "find_macro_definitions", caller, @_);
  if ($finding_macro_defs)
    { die "Called find_macro_definitions, but already finding macrodefs"; }
  local $finding_macro_defs = $true;
  my $file;
  foreach $file (@ARGV)
    { $currentfile = $file;	# $file is localized to foreach loop
      if ($opt_v)
	{ print STDERR $currentfile . "\n"; }
      open(INPUT,$currentfile) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$currentfile} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      while ($line = getline())
	{
	  # Amazingly enough, all the work is done by getline, which
	  # calls process_macro_definition.
	}
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      close(INPUT);
    }
}

# Given a macro definition (everything after "#define", with no leading,
# trailing space), enter it into the appropriate global arrays
sub process_macro_definition
{
  my ($def) = @_;
  check_args(1, "process_macro_definition", caller, @_);
  # print "process_macro_definition <<$def>>\n";
  my ($name, $args, $body) = macroparse($def);

  if (!defined($args)) { $args = ""; }
  # print "parsed: |$name|$args|$body|\n";
  my ($thisnum) = $cppcmdcount{"define"}-1;
  if (!defined($macros{$name}[0]))
    { $macros{$name}[0] = 0; }
  $macros{$name}[0] += 1;
  $macros{$name}[$macros{$name}[0]] = $thisnum;
  # print "def number $macros{$name}[0]:";
  # for ($i = 1; $i <= $macros{$name}[0]; $i++)
  #   { print " $macros{$name}[$i]"; }
  # print "\n";
  $mname[$thisnum] = $name;
  $margs[$thisnum] = $args;
  $mbody[$thisnum] = $body;
  $mdependenton[$thisnum] = @dependenton;
  if (!defined($currentfile))
    { die "undefined currentfile"; }
  $mfile[$thisnum] = $currentfile;
  $mline[$thisnum] = $.;
}


sub output_stats
{
  check_args(0, "output_stats", caller, @_);

  if ($lines == 0) {
    print STDERR "No lines read! Perhaps you meant to use the -i option?\n";
  } else {
    if ($opt_S) {
      my ($h, $v);
      # Dump statistics on frequencies of directives
      printf STATS "DIRECTIVES#: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	print STATS "$h ";
      }
      print STATS "\n";
      printf STATS "DIRECTIVES: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	print STATS "$v ";
      }
      print STATS "\n";
      printf STATS "DIRECTIVES%: ";
      while ( ($h,$v) = each(%cppcmdcount) ) {
	printf STATS "%2.2f ", (100*$v/$lines);
      }
      print STATS "\n";

      printf STATS "GLOBAL: $cppcmdcount{'define'} define-s (%2.2f%), " . ($cpp_cmds - $cppcmdcount{"define"}) . " other (%2.2f%), $lines lines (%2.2f%), %d files\n",
      100*$cppcmdcount{"define"}/$lines, 100*($cpp_cmds - $cppcmdcount{"define"})/$lines,
      100*($cpp_cmds)/$lines, $#ARGV+1;
      # printf STATS "EVILSTATS: $cObsoleted obsoleted (%2.2f%), $cDanger dangerous (%2.2f%), $cEvil evil (%2.2f%), $cIllegal illegal (%2.2f%)\n",
      # pct($cObsoleted), pct($cDanger), pct($cEvil), pct($cIllegal);

      # Show categorization
      print STATS "CATEGORIZATION:";
      my $catname;
      foreach $catname (@categoryname)
	{ print STATS "\t$catname"; }
      print STATS "\n";
      print STATS "CATEGORIZATION#:";
      # Need to count up total numbers for each categorization.
      # print STATS "CATEGORIZATION: $cppcmdcount{"define"} $cNullDefine $cPreventMI $cSimpleConstant $cSimpleConstantWithDefault $cSimpleStrConstant $cCastedConstant $cSimpleExpression $cWithNullArgs $cWithArgs $cUncategorized\n";
      print STATS "\n";
      print STATS "CATEGORIZATION%:";
      # Need to count up percentages for each categorization.
      #     printf STATS "CATEGORIZATION%: %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f %2.2f\n",
      #     pct($cppcmdcount{"define"}),pct($cNullDefine),pct($cPreventMI),pct($cSimpleConstant),
      #     pct($cSimpleConstantWithDefault),pct($cSimpleStrConstant),pct($cCastedConstant),
      #     pct($cSimpleExpression),pct($cWithNullArgs),pct($cWithArgs),pct($cUncategorized);
      print STATS "\n";
    }

    # -D = dump the defines
    if ($opt_D) {
      my $name;
      foreach $name (keys %macros) {
	# Could also print number of times it's defined.
	print DEFINES "$name\n";
      }
    }
  }
}

# pct(x) returns a percentage of macros defined
sub pct {
  my ($x) = @_;
  check_args(0, "pct", caller, @_);
  if (!defined($x))
    { return; }
  if ($x < 0 || $x > $cppcmdcount{"define"}) {
    print STDERR "Percentage out of range: $x / $cppcmdcount{'define'}\n";
  }
  return (100*$x/$cppcmdcount{"define"});
}

sub test_typedecl_regexp
{
  check_args(0, "test_typedecl_regexp", caller, @_);
  my $file;
  foreach $file (@ARGV)
    { $currentfile = $file;	# $file is localized to foreach loop
      if ($opt_v)
	{ print STDERR $currentfile . "\n"; }
      open(INPUT,$currentfile) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$currentfile} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      while ($line = getline())
	{ if ($line =~ /^$type_specifier_re/o)
	    { print "ts: <<$&>> $line"; }
	  if ($line =~ /^$type_declarator_re/o)
	    { print "td: <<$&>> $line"; }
	  if ($line =~ /^$type_declarator_re\s*[,=;\(]/o)
	    { print "td+: $line"; }
	}
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      close(INPUT);
    }
}



###########################################################################
### Parsing
###

my $incomment = $false;		# in /* */ style comment
my $instring = $false;
# Shouldn't be in a character constant across lines.
# my $incharconst = $false;
use vars qw($commaop);		# not "my" because dynamically bound
$commaop = $true;		# whether commas should be operators or not
				# (they shouldn't in arglists, initializers)


# Uses globals $getline_nocomment and $getline_simplify.
#   If $getline_nocomment is set, then comments are stripped from result.
#   If $getline_simplify is set, then character and string literals are
#     replaced by 'a' and "", respe respectively.  That lets us do a simple
#     syntactic check for parens, braces, commas, etc., obviating the need
#     for has_token, which redoes all this work anyway.
# If calls to ungetline have been made, those strings are returned (uses
#   global @getline_ungotlines), without any processing of comments or
#   literals, but with macro preprocessor command processing.  peek_line
#   avoids macro preprocessor command processing by setting $getline_nocpp.
# To simplify an arbitrary string, use updateinvars.

# Read the next logical line from <INPUT>, until no continuation char
#   and not in string or comment.
# Result ends with newline.
# With argument, doesn't pop (actually, shift) from getline_ungotlines.
sub getline
{ my ($dont_pop) = @_;
  if (!defined($dont_pop))
    { $dont_pop = $false; }
  check_args_range(0, 1, "getline", caller, @_);

  if ($instring || $incomment)
    { die "Bad instring $instring or incomment $incomment"; }

  my $result;
  if ((@getline_ungotlines > 0) && (!$dont_pop))
    { # print "popping getline_ungotlines $getline_ungotlines[$#getline_ungotlines]"; # no newline: it ends with one
      # print "all ungotlines: <<", join(">><<", @getline_ungotlines), ">>\n";
      #gd# @dependenton = shift(@getline_ungotdependenton);
      #gd# return shift(@getline_ungotlines);
      $result = shift(@getline_ungotlines);
    }
  else
    { if (not ($result = <INPUT>))
	{ return $result; }
      $lines++;

      $result = updateinvars($result);
      # perhaps check for $mname and mention it in message if it's set
      while ($incomment || $instring || ($result =~ m/\\$/))
	{
	  # splice lines
	  while ($result =~ m/\\$/)
	    {			# block to localize match data
	      { if ($result =~ m/\\\Z(?!\n)/) # backslash, end of string, no newline
		  { print EVIL "$currentfile:$.: evil: file ends with backslash (no newline)\n"; } }
	      $result = $`;	# remove backslash and possibly newline
	      my $nextline;
	      if ($nextline = <INPUT>)
		{ $nextline = updateinvars($nextline);
		  $result = append_lines($result, $nextline);
		  # The append_lines trims trailing spaces, prettying the message.
		  if ($nextline =~ m/^\s*$/)
		    {		# No \n at end: $result ends in a newline
		      print EVIL "$currentfile:$.: dangerous: blank line follows continuation character:\n    $result"; }
		}
	      else
		# Already removed backslash and newline from result.
		# (Should I add them back?)
		{ print EVIL "$currentfile:$.: dangerous: file ends with continuation character:\n    $result\n"; } }

	  while ($incomment)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $lines++;
		  $nextline = updateinvars($nextline);
		  $result = append_lines($result, $nextline); }
	      else
		{ print EVIL "$currentfile:$.: dangerous: file ends in comment:\n    $result";
		  $incomment = 0; } }

	  # Not "while ($instring) ..." because processing continuation lines
	  # takes priority over simple concatenation.
	  if ($instring)
	    { my $nextline;
	      if ($nextline = <INPUT>)
		{ $lines++;
		  $nextline = updateinvars($nextline);
		  # Strict ANSI C does not permit newlines in string constants;
		  # perhaps warn.
		  # Not "$result = append_lines($result, $nextline);" because in string.
		  $result = $result . $nextline;
		}
	      else
		{ print EVIL "$currentfile:$.: dangerous: file ends in string:\n    $result\n";
		  $instring = 0; } }
	} }

  if (($result =~ /^\#/) && !$getline_nocpp)
    { # Preprocessor line; usually just return "\n";
      return getline_handle_preprocessor_line($result);
    }

  if ($result eq "")
    { die "empty getline result"; }
  # print "getline returning <<$result>>\n"; # $result ends in newline
  $result;
}

# Users shouldn't use this, because they won't be able to correctly set
# getline_ungotdependenton.
# sub ungetline
# {
#   my ($ungotline) = @_;
#   check_args(0, "ungetline", caller, @_);
#   push (@getline_ungotlines, $ungotline);
# }

#gd# This clever saving and restoring of @dependenton is neat and all that, but
#gd# perhaps misguided.  Instead, change the contract of peek_line to never do
#gd# any preprocessor processing, and have getline do it when the line is gotten
#gd# for real.
sub peek_line
{
  my ($arg) = @_;
  check_args(1, "peek_line", caller, @_);
  if (!defined($arg))
    { $arg = 1; }

  #gd# if (@getline_ungotlines != @getline_ungotdependenton)
  #gd#   { die "different lengths for ungot{lines,dependenton} " . scalar(@getline_ungotlines) . " @getline_ungotlines ||| " . scalar(@getline_ungotdependenton) . " @getline_ungotdependenton"; }

  if ($arg <= @getline_ungotlines)
    { # We have previously peeked at the line in question
      my $index = @getline_ungotlines-$arg;
      #gd#       return($getline_ungotlines[$index], $getline_ungotdependenton[$index]);
      return($getline_ungotlines[$index]); }
  else
    { if ($arg < (@getline_ungotlines + 1))
	{ # Recursively fill up the arrays
	  # Actually, this should never happen:  why  would one look two
	  # lines ahead before checking the next line?
	  die "Why look far ahead when you haven't looked near?  $arg " . scalar(@getline_ungotlines);
	  peek_line($arg-1); }
      if ($arg != (@getline_ungotlines + 1))
	{ die "This can't happen"; }

      # Do the real work.
      #gd# local @dependenton = @dependenton; # tricky!
      #gd# if (@getline_ungotdependenton == 0)
      #gd#   { @dependenton = $getline_ungotdependenton[$#getline_ungotdependenton]; }
      my $nextline;
      { local $getline_nocpp = $true;
	# print "peeking about to call getline\n";
	$nextline = getline("don't pop"); }
      # print "peeking found $nextline";
      #gd# $getline_ungotdependenton[$#getline_ungotdependenton+1] = @dependenton;
      push (@getline_ungotlines, $nextline);
      #gd# return($nextline, @dependenton);
      # print "peek_line($arg) returning $nextline";
      return($nextline); }
}


# Takes a simplified line as its argument; returns a string containing the
# unbalanced braces (empty string if all braces are balanced).
sub brace_change
{ my ($line) = @_;
  check_args(1, "brace_change", caller, @_);
  # print "brace_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\{\}]/)
    { $result_chars .= $&;
      if ($& eq "\{")
	{ $result_num++; }
      elsif ($& eq "\}")
	{ $result_num--; }
      else
	{ die "What match? $&"; }
      $line = $'; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Takes a simplified line as its argument; returns a string containing the
# unbalanced parens (empty string if all parens are balanced).
# Perhaps this should also check for braces (and complain or err if any are
# found before parens balance).
sub paren_change
{ my ($line) = @_;
  check_args(1, "paren_change", caller, @_);
  # print "paren_change $line";
  my $result_num = 0;
  my $result_chars = "";
  while ($line =~ /[\(\)]/)
    { $result_chars .= $&;
      if ($& eq "\(")
	{ $result_num++; }
      elsif ($& eq "\)")
	{ $result_num--; }
      else
	{ die "What match? $&"; }
      $line = $'; }
  return ($result_num == 0) ? $false : $result_chars;
}

# Return index of first close paren which doesn't match a preceding open
# paren in the argument string, and the argument string.  Ignores strings, braces, etc.
# Optional second argument says where to start (right after the open, usually).
# Optional third argument says whether to read lines to try to balance (in which
# case the second return value can differ from the first).
sub find_close_paren
{ my ($exp, $pos, $read) = @_;
  check_args(3, "find_close_paren", caller, @_);
  if (!defined($pos))
    { $pos = 0; }
  if (!defined($read))
    { $read = $false; }
  check_args_range(1, 3, "find_close_paren", caller, @_);
  # print "paren_change $line";
  my $opens = 1;
  my $brace_pos;			# undefined if no brace found
  { my $open_pos = index($exp, "\{", $pos);
    my $close_pos = index($exp, "\}", $pos);
    $brace_pos = ($open_pos == -1) ? $close_pos : ($close_pos == -1) ? $open_pos : min($open_pos, $close_pos);
    if ($brace_pos == -1)
      { undef($brace_pos); } }

  while ($opens > 0)
    { my $next_open = index($exp, "\(", $pos);
      my $next_close = index($exp, "\)", $pos);
      if (($next_open == -1) && ($next_close == -1))
	{ die "no closing paren can be found in $exp"; }
      elsif (($next_open == -1) || ($next_close < $next_open))
	{ if (defined($brace_pos) && ($next_close > $brace_pos))
	    { die "Found brace before matching paren in $exp"; }
	  $opens--;
	  $pos = $next_close+1; }
      elsif (($next_close == -1) || ($next_open < $next_close))
	{ if (defined($brace_pos) && ($next_open > $brace_pos))
	    { die "Found brace before matching paren in $exp"; }
	  $opens++;
	  $pos = $next_open+1; }
      else
	{ if (!$read)
	    { die "find_close_paren: no matcing paren"; }
	  if (defined($brace_pos))
	    { die "Found brace before matching paren in $exp"; }
	  my $nextline = getline();
	  print "*** read in find_close_paren: $nextline";
	  if ($nextline =~ /[\{\}]/)
	    { if (!defined($brace_pos))
		{ $brace_pos = length($exp); }
	      $brace_pos += length($`);
	      if (!(substr($exp . $nextline, $brace_pos, 1) =~ /[\{\}]/))
		{ die "I just found a brace at position $brace_pos of $exp$nextline"; } }
	  $exp .= $nextline; } }
  return ($pos - 1, $exp);
}


# updateinvars exists for the purposes of getline, but may be called by others,
#	particularly to remove comments or simplify string/character literals.
# Obeys global variables $getline_nocomment and $getline_simplify; see their
#	documentation at getline.
# Result differs from input only if one of them is set.
# All backslash line continuations have already been processed.
sub updateinvars
{
  my ($remaining) = @_;
  check_args(1, "updateinvars", caller, @_);
  my $result;
  my $computeresult = ($getline_nocomment || $getline_simplify);
  if ($computeresult)
    { $result = ""; }
  else
    { $result = $remaining; }

  # print "updateinvars ($computeresult) $remaining"; # $remaining ends w/newline
  while ($remaining)
    { if ($incomment)
	{ if ($remaining =~ /\*\//)
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $` . $&; }
	      $remaining = $';
	      $incomment = 0; }
	  else
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $remaining; }
	      return $result; } }
      elsif ($instring)
	{ # print "in string, processing $remaining";
	  if ($remaining =~ m/$non_escaped_double_quote_re/o)
	    # Found a non-escaped double quote
	    { # print "non-escaped double quote: $result|$remaining|$`|$&|$'\n";
	      if ($computeresult)
		{ if ($getline_simplify)
		    { $result .= "\""; }
		  else
		    { $result .= $` . $&; } }
	      # print "post-nonescdquote: $result|$remaining\n";
	      $remaining = $';
	      $instring = 0; }
	  else
	    { # print "$currentfile:$.: in string after line $_[0]";
	      if ($computeresult && !$getline_simplify)
		{ $result .= $` . $&; }
	      return $result; } }
      # If not instring, \" suffices instead of the more complicated
      # regexp that checks for leading backslashes.
      elsif ($remaining =~ m/\/[\*\/]|[\'\"]/) #'FIXCOLOR
	{ my $match = $&;
	  my $postmatch = $';
	  if ($computeresult)
	    { $result .= $`; }
	  if ($match eq "\'")
	    { if ($postmatch =~ m/^$char_literal_contents_re\'/o)
		{ if ($computeresult)
		    { if ($getline_simplify)
			{ $result .= "'a'"; }
		      else
			{ $result .= "'" . $&; } }
		  $remaining = $'; }
	      else
                # No newline, since $_[0] has one.
		{ print EVIL "$currentfile:$.: bad character constant $match$postmatch\n    in $_[0]";
		  if ($postmatch =~ /\'/)
		    { if ($computeresult)
			{ if ($getline_simplify)
			    { $result .= "'a'"; }
			  else
			    { $result .= "'" . $&; } }
		      $remaining = $'; }
		  else
		    { $remaining = $postmatch; } } }
	  elsif ($match eq "\"")
	    { if ($computeresult)
		{ $result .= $match; }
	      $remaining = $';
	      $instring = 1; }
	  elsif ($match eq "//")
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      return $result; }
	  elsif ($match eq "/*")
	    { if ($computeresult && !$getline_nocomment)
		{ $result .= $match . $postmatch; }
	      $remaining = $';
	      $incomment = 1; }
	  else
	    { die "$currentfile:$.: updateinvars: what match?  $match in $_[0]\n"; } }
      else
	{ if ($computeresult)
	    { $result .= $remaining; }
	  return $result; }
    }
}

# All backslash line continuations have already been processed; no
# nonterminated strings, comments, or character constants.
# Result does NOT end in newline
sub remove_comments
{
  my ($input) = @_;
  check_args(1, "remove_comments", caller, @_);
  local $getline_nocomment = $true;
  local $getline_simplify = $false;
  my $result = updateinvars($input);
  if ($instring || $incomment)
    { die "Bad string passed to remove_comments: instring $instring incomment $incomment"; }
  return $result;
}


# This isn't needed any longer, because a simplified string has no
# comments, strings, or character literals to confuse a simplistic check.
# (Don't remove it yet, though, just in case we need it later.)
# # Assumes no comments
# sub has_token
# {
#   my ($token, $line) = @_;
#   check_args(1, "has_token", caller, @_);
#   if (!defined($token)) { die "undefined token, line $line\n"; }
#   if (!defined($line)) { die "undefined line, token $token\n"; }
# 
#   # Check for character constants to avoid processing " in one.
# 
#   # If not instring, I think \" suffices instead of the more complicated
#   # regexp that checks for leading backslashes.
#   while (($line =~ m/[\"\']/) #'FIXCOLOR
# 	 # should regexp-quote $token
# 	 || ($line =~ m/\Q$token\E/))
#     { my $match = $&;
#       $line = $';
#       print "has_token($token) matched $match before $line\n";
#       if ($match eq $token)
# 	{ return $true; }
#       elsif ($match eq "\"")
# 	{ if ($line =~ /$non_escaped_double_quote_re/o)
# 	    { $line = $'; }
# 	  else
# 	    { die "Didn't find end of string literal $line.\n"; } }
#       elsif ($match eq "'")
# 	{ if ($line =~ /^$char_literal_contents_re\'/o)
# 	    { $line = $'; }
# 	  else
# 	    { die "Didn't find end of character literal $line.\n"; } }
#       else
# 	{ die "What match $match in $line\n"; } }
#   return $false;
# }


# Returns the line that should be the getline result, usually "\n";
sub getline_handle_preprocessor_line
{
  my ($line) = @_;
  check_args(1, "getline_handle_preprocessor_line", caller, @_);
  if ($line =~ /^\#\s*$/)
    { # null preprocessor command; do nothing
      return "\n";
    }
  # Maybe also check for (0 === 1), or macro that
  # always expands to 0; but that is probably overkill.
  elsif ($line =~ /^\#\s*ifdef\s+(0|\(0\))\s*$/)
    { discard_to_endif();
      return "\n"; }
  elsif ($line =~ m/^\#\s*($identifier_re)\s*/o)
    { # Found a real preprocessor command
      my $cpp_cmd = $1;
      $line = $';
      $line =~ s/\s+$//;	# remove trailing whitespace
      return getline_handle_preprocessor_command($cpp_cmd, $line); }
  else
    { die "Strange preprocessor line $line"; }
}

# This is a catchall for everything that has to be done to a preprocessor line.
# It's a bit gross to do it this way, but it seems most expedient.
# Always do:
#  * set @dependenton
# Sometimes do:
#  * if $finding_macro_defs, then in first pass, so
#      * for each use of the preprocessor, set $cppcmdcount
#      * for each #define, call process_macro_definition
#  * if $getting_macro_call_types, then in second pass, so
#      * at present, do no extra work
#  * if $merge_cpp_ if_branches, then try to merge #if ... #else ... #endif
#
# Control the action via the following variables: ...
sub getline_handle_preprocessor_command
{
  # $cpp_cmd and $cpp_cmd_arg contain no leading or trailing space.
  my ($cpp_cmd, $cpp_cmd_arg) = @_;
  check_args(2, "getline_handle_preprocessor_command", caller, @_);

  if ($finding_macro_defs)
    { # Perhaps keep a list of each use, with line numbers (could help when
      # determining if it is a preventMI).
      if (!defined($cppcmdcount{$cpp_cmd}))
	{ $cppcmdcount{$cpp_cmd} = 0; }
      $cppcmdcount{$cpp_cmd}++;
      $cpp_cmds++;
    }

  if ($cpp_cmd eq "if")
    { push(@dependenton, $cpp_cmd_arg);
      # print "if $. $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifdef")
    { push(@dependenton, "defined($cpp_cmd_arg)");
      # print "ifdef $. $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "ifndef")
    { push(@dependenton, "!defined($cpp_cmd_arg)");
      # print "ifndef $. $cpp_cmd_arg; now dependent on @dependenton\n";
      if ($merge_cpp_if_branches)
	{ my $merged = cpp_merged_branches();
	  if (defined($merged))
	    { return $merged; } }
    }
  elsif ($cpp_cmd eq "endif")
    { if (@dependenton == 0)
	{ die "improperly nested \#endif"; }
      # print "endif $. $dependenton[$#dependenton]; ";
      pop(@dependenton);
      # print "now dependent on @dependenton.\n";
    }
  elsif ($cpp_cmd eq "else")
    { if (@dependenton == 0)
	{ die "improperly nested \#else"; }
      my $last = pop(@dependenton);
      push(@dependenton, "!($last)"); }
  elsif ($cpp_cmd eq "elif")
    { if (@dependenton == 0)
	{ die "improperly nested \#elif"; }
      my $last = pop(@dependenton);
      push(@dependenton, "(!($last)) && ($cpp_cmd_arg)"); }
  elsif ($cpp_cmd eq "define")
    { if ($finding_macro_defs)
	{ process_macro_definition($cpp_cmd_arg); }
    }
  elsif ($cpp_cmd eq "include")
    { # handle #include
    }
  elsif ($cpp_cmd eq "undef")
    { # handle #undef
    }
  else
    { # Some other cpp command
      print "unhandled cpp command \#$cpp_cmd $cpp_cmd_arg\n";
    }
  return "\n";
}


# Read and discard lines until we find the matching #endif
# No return value.
sub discard_to_endif
{
  check_args(0, "discard_to_endif", caller, @_);
  my $if0depth = 1;
  my $line;
  while ($if0depth > 0)
    { if (not ($line = <INPUT>))
	{ die "File ends in \#ifdef 0"; }
      $lines++;
      # I'll trust that no comment or string contains anything that
      # looks like a preprocessor command.  Strictly speaking, I should
      # use getline and/or updateinvars, because anything in an #ifdef
      # is supposed to be a sequence of valid tokens, but #ifdef 0 often
      # contains non-syntactic constructs.  (Maybe eventually use
      # getline/updateinvars but permit and ignore errors.)
      # This duplicates part of find_preprocessor_commands.  Oh, well.
      if ($line =~ m/^\#\s*if(n?def)\b/o)
	{ $if0depth++; }
      elsif ($line =~ m/^\#\s*endif\b/o)
	{ $if0depth--; } }
}

# This handles
#     #if...
#     #elsif ...
#     #else
#     #if...
#     #endif
#     #endif
# and returns, instead, a single merged string when possible.
# It does not handle other types of nesting, such as
#     #if...
#     #if...
#     #else
#     #endif
#     #if
#     #else
#     #endif
#     #endif
# should it be able to do the latter?

# Returns a merged string.
# Returns the undefined value if
#  * cpp commands are too far separated
#  * series of cpp commands not one of those handled
#  * parts are different, not brace-unbalanced, or differently brace-unbalanced

sub cpp_merged_branches
{
  check_args(0, "cpp_then_part", caller, @_);
  # print "cpp_merged_branches\n";

  my $failure_value;		# undefined

  my @parts = ();

  my $prev_sizes = 0;		# sum of all previous sizes

  { my $size_limit = 10;
    my $num_endifs = 0;		# number of extra #endif commands
    my $next_line;

THENPART:
    { my $this_result = "";
      my $this_size = 0;
      $next_line = peek_line($prev_sizes+1);
      while (!($next_line =~ /^\#\s*els(e|if)\b/))
	{ if (($this_size > $size_limit) || ($next_line =~ /^\#/))
	    { return $failure_value; }
	  $this_result .= $next_line;
	  $this_size++;
	  $next_line = peek_line($prev_sizes+$this_size+1); }
      push(@parts, $this_result);
      $prev_sizes += $this_size + 1;
    }
    print "cpp_merge_branches: thenpart $parts[$#parts]\n";

    if ($next_line =~ /^\#\s*elsif/)
      { goto THENPART; }

ELSEPART:
    { my $this_result = "";
      my $this_size = 0;
      $next_line = peek_line($prev_sizes+1);
      while (!($next_line =~ /^\#\s*endif\b/))
	{ if (($this_size == 0) && ($next_line =~ /^\#\s*if(n?def)?\b/))
	    # if the first thing is #if, go back to then part
	    { $num_endifs++;
	      goto THENPART; }
	  if (($this_size > $size_limit) || ($next_line =~ /^\#/))
	    { return $failure_value; }
	  $this_result .= $next_line;
	  $this_size++;
	  $next_line = peek_line($prev_sizes+$this_size+1); }
      push(@parts, $this_result);
      $prev_sizes += $this_size + 1;
    }
    print "cpp_merge_branches: elsepart $parts[$#parts]\n";

    while ($num_endifs > 0)
      { $next_line = peek_line(++$prev_sizes);
	if (!($next_line =~ /^\#\s*endif\b/))
	  { return $failure_value; }
	$num_endifs--; }
  }

  # Variable @parts holds the desired values; maybe merge them.

  # Check whether all the parts are the same (modulo whitespace, maybe)
  { my $first_part = $parts[0];
    if ($getline_simplify) { $first_part =~ s/\s+/ /; }
    my $all_same = $true;
    my $index = 1;
    while ($all_same && ($index <= $#parts))
      { my $other_part = $parts[$index];
	if ($getline_simplify) { $other_part =~ s/\s+/ /; }
	$all_same = ($first_part eq $other_part);
	$index++; }
    if ($all_same)
      { for $index (1..$prev_sizes)
	  { print "discarding ", getline(); }
	print "returning one of ", scalar(@parts), " identical parts: $first_part";
	return $first_part; } }

  # Check whether the parts are all equally brace_unbalanced
  { my $firstbrace_change = brace_change($parts[0]);
    if ($firstbrace_change ne "")
      { my $index = 1;
	my $all_same = $true;
        while ($all_same && ($index <= $#parts))
	  { $all_same = ($firstbrace_change eq brace_change($parts[$index]));
	    $index++; }
	if ($all_same)
	  { for $index (1..$prev_sizes)
	      { print "discarding ", getline(); }
	    print "merging ", scalar(@parts), " brace-identical parts: <", join(">|<", @parts), ">\n";
	    return merge_brace_unbalanced_lines($firstbrace_change, @parts); } } }
  return $failure_value;
 }


# All of the lines are identically brace-unbalanced
sub merge_brace_unbalanced_lines
{ my ($braces, @lines) = @_;
  check_args_at_least(3, "merge_brace_unbalanced_lines", caller, @_);

  my $pieces = length($braces)+1;

  my @split_lines = ();
  { my $index;
    for $index (0..$#lines)
      { my @this_pieces = split(/[\{\}]/, $lines[$index]);
	# Does this work?  Don't risk it...
	# $split_lines[$index] = @this_pieces;
	{ my $piece;
	  for $piece (0..$#this_pieces)
	    { $split_lines[$index][$piece] = $this_pieces[$piece]; } }
	if ($pieces != @this_pieces)
	  { die "should have $pieces, not ", scalar(@this_pieces), ", pieces: $lines[$index]"; } } }

  my $result = "";
  { my $piece;
    for $piece (0..$pieces-1)
      { { my $index;
	  for $index (0..$#lines)
	    { if (!defined($split_lines[$index][$piece]))
		{ my $p;
		  for $p (0..$pieces)
		    { my $i;
		      for $i (0..$#lines)
			{ print "$p $i <<$split_lines[$i][$p]>>\n"; } }
		  die "piece $piece, index $index not defined"; }
	      $result .= $split_lines[$index][$piece]; } }
	if ($piece != $pieces)
	  { $result .= substr($braces, $piece, $piece+1); } } }
  $result;
}



sub is_cpp_command
{ my ($line) = @_;
  check_args(1, "is_cpp_command", caller, @_);
  $line =~ /^\#/;
}

# Watch out: this removes the trailing newline.
sub trim_whitespace
{
  my ($result) = @_;
  check_args(1, "trim_whitespace", caller, @_);
  $result =~ s/^\s+//;
  $result =~ s/\s+$//;
  # if ($result =~ /^\s+(.*)$/) { $result = $1; }
  # # (.*)\s+ only gets rid of last space
  # if ($result =~ /^(.*[^\s])\s+$/) { $result = $1; }
  return $result;
}


# This pretties things up but changes contents of line-spanning strings,
# so don't call it if ARG1 ends inside a string.
sub append_lines
{
  my ($arg1, $arg2) = @_;
  check_args(2, "append_lines", caller, @_);
  # "+", not "*", so don't introduce spaces where there were none before
  # Do I need \Z instead of $?  It seems I don't...
  $arg1 =~ s/[ \t\n]+$/ /;
  $arg2 =~ s/^[ \t\n]+/ /;
  $arg1 . $arg2;
}

# Return an array of three elements: name, args, def.
# None have leading or trailing whitespace
sub macroparse
{ my ($line) = @_;
  check_args(1, "macroparse", caller, @_);
  # print "macroparse $_[0]\n";
  # Match zero or more, not one or more, spaces before definition.
  # (Perhaps warn if zero are matched.)
  my @result = ($line =~ m/^(\w+)(\([^\)]*\))?\s*(.*)\s*$/);
  if ($#result != 2)		# ($# == 2) => 3 elements
    { die "Problem parsing macro `$line'\n"; }
  @result;
}


# Recursive descent?  Something simpler?
#   exp = (exp) | num | var | exp op exp     -- no functions
# To tokenize, just split at word beginning and end and at number beginning
# 	and end (which may be a bit tricky to tease apart from operator, with
#	leading +/-, but standard says literals have no leading sign -- it's
#       a unary operator).


# Arguments: string
# Returns: type (or 0 if unsuccessful parse)
#          remaining string?
# Side-effects: %parsevars, %parsefuns, %parsetypes which are lists of all
# the variables, functions, types encountered during the parse
my %parsevars = ();
my %parsefuns = ();
my %parsetypes = ();

# Should check @parsexxxs for reserved words; if we find any, I misparsed.

sub parse_expression
{
  my ($exp) = @_;
  check_args(1, "parse_expression", caller, @_);
  # Could use undef instead...
  %parsevars = ();
  %parsefuns = ();
  %parsetypes = ();
  # print "parse_expression $exp\n";
  my ($type, $remaining) = parse_exp(remove_comments($exp));
  # print "parse_expression $remaining\n";
  if ($remaining =~ /^\s*$/)
    { return $type; }
  else
    { return $typeFAIL; }
}


sub parse_exp_nocommaop
{
  my ($exp, $ignoretypes) = @_;
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  check_args_range(1, 2, "parse_exp_nocommaop", caller, @_);
  local $commaop = $false;
  return parse_exp($exp, $ignoretypes);
}

sub parse_exp_commaop
{
  my ($exp, $ignoretypes) = @_;
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  check_args_range(1, 2, "parse_exp_commaop", caller, @_);
  local $commaop = $true;
  return parse_exp($exp, $ignoretypes);
}


# Takes a
# Like parse_expression, but doesn't reset @parsexxxs.
# Returns two values:  the expression's type and the remaining string.
# Every call should be followed by   "if (!$type) { return($typeFAIL,$exp); }"
# See H&S p. 181.
sub parse_exp
{
  my ($exp, $ignoretypes) = @_;
  if (!defined($ignoretypes))
    { $ignoretypes = $false; }
  check_args_range(1, 2, "parse_exp", caller, @_);
  # If ignoretypes is set, then we don't try to infer types, look up types
  # of unknown functions, or set symbol tables.  We do still compute types
  # for literals and return a type, I think.

  # Perhaps remember length of @parsexxxs, so we can restore them if failure.
  # But right now we never fail unless everything fails, so never mind...

  # First, cope with open parens

  # Cast
  if ($exp =~ /^\s*\(\s*($builtin_type_re)\s*\)/)
    { # print "Found cast $1\n";
      my ($casttype) = $1;
      my ($type, $remaining) = parse_exp($');
      if (!$type) { return($typeFAIL,$exp); }
      my $casttypenum = type_to_num($casttype);
      if (!is_number($casttypenum))
	{ $parsetypes{$casttypenum} = $true; }
      return parse_exp_follower($casttypenum, $remaining); }
  # Type in parens followed by (what looks like) paren, number, or identifier
  if ($exp =~ /^\s*\(\s*($type_re)\s*\)\s*([0-9a-z\(])/)
    { my ($casttype) = $1;
      $parsetypes{$casttype} = $true;
      # print "Found cast $1 $2\n";
      my ($type, $remaining) = parse_exp($2 . $');
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($casttype,$remaining); }

  # Parens as grouping
  if ($exp =~ m/^\s*\(/)
    { my ($type, $remaining) = parse_exp_commaop($');
      if (!$type) { return($typeFAIL,$exp); }
      if ($remaining =~ m/^\s*\)/)
	{ return parse_exp_follower($type, $'); }
      else
	{ return($typeFAIL,$exp); } }

  # Unary prefix operators
  if ($exp =~ /^\s*(\+\+|--|[-~!+&*])/)
    { my ($type, $remaining) = parse_exp($');
      if (!$type) { return($typeFAIL,$exp); }
      return parse_exp_follower($type,$remaining); }
  # [^\)] was [ \ta-zA-Z0-9*]
  if ($exp =~ /^\s*sizeof\s*\(\s*([^\)]+)\)/)
    { my $sizeoftype = $1;
      $sizeoftype =~ s/\s+$//;
      my $remaining = $';
      if (!($sizeoftype =~ /^$type_re$/o))
	{ die "sizeof($sizeoftype) doesn't look like a type"; }
      return parse_exp_follower(type_to_num($sizeoftype),$remaining); }

  # Literals
  $exp =~ s/^\s+//;		# remove leading space

  # Literal string
  if ($exp =~ /^$string_literal_re/)
    # String contains no non-escaped double-quote
    # Should look for a following string, to concatenate the two.
    # Perhaps special-case:  look for symbol (which is macro with typeSTRING)
    # or literal string.
    { return ($typeSTRING, $'); }

  # Literal character
  if ($exp =~ /^$char_literal_re/o)
    { return parse_exp_follower($typeCHAR, $'); }

  # Literal floating-point
  # This precedes integer because an integer matches the first part of a float
  if (($exp =~ /^$float_literal_whole_re/o)
      || ($exp =~ /^$float_literal_frac_re/o))
    { my ($type) = $typeDOUBLE;
      if (($2 eq "f") || ($2 eq "F"))
	{ $type = $typeFLOAT; }
      elsif (($2 eq "l") || ($2 eq "L"))
	{ $type = $typeLDOUBLE; }
      return parse_exp_follower($type,$'); }

  # Literal integer (octal)
  # Don't need leading [-+]? because they are always unary operators, never
  # part of the literal itself.
  if (($exp =~ /^$hex_literal_re/o)  # hex (regexp failed with \d for 0-9)
      # hex precedes octal/decimal because the "0" looks like a leading integer
      || ($exp =~ /^$dec_oct_literal_re/o)) # octal or decimal
    { # print "Found integer $1\n";
      my ($remaining) = $';
      my ($type) = infer_int_type($1);
      # print "inferred type ", type_name($type), "\n";
      if ($2 =~ /[uU]/)
	{ $type = type_unsigned($type); }
      if ($2 =~ /[lL]/)
	{ $type = type_long($type); }
      # print "parse_exp_follower($type,$remaining)\n";
      return parse_exp_follower($type,$remaining); }

  # Variable
  elsif ($exp =~ /^$identifier_re/o)
    { my ($var) = $&;
      my ($remaining) = $';
      categorize_macro_name($var); # huh??
      my $vartype = $mntype{$var};
      if (!defined($vartype))
	# Need to do a MUCH better job here; in particular, infer a type.
	# Perhaps return a negative number, an index into a list of things
	# whose types need to be inferred.
	{ $vartype = $typeUNKNOWN; }
      # Perhaps do something different if the categorization was successful.
      if ($remaining =~ /^\s*\(/)
	{ $parsefuns{$var} = $true;
	  return parse_arglist($vartype, $');
	}
      else
	{ $parsevars{$var} = $true;
	  return parse_exp_follower($vartype, $remaining); }
    }
  else
    { # print "Couldn't match $exp\n";
      return ($typeFAIL, $exp); }
}


# $arglist already has leading paren stripped.
sub parse_arglist
{
  my ($ftype, $arglist) = @_;
  check_args(2, "parse_arglist", caller, @_);

  # Need a notation for function types; maybe just -> in front.
  while (!($arglist =~ /^\s*\)/))
    { my ($thisargtype, $comma) = parse_exp_nocommaop($arglist);
      if (!$thisargtype) { return($typeFAIL, $arglist); }
      # push $thisargtype somewhere
      if ($comma =~ /^\s*,/)
	{ $arglist = $'; }
      elsif ($comma =~ /^\s*\)/)
	{ $arglist = $comma; }
      else
	{ die "Neither comma nor close paren followed well-formed arg $arglist\n";
	  return($typeFAIL, $arglist); } }
  return parse_exp_follower($ftype,$');
}

# $initializer already has leading brace stripped
sub parse_array_initializer
{
  my ($initlist) = @_;
  check_args(1, "parse_array_initializer", caller, @_);

  # print "parse_array_initializer $initlist"; # $initlist ends in newline

  while (!($initlist =~ /^\s*\}/))
    { my ($thisinittype, $comma);
      # print "current initlist = $initlist"; # $initlist ends in newline
      if ($initlist =~ /^\s*\{/)
	{ ($thisinittype, $comma) = parse_array_initializer($');
	  # transform subinittype from array to scalar type
	}
      else
	{ ($thisinittype, $comma) = parse_exp_nocommaop($initlist);
	  # print "parse_exp_nocommaop returned ($thisinittype) $comma\n";
	}
      if (!$thisinittype) { return($typeFAIL, $initlist); }
      # push $thisinittype somewhere
      if ($comma =~ /^\s*,/)
	{ $initlist = $'; }
      elsif ($comma =~ /^\s*\}/)
	{ return ($thisinittype, $'); }
      else
	{ die "Neither comma nor close brace followed well-formed init $initlist\n";
	  return($typeFAIL, $initlist); } }
  # don't call parse_exp_follower
  return ($typeUNKNOWN,$');
}

# Returns a success boolean, the post-closeparen string, and the declarations.
# These might be:
#   * identifiers or type decls (if in definition)
#   * types or type decls (if in declaration)
# so don't try to distinguish; just return them literally.
sub parse_function_decl_args
{
  my ($text) = @_;
  check_args(1, "parse_function_decl_args", caller, @_);
  my @arg_decls = ();

  print "parsing next arg decl in $text\n";
  # used to use parse_exp_nocommaop, but it's not expressions we're parsing...
  while (!($text =~ /^\s*[,\)]/))
    { # I have no way of preferring to parse as a typedecl vs. as
      # a type vs as a bare identifier (don't know if this is function
      # definition or declaration, so perhaps pass that information in.
      # Fix the disambiguation later.
      print "looking for type or type declarator\n";
      if ($text =~ /^\s*($type_declarator_re)\s*[,\)]/)
	{ push(@arg_decls, $1);
	  $text = substr($&, -1) . $';
	  print "new text $text\n";
	}
      elsif ($text =~ /^\s*($type_re)\s*[,\)]/) # also catches just identifier
	{ push(@arg_decls, $1);
	  $text = substr($&, -1) . $';
	  print "new text $text\n";
	}
      else
	{ die "Couldn't parse function arg declaration $text"; }
    }
  # print "match: $`|$&|$'\n";
  if (!defined($'))
    { die "postmatch not defined.\n"; }
  my $postmatch = $';
  if (!defined($postmatch))
    { die "postmatch not defined.\n"; }
  return ($true, $', @arg_decls);
}

# Need this be global?
my %argnametype;

# Side effects global %argnametype;
# Return an associative array of names to types and the remaining string
# after the open brace.
sub parse_KandR_function_arg_decls
{
  my ($argdecls) = @_;
  check_args(1, "parse_KandR_function_arg_decls", caller, @_);
  %argnametype = ();
  while (!($argdecls =~ /^\s*\{/))
    { # print "parsing K&R function arg decls $argdecls\n";
      if (!($argdecls =~ /^\s*$type_declarator_re\s*([,;])/))
	{ die "Couldn't parse K&R-style type declarator $argdecls\n"; }
      my $typespec = $1;
      my $declarator = $2;
      my $nextchar = substr($&, length($&)-1);
      $argdecls = $';
      my ($type, $identifier) = parse_declarator($typespec, $declarator);
      $argnametype{$identifier} = $type;
      while ($nextchar eq ",")
	{ if (!($argdecls =~ /^\s*$declarator_re\s*([,;])/))
	    { die "Couldn't parse declarator following comma after '$typespec $declarator $nextchar': $argdecls\n"; }
	  $declarator = $1;
	  $nextchar = substr($&, length($&)-1);
	  $argdecls = $';
	  ($type, $identifier) = parse_declarator($typespec, $declarator);
	  $argnametype{$identifier} = $type; } }

  # print "after K&R, remainder $'\n";
  return $';
}


sub parse_exp_follower
{
  my ($type, $follow) = @_;
  check_args(2, "parse_exp_follower", caller, @_);
  $follow =~ s/^\s+//;		# remove leading space

  if (!defined($type)) { die "type undefined $follow\n"; }

  # Should this be eq to avoid failing when $type is a string?
  if ($type eq $typeFAIL)
    # This isn't quite right since the failure occurred earlier.
    # Perhaps die in this case instead.
    { return($type, $follow); }

  # Array subscript
  if ($follow =~ /^\[/)
    { my $subscript = $';
      my ($subscrtype, $closebracket) = parse_exp($subscript);
      if (!$subscrtype) { return($typeFAIL,$subscript); }
      if (!(type_integral_p($subscrtype) || ($subscrtype == $typeUNKNOWN)))
	# This shouldn't happen; perhaps die instead.
	{ die "Non-integral type ", type_name($subscrtype), " in subscript\n";
	  return ($typeFAIL, $follow); }
      if ($closebracket =~ /\s*\]/)
	{ my ($remaining) = $';
	  return parse_exp_follower(type_dereference($type), $remaining); }
      else
	{ return ($typeFAIL, $follow); } }

  # Function call (might this be some other use of parens??)
  if ($follow =~ /^\(/)
    { return parse_arglist($type, $'); }

  # Unary postfix operators
  if ($follow =~ /^(\+\+|--)/)
    { return parse_exp_follower($type, $'); }
  # Structure selectors
  if ($follow =~ /^\s*(\.|->)\w+\b/)
    { return parse_exp_follower($typeUNKNOWN, $'); }

  # Binary operators:  multi-char operators must precede single-char ones
  if (($follow =~ /^(<<|>>|[<=>!]=|&&|\|\||[-*\/%+&^|<>])/)
      || ($commaop && ($follow =~ /^(,)/)))
    { my $op = $1;
      my $arg2 = $';
      if ($op eq ",")
	{ # print "found a comma operator, commaop = $commaop\n";
	}
      my ($type2, $remaining) = parse_exp($arg2);
      if (!$type2) { return ($typeFAIL, $arg2); }
      if (bool_op_p($op))
	{ return parse_exp_follower($typeBOOL, $remaining); }
      elsif ($op eq ",")
	{ return parse_exp_follower($type2, $remaining); }
      else
	{ return parse_exp_follower(type_lub($type, $type2), $remaining); } }

  # Ternary operator ?:
  if ($follow =~ /^\?/)
    { my $then = $';
      my ($thentype, $colon) = parse_exp($then);
      if (!$thentype) { return ($typeFAIL, $then); }
      if (!($colon =~ /^\s*:/)) { return ($typeFAIL, $colon); }
      my ($elsetype, $remaining) = parse_exp($');
      if (!$elsetype) { return ($typeFAIL, $colon); }
      return (type_lub($thentype, $elsetype), $remaining); }

  return ($type, $follow);
}

sub bool_op_p
{
  my ($op) = @_;
  check_args(1, "bool_op_p", caller, @_);
  return ($op =~ /[<=>!]=|&&|\|\||<|>/);
}


### Get types for macro calls

# This is a bit disappointing because it's so heuristic; my inclination is
# really to get it right rather than approximate.

# Find all uses of a macro, to determine types of its arguments.
# (If it isn't used, it can be eliminated -- this will be true of many in
# standard header files, perhaps.)
# Do a rough parse of each file:
#  recognize binding forms:
#     variable declarations, function definitions, function declarations
#     Can use etags to find function defintiions, but it doesn't find
#	global variables.
#  recognize function calls, check whether they are macros
# Cope with macro definitions like "#define local static" and with
#    typedefs like "typedef unsigned long  ulg;" (the latter not to use
#    the raw type, but to permit type_lub to do a better job, maybe).

sub get_macro_call_types
{
  check_args(0, "get_macro_call_types", caller, @_);
  local $getting_macro_call_types = $true;
  local $getline_nocomment = $true;
  local $getline_simplify = $true;
  local $merge_cpp_if_branches = $true;
  # Perhaps should use %files instead of @ARGV
  # print "ARGV @ARGV";
  my $file;
  foreach $file (@ARGV)
    { $currentfile = $file;	# $file is localized to foreach loop
      if ($opt_v)
	{ print STDERR "file $currentfile\n"; }
      # open(INPUT,$currentfile) or next; # skip to next file if open fails
      open(INPUT,$currentfile) or next; # skip to next file if open fails
      # Commented out to quiet compiler
      # $files{$currentfile} = 1;
      if (@dependenton > 0)
	{ die "In \#if at beginning of file: @dependenton"; }
      # Perhaps I should use a variant of getline that insists that parens
      # are balanced, too; that might let me more reasonably cope with
      # breaks across lines.
      if ($symtab_scopes != 0)
	{ die "Bad brace depth $symtab_scopes.\n"; }
      my $in_extern_C = $false;
      my $line;
      while ($line = getline())
	{
	  # The line number $. isn't quite right, as we may have peeked ahead
	  # print "line $.: $line"; # no newline, since $line contains one
	  if ($line =~ /^\s*$/)
	    { # empty line; possibly was originally a preprocessor command
	    }
	  elsif ($line =~ m/^\#/o)
	    { die "getline shouldn't return preprocessor lines: $line"; }
	  else
	    {			# not empty or a preprocessor line
	      # print "not empty or a preprocessor line $line"; # $line has newline
	      chop($line);	# remove trailing newline
	      # In a scope, must be indented or: close brace, comment, label
	      if (($symtab_scopes != 0)
		  && (!(($line =~ m/^(\s|\/[\/\*]|$identifier_re\s*:)/o)
			|| (($symtab_scopes == 1)
			    && (($line =~ m/^\}/)
				|| ($line =~ m/^(\"|0\};)/))))))
		{ die "Non-indented line $line at bracedepth $symtab_scopes"; }

	      # Check for improper indentation later, complaining only
	      # about lines containing definitions/declarations.  (Maybe
	      # should do more checking?)

	      # Look for:  typedef,
	      #   function definition/declaration (only at symtab_scopes == 0)
	      #   variable definition/declaration,
	      #   function call (of a macro),
	      #   brackets (to keep track of scopes),
	      #   string/char literals (to avoid catching too much).
	      # These can span multiple lines, especially function definitions.

PROCESSLINE:
	      if (!defined($line))
		{ die "PROCESSLINE: line undefined.\n"; }
	      print "PROCESSLINE $line\n";
	      $line = simple_macro_substitute($line);
	      if ($line =~ /^\s*$/)
		{		# do nothing; maybe this was a preprocessor directive
		  # print "empty line $.\n";
		}
	      elsif ($line =~ /^\s*typedef\s+/)
		{		# process typedefs
		  print "typedef line $.\n";
		}
	      elsif (($line =~ /^$type_specifier_re\s*$/o)
		     # this call to peek_line ignores the @dependenton argument
		     && (peek_line(1) =~ /^$declarator_re\s*\(/o))
		{ # Function definition split over multiple lines
		  $line .= " " . getline();
		  goto PROCESSLINE; }
	      elsif ($line =~ /^\s*$type_declarator_re\s*([,=;\(])/o)
		{
		  # Looks like a type declarator, but might not really be one.
		  print "matched type declarator <$1><$2>\n";
		  # print "maybe matched typedeclarator <$1><$2><$3><$4><$5><$6><$7><$8><$9> <<", defined($macros{$6}[0]), (defined($macros{$6}[0]) ? (">><<$macros{$6}[0] $macros{$6}[1] |$mname[$macros{$6}[1]]|$margs[$macros{$6}[1]]|$mbody[$macros{$6}[1]]|$mfile[$macros{$6}[1]]|$mline[$macros{$6}[1]]|") : ""), ">>\n";

		  my $typespec = $1;
		  my $declarator = $2;
		  my $nextchar = substr($&, length($&)-1);
		  my $remaining = $';

		  # Fallthroughs below depend on the fact that this is the last
		  # clause in the elsif chain: there's nothing else we would
		  # try to do here if we didn't have a type declarator.
		  if (($typespec eq "return") # "return foo;"
		      || ($typespec eq "else") # "else if (...)"
		      )
		    { # fall through
		      print "rejected typespec $typespec\n";
		    }
		  elsif (($nextchar eq "(")
			 && ($declarator =~ /^$identifier_re$/o)
			 && defined($macros{$declarator}[0]))
		    { # The function being defined is actually a macro.
		      # Try to expand it, else fall through.
		      my $identifier = $declarator;

		      my $close_paren_pos;
		      # if parens aren't balanced, read enough text to balance them.
		      ($close_paren_pos, $remaining) = find_close_paren($remaining, 0, $true);

# 		      # First,
# 		      print "Make sure parens are balanced $remaining\n";
# 
# 		      if ($remaining =~ /[\{\}]/)
# 			{ if (paren_change($nextchar . $`))
# 			    { die "unbalanced parenthesis before brace $nextchar$remaining"; } }
# 		      else
# 			{ # Temporarily prepend $nextchar to $remaining
# 			  $remaining = $nextchar . $remaining;
# 			  while (paren_change($remaining))
# 			    { $remaining .= " " . getline();
# 			      if ($remaining =~ /[\{\}]/)
# 				{ if (paren_change($`))
# 				    { die "unbalanced parenthesis before brace $nextchar$remaining"; } } }
# 			  $remaining = substr($remaining, 1); }

		      # Case 1:
		      # There is only one expansion for the macro.  Expand it.
		      if ($macros{$identifier}[0] == 1)
			{ # ... expand macro ...;
			  # goto PROCESSLINE;
			}

		      # Case 2: macro that takes a single arg and either
		      # returns it or returns nothing, which can be used to
		      # construct either a K&R or ANSI function declaration
		      # by passing in a parenthesized list as the argument.
		      if (is_fun_decl_arg_macro($identifier))
			{
			  die "shouldn't find fun_decl_arg_macro any more";
			  # ... expand macro ...;
			  # For now, hack it.
			  if (!($declarator =~ /^$identifier_re$/))
			    { die "can't have pointer or array declarators"; }
			  print "expanding empty-paren macro from $line";
			  $line = $typespec . " " . $nextchar
			    . substr($remaining, 0, $close_paren_pos-1)
			      . substr($remaining, $close_paren_pos+1);
			  print "expanding empty-paren macro to $line";
			  goto PROCESSLINE;
			}
		      # fall through
		    }
		  else
		    { # This actually is a valid type declarator
		      my ($type, $identifier) = parse_declarator($typespec, $declarator);

		      if (($line =~ /^\s/)
			  && ($symtab_scopes == 0)
			  # accept indented declaration/definition in #if at top scope
			  # (want to reject function defs but not decls; how to do?)
			  && (@dependenton == 0))
			{
			  print "potential indentation problem; nextchar '$nextchar'\n";
			  # Hack for gzip-1.2.4/deflate.c.
			  # If a few improperly indented lines containing no braces
			  # are followed by a property unindented line, don't die.
			  my $proper_follows = $false;
			  { my $follow;
			    for $follow (1..7)
			      { my $next = getline($follow);
				if ($next =~ /^[^\s]/)
				  { $proper_follows = $true;
				    last; }
				if ($next =~ /[\{\}]/)
				  { last; } } }
			  if (!$proper_follows)
			    { die "Indented line $. at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line"; }
			  print "Overlooked indented line $. at top level ($symtab_scopes scopes, dependenton (@dependenton), nextchar '$nextchar'):\n $line"; }
		      # print "found typespec '$typespec' declarator '$declarator' nextchar '$nextchar' remaining '$remaining' on line $.\n";
		      # If no semicolon, then the definition must span lines.
		      if (($nextchar ne ";") && ($nextchar ne "("))
			# Only need to check the new stuff, not the whole thing.
			{ while (!($remaining =~ /;/))
			    {	# print "no semicolon, so appending a line to $remaining\n";
			      $remaining = append_lines($remaining, getline()); } }
		      # print "found semicolon (or nextchar is open paren) in $remaining\n";

		      if ($nextchar eq "(")
			{	# found (start of) function definition or prototype
			  if ($symtab_scopes != 0)
			    { die "Function definition or prototype $& at bracedepth $symtab_scopes.\n"; }
			  # Only need to check the new stuff, not the whole thing.
			  while (!($remaining =~ /\)/))
			    { print "no close paren, so appending a line to $remaining\n";
			      $remaining = append_lines($remaining, getline()); }
			  if (!($remaining =~ /\)/))
			    { die "There must be a close paren.\n"; }
			  # print "found function $identifier; remaining $remaining\n";
			  # process the args:  create the scope, eat the following
			  # open brace, etc.  $remaining includes everything after
			  # the original open paren.
			  # Three possibilities:
			  #   function declaration (K&R or ANSI)
			  #   K&R-style function definition
			  #   ANSI-style function definition
			  # odd; "my ($success, $remaining) = ..." doesn't work.
			  my $success;
			  my @arg_decls;
			  my @arg_names; # These two will be set from arg_decls when
			  my @arg_types; #   we know whether this was a def or decl.
			  ($success, $remaining, @arg_decls) = parse_function_decl_args($remaining);
			  if (!defined($remaining))
			    { die "remaining not defined after parse_function_decl_args => @arg_decls"; }
			  if (!$success)
			    { $line = $remaining;
			      goto PROCESSLINE; }
			  # $remaining is what follows the close paren
			  while ($remaining =~ /^\s*$/)
			    {	# print "no semi or brace, so appending a line to $remaining\n";
			      my $nextline = getline();
			      $remaining = append_lines($remaining, $nextline); }
			  # $remaining is nonempty; if first character is
			  # semicolon, then this is a declaration, else a definition
			  if ($remaining =~ /^\s*;/)
			    {	# declaration
			      # enter this in the global symbol table, perhaps
			      # (to be done)
			      $remaining = $';
			      ***** set arg_names and arg_types from arg_decls by parsing them as types or typedecls.
			    }
			  else
			    {	# function definition
			      print "found function definition $identifier; remaining $remaining\n";
			      ***** set arg_names and arg_types from arg_decls by parsing them as identifiers or typedecls.
			      if ($remaining =~ /^\s*\{/)
				{ # ANSI-style definition
				  $remaining = $';
				}
			      else
				{ # K&R-style definition
				  if (!($remaining =~ /^\s*$type_declarator_re\s*([,;])/))
				    { die "Didn't find first type+declarator in K&R-style $remaining\n"; }
				  { my $argtype;
				    for $argtype (@argtypes)
				      { if ($argtype != $typeUNSPECIFIED)
					  { die "K&R-style definition, but a type is specified as " . type_name($argtype) . ".\n"; } } }
				  # Only need to check the new stuff, not the whole thing.

				  while (!($remaining =~ /\{/))
				    { # print "no brace, so appending a line to $remaining\n";
				      $remaining = append_lines($remaining, getline()); }
				  $remaining = parse_KandR_function_arg_decls($remaining);
				  # Make sure that the argument list matches the declarators
				  { { my $index;
				      foreach $index (0..$#argnames)
					{ # print "argname: ", @argname, "\nargtype: ", @argtype, "\n";
					  my $thistype = $argnametype{$argnames[$index]};
					  if (!defined($thistype))
					    { die "No K&R-style declarator for $argnames[$index]\n"; }
					  $argtypes[$index] = $thistype;
					  delete $argnametype{$argnames[$index]};
					} }
				    # argnametype should be empty now
				    { my $name;
				      for $name (keys %argnametype)
					{ die "K&R-style declarator, but no argument, for $name $argnametype{$name}\n"; } }
				  }
				}
			      print "Done parsing function definition to open brace\n";

			      # function definition: $remaining is everything after
			      # the open brace, and @argnames and @argtypes are set.
			      # Two things to do:
			      #  1. add function's type to the global symbol table
			      #  2. enter a scope

			      # 1. add function's type to the global symbol table
			      # (to be done).  Actually, this should be easy since
			      # we are at global scope now.  Perhaps have separate
			      # tables for guesses and for what we know for sure.
			      # We'll have declarations for everything but macros.
			      # Watch out that it isn't already in the global
			      # symbol table (make sure it is compatible if so).

			      # 2. enter a scope
			      enter_scope();
			      { my $index;
				for $index (0..$#argnames)
				  { symtab_add($argnames[$index], $argtypes[$index]); } }

			      # Done with function definition
			    }

			  # We just coped with a function definition or declaration.
			  # Process the rest of the line (if def, this is anything
			  # after the open brace).
			  $line = $remaining;
			  goto PROCESSLINE;
			}
		      else
			{
PROCESSVARDEF:
			  # variable definition or declaration
			  # print "variable definition or declaration <<$identifier>> $type\n";
			  # $nextchar = "," or "=" or ";"
			  if (!(($nextchar eq ",") || ($nextchar eq "=") || ($nextchar eq ";")))
			    { die "what nextchar? '$nextchar'"; }

			  # This should logically happen here, but hold off
			  # in case there is trouble.
			  # symtab_add($identifier, $type);
			  if ($nextchar eq ";")
			    { symtab_add($identifier, $type);
			      $line = $remaining;
			      goto PROCESSLINE; }
			  elsif ($nextchar eq ",")
			    {
ATCOMMA:
			      if ($remaining =~ /^\s*$declarator_re\s*([,=;])/o)
				{ # First, add the previous thing.
				  symtab_add($identifier, $type);
				  # Now cope with this one.
				  $declarator = $1;
				  $nextchar = substr($&, length($&)-1);
				  $remaining = $';
				  ($type, $identifier) = parse_declarator($typespec, $declarator);
				  goto PROCESSVARDEF; }
			      elsif ($remaining =~ /^\s*$type_declarator_re\s*([,\)])/o)
				{ # We're in the middle of a function declarator
				  # Skip to next brace or semicolon

				  # It looks like we ignore the type
				  # declarator we just found.  And, we don't do
				  # symtab_add($identifier, $type);
				  # which was deferred from above.  What's up?
				  $remaining = $';
				  if ($remaining =~ /[\{;]/)
				    { if ($& eq ";")
					{ $remaining = $'; }
				      else
					{ $remaining = $& . $'; } }
				  elsif ($remaining =~ /\)/)
				    { $remaining = $'; }
				  else
				    { die "No semicolon or brace after function declarator?  It can't be!\n"; }
				  $line = $remaining;
				  goto PROCESSLINE; }
			      else
				{ die "Found '$typespec $declarator' ($nextchar) on line $. but no following var in $remaining\n"; } }
			  elsif ($nextchar eq "=")
			    {	# Skip over an expression and continue processing from there.
			      # print "skipping expression $remaining\n";
			      my $postexp = skip_expression_nocommaop($remaining);
			      if ($postexp eq "")
				{ # do nothing; done with this line, because
				  # parsing of the expression failed
				  die "Failed to parse initializer $remaining\n"; }
			      elsif ($postexp =~ /\s*;/)
				{ $line = $';
				  goto PROCESSLINE; }
			      elsif ($postexp =~ /\s*,/)
				{ $remaining = $';
				  goto ATCOMMA; }
			      else
				{ die "After skipping well-formed initializer, didn't find comma or semicolon.\n"; } }
			  else
			    { die "Bad nextchar $nextchar.\n"; } }
		    } }
	      # Line didn't match $type_declarator_re
	      # Parse it looking for:
	      #  * open and close braces to keep track of scopes
	      #  * strings and chars so we can skip over them
	      #    (or maybe simplify_line will do away with them).
	      #  * open parens, because maybe they indicate a function call
	      #  * semicolon: try again
	      if ($line =~ "^extern \"\" {")
		{ if ($symtab_scopes != 0)
		    { die "extern \"C\" not at top level"; }
		  if ($in_extern_C)
		    { die "extern \"C\" inside extern \"C\""; }
		  $line = $';
		  $in_extern_C = $true;
		}
	      while ($line =~ m/[\({}\"\';]/) #'FIXCOLOR
		# Found brace, open paren, quote, comment, or semicolon
		{		# print "Found brace, open paren, quote, comment, or semicolon: $&$'\n";
		  my $match = $&;
		  $line = $';
		  if ($match eq "{")
		    { enter_scope();
		      goto PROCESSLINE; }
		  elsif ($match eq "}")
		    { if (($symtab_scopes == 0) && $in_extern_C)
			{ $in_extern_C = $false; }
		      else
			{ exit_scope(); }
		      goto PROCESSLINE; }
		  elsif ($match eq ";")
		    { goto PROCESSLINE; }
		  elsif ($match eq "(")
		    { if ($` =~ /$identifier_re\s*$/o)
			{	# found something that looks like a function call
			  # process it
			}
		      else
			{	# This paren doesn't represent a function call;
			  # look for another brace, open paren, quote, comment
			}
		    }
		  elsif ($match eq "\"")
		    { if ($line =~ /$non_escaped_double_quote_re/o)
			{ $line = $'; }
		      else
			{ die "Didn't find end of string literal $line.\n"; } }
		  elsif ($match eq "'")
		    { if ($line =~ /^$char_literal_contents_re\'/o)
			{ $line = $'; }
		      else
			{ die "Didn't find end of character literal $line.\n"; } }
		  else
		    { die "What match '$match' '$line'?\n"; } }
	    }
	  # done with this line; get another
	}
      # done with this file; read another
      if (@dependenton > 0)
	{ die "Still in \#if at end of file: @dependenton"; }
      # print "closing file $currentfile\n";
      close(INPUT);
    }
}


# This should perhaps do more:  substitute for macros with only one definition,
# or those that expand to either nothing or a keyword like const, etc.
sub simple_macro_substitute
{ my ($text) = @_;
  check_args(1, "simple_macro_substitute", caller, @_);

  my $fdmacro;
  # Using "for" instead of foreach gives me 'Use of "" without parens is ambiguous'!
  foreach $fdmacro (keys %fun_decl_arg_macros)
    { if ($text =~ /\b$fdmacro\s*\(/)	# no /o here, as $macro varies
	{ my $prematch = $`;
	  my $postmatch = $';
	  my $close_paren_pos;
	  ($close_paren_pos, $postmatch) = find_close_paren($postmatch, 0, $true);
	  my $result = $prematch . substr($postmatch, 0, $close_paren_pos)
	    . substr($postmatch, $close_paren_pos+1);
	  print "simple_macro_substitute $text\n ===> $result\n";
	  return $result; } }
  return $text;
}



# Returns two values the remaining string, or the empty string if failure.
# This is actually for skipping initializers.
sub skip_expression_nocommaop
{
  my ($input) = @_;
  check_args(1, "skip_expression_nocommaop", caller, @_);
  my ($type, $remaining);

  # print "skipping expression $input\n";

  if ($input =~ /^\s*\{/)
    { ($type, $remaining) = parse_array_initializer($');
      print "parse_array_initializer returned $type $remaining\n";
    }
  else
    { ($type, $remaining) = parse_exp_nocommaop($input, "ignore types"); }
  if (!$type)
    { return ""; }
  else
    { return $remaining; }
}


### Symbol table

# The symbol table is two parallel arrays:
my @symtab_identifiers = ();
my @symtab_types = ();
# $scopemarker in the @identifiers array indicates a scope boundary
my $scopemarker = "scope marker";	# contains space, as no real variable can

# Perhaps have a different structure (an associative array?) for the global
# level and only use this for nested scopes.


sub show_symtab
{
  my ($text) = @_;
  check_args(1, "show_symtab", caller, @_);
  if ($#symtab_identifiers != $#symtab_types)
    { die "symtab_identifiers and symtab_types arrays have different lengths ($#symtab_identifiers != $#symtab_types)\n"; }
  print "{SYMBOL TABLE $text at line $.:\n";
  # perhaps print out in opposite direction
  my $i;
  for ($i = $#symtab_identifiers; $i >= 0; $i--)
    { if ($symtab_identifiers[$i] eq $scopemarker)
	{ print " --------\n"; }
      else
	{ print " ", $symtab_identifiers[$i], "\t", type_name($symtab_types[$i]), "\n"; }
    }
  print "}\n";
}

sub enter_scope
{
  check_args(0, "enter_scope", caller, @_);
  push(@symtab_identifiers, $scopemarker);
  push(@symtab_types, 0);
  $symtab_scopes++;
  if ($debug_scopes) { show_symtab("entered scope $symtab_scopes"); }
}

sub exit_scope
{
  check_args(0, "exit_scope", caller, @_);
  if ($debug_scopes) { show_symtab("exiting scope $symtab_scopes"); }
  if ($#symtab_identifiers == -1)
    { die "Trying to exit scope at line $., but empty symtab_identifiers array at beginning.\n"; }
  while ($scopemarker ne pop(@symtab_identifiers))
    { pop(@symtab_types);
      if ($#symtab_identifiers == -1)
	{ die "Trying to exit scope at line $., but didn't find scopemarker.\n"; } }
  pop(@symtab_types);
  # It's possible that ($#symtab_identifiers == -1), if global scope is empty.
  if ($debug_scopes) { show_symtab("exited scope $symtab_scopes"); }
  $symtab_scopes--;
}

# sub symtab_scopes
# {
#   check_args(0, "symtab_scopes", caller, @_);
#   my $result = 1;
#   my $id;
#   for $id (@symtab_identifiers)
#     { if ($id eq $scopemarker)
# 	{ $result++; } }
#   return $result;
# }

sub symtab_add
{
  my ($identifier, $type) = @_;
  check_args(2, "symtab_add", caller, @_);
  if (!defined($identifier))
    { die "symtab_add: undefined identifier, type $type"; }
  if (!defined($type))
    { die "symtab_add: undefined type, identifier $identifier"; }
  push (@symtab_identifiers, $identifier);
  push (@symtab_types, $type);
}

sub symtab_lookup
{
  my ($var) = @_;
  check_args(1, "symtab_lookup", caller, @_);
  my $index;
  for ($index = $#symtab_identifiers; $index >= 0; $index--)
    { if ($var eq $symtab_identifiers[$index])
	{ return $symtab_types[$index]; } }
  return $typeFAIL;
}



###########################################################################
### Check and categorize macros
###

# Need a routine that assigns a type to a literal.
# (Useful for turning macros into const variables.)

# # FIsNumConst(string)  returns 1 iff string matches a numeric const regexp
# sub FIsNumConst {
#   my ($str) = @_;
#   check_args(1, "FIsNumConst", caller, @_);
#   if ($str =~ /^\(?-?\d+\.?\d*\)?$/ || # decimal 2.
#       $str =~ /^\(?-?\d*\.?\d+\)?$/ || # fraction .2
#       $str =~ /^0x[\d|a-f|A-F]+$/ ||   # hex
#       $str =~ /^-?\d+[ulUL]$/) {       # trailing L for long, U for unsigned
#     return 1;
#   } else {
#     return 0;
#   }
# }

sub test_categorize_macro
{ my ($body) = @_;
  check_args(1, "test_categorize_macro", caller, @_);
  $mbody[1000] = $body;
  $mname[1000] = "dummy";
  $margs[1000] = "(arg)";
  undef $mcategory[1000];
  categorize_macro(1000);
  print $categoryname[$mcategory[1000]] . "\n";
}

# Takes macro name as argument; categorizes each of the macro's definitions
sub categorize_macro_name
{ my ($name) = @_;
  check_args(1, "categorize_macro_name", caller, @_);
  if (defined($mntype{$name}))
    { return; }
  my $numdefs = $macros{$name}[0];
  if (!defined($numdefs))
    { # We called this on a non-macro (we try for every name in a definition).
      return; }
  my $type;
  my $category;
  { my $i;
    for ($i = 1; $i <= $numdefs; $i++)
      { if (!defined($mcategory[$macros{$name}[$i]]))
	  { categorize_macro($macros{$name}[$i]);
	    if (!defined($type))
	      { $type = $mtype[$i];
		$category = $mcategory[$i]; }
	    else
	      { $type = type_lub($type, $mtype[$i]);
		$category = category_lub($category, $mcategory[$i]); } } } }
  $mntype{$name} = $type;
  $mncategory{$name} = $category;
}


# Takes index into macro arrays as argument
sub categorize_macro
{ my ($index) = @_;
  check_args(1, "categorize_macro", caller, @_);

  # print "Categorizing $index $mname[$index]$margs[$index] $mbody[$index]\n";

  if (defined($mcategory[$index]))
    { # print "Already categorized! $mcategory[$index] $categoryname[$mcategory[$index]]\n";
      return; }
  $mcategory[$index] = $catINPROCESS;

  my $body = remove_comments($mbody[$index]);
  $mbody_noc[$index] = $body;
  $fDebugCommentRemoval && print STDERR "body = '$mbody[$index]'\nbody_noc = '$body'\n";

  my $category;
  my $type;
  if ($body eq "")
    # Null define
    { $category = $catNULLDEFINE; }
#!    elsif ($body =~ /^\".*\"$/)
#!      # String
#!      { # print "found string";
#!        $category = $catLITERAL;
#!        $type = $typeSTRING; }
  else
    { my $remaining;
      ($type, $remaining) = parse_exp($body);
      # print "type = $type; remaining = $remaining\n";
      # $type was ($type != $typeFAIL)
      if ($type && ($remaining =~ /^\s*$/))
	# Expression
	{ $category = $catEXP;
	  # print "category = $category; found expression $body\n";
	  { my $arg;
	    foreach $arg (split(/[\(, \t]*/, $margs[$index]))
	      { delete $parsevars{$arg};
		if (defined($parsetypes{$arg}))
		  { $category = $catTYPEARG;
		    goto CATEGORIZED; }
		delete $parsefuns{$arg}; } }
	  # print "category postargs = $category\n";
	  # Assume the functions and types are well-defined if not macros
	  # If they are macros, should check 'em, not just fail.
	  { my $fun;
	    foreach $fun (keys %parsefuns)
	      { if (defined $macros{$fun})
		  # This is actually fine most of the time; fix later.
		  { $category = $catMACROFUN;
		    goto CATEGORIZED; } } }
	  # print "category postfun = $category\n";
	  { my $type;
	    foreach $type (keys %parsetypes)
	      { if (defined($macros{$type}))
		  # This may be fine; fix later.
		  { $category = $catMACROTYPE;
		    goto CATEGORIZED; } } }
	  # print "category posttype = $category\n";
	  # For each free variable, check its type.
	  { my $var;
	    foreach $var (keys %mfreevars)
	      { print "examining free var $var ($mname[$index])\n";
		if (defined($macros{$var}))
		  { my $varclass;
		    my $i;
		    foreach $i ($macros{$var})
		      { if ($mcategory[$i] == $catNOTYET)
			  { categorize_macro($i); }
			if (!defined($varclass))
			  { $varclass = $mcategory[$i]; }
			elsif ((($mcategory[$i] == $catLITERAL)
				|| ($mcategory[$i] == $catCONSTANT)
				|| ($mcategory[$i] == $catSOMECONSTANT))
			       && (($varclass == $catLITERAL)
				   || ($varclass == $catCONSTANT)
				   || ($varclass == $catSOMECONSTANT)))
			  { $varclass = $catSOMECONSTANT; }
			elsif ($varclass != $mcategory[$i])
			  { $category = $catFAILURE;
			    goto CATEGORIZED; }
			else
			  { die "Huh?"; } }
		    if (!(($varclass == $catLITERAL)
			  || ($varclass == $catCONSTANT)
			  || ($varclass == $catSOMECONSTANT)))
		      { $category = $catFAILURE; # should be more specific here
			goto CATEGORIZED; } }
		else
		  # This is a free variable.  Should check whether it is a global
		  # (which would be OK; a local would be bad).
		  { $category = $catEXPFREE; # should be more specific here
		    goto CATEGORIZED; }
	      } }
	  # print "category postfree = $category\n";
	  $category = $catSOMECONSTANT;
	  # print "category = $category\n";
	}
      else
	# Should do some evilness processing here, to justify the failed
	# categorization.
	{ # Not an expression, apparently
	  $category = $catFAILURE;
	}
    }

 CATEGORIZED:
  # print "categorized as $category = $categoryname[$category]\n";
  if ($fShowCategorization)
   { # print defined($index), " ", defined($mfile[$index]), " ", defined($mline[$index]), " ", defined($category), " ", defined($categoryname[$category]), " ", defined($mname[$index]), " ", defined($margs[$index]), " ", defined($mbody[$index]), "\n";
     # print "$mfile[$index]:$mline[$index]: $category = $categoryname[$category]: $mname[$index]$margs[$index] $mbody[$index]\n";
      print CATEG "$mfile[$index]:$mline[$index]: $categoryname[$category]";
      if (($category == $catEXP)
	  || ($category == $catEXPFREE)
	  || ($category == $catLITERAL)
	  || ($category == $catCONSTANT)
	  || ($category == $catSOMECONSTANT))
	{ print CATEG "(", type_name($type), ")"; }
      print CATEG ": $mname[$index]$margs[$index] $mbody[$index]\n"; }
  $mcategory[$index] = $category;


#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: NullDefine: $name\n";
#     }
#   }
}


# Return true for a macro that takes a single arg and either returns it or
# returns only open and close parens, which can be used to construct either
# a K&R or ANSI function declaration by passing in a parenthesized list as
# the argument.
sub is_fun_decl_arg_macro
{ my ($identifier) = @_;
  check_args(1, "is_fun_decl_arg_macro", caller, @_);

  # print "is_fun_decl_arg_macro: $identifier $macros{$identifier}[0] $margs[$macros{$identifier}[1]] $margs[$macros{$identifier}[2]]\n";

  if (($macros{$identifier}[0] == 2)
      && (!($margs[$macros{$identifier}[1]] =~ /,/))
      && (!($margs[$macros{$identifier}[2]] =~ /,/)))
    ## Two expansions, each with one argument
    { # print "is_fun_decl_arg_macro stage 2\n";
      my $empty_parens;
      if ($mbody[$macros{$identifier}[1]] =~ /^\(\s*\)$/)
	{ $empty_parens = 1; }
      elsif ($mbody[$macros{$identifier}[2]] =~ /^\(\s*\)$/)
	{ $empty_parens = 2; }
      if (defined($empty_parens))
	{ my $body = $mbody[$macros{$identifier}[3-$empty_parens]];
	  my $args = $margs[$macros{$identifier}[3-$empty_parens]];
	  # print "is_fun_decl_arg_macro $empty_parens $args $body", scalar($args =~ /^\(\s*$body\s*\)$/), "\n";
	  if ($args =~ /^\(\s*$body\s*\)$/)
	    { return $true; } } }
  return $false;
}


# # Uses $lastline global, too
# sub categorize_macro
# { my ($name, $args, $fullbody) = @_;
#   check_args(1, "categorize_macro", caller, @_);
#   if ($fullbody =~ m!^(.*?)\s*(/\*.*\*/\s*)*(//.*)?$!) {
#     # $1 matches non-commented part w/ leading,trailing ws removed
#     $body = $1;
#   } else {
#     $body = $fullbody;
#   }
#   $fDebugCommentRemoval && print STDERR "fullbody = '$fullbody'\nbody = '$body'\n";
#   if (defined($args)) {
#     if ($args =~ /^\(\s*\)$/) {
#       $cWithNullArgs++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: WithNullArgs: $name $args $fullbody\n";
#     } else {
#       $cWithArgs++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: WithRealArgs: $name $args $fullbody\n";
#     }
#   }
#   # Must not have had args
#   elsif (!defined($body) || $body eq "") {
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cPreventMI++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: PreventMI: $name\n";
#     }
#     else {
#       $cNullDefine++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: NullDefine: $name\n";
#     }
#   }
#   # Must have a body
#   elsif ($body =~ /^\".*\"$/) {
#     $cSimpleStrConstant++;
#     $fShowCategorization &&
#       print CATEG "$currentfile:$.: SimpleStrConstant: $name $fullbody\n";
#   }
#   # If the type contains a trailing *, the constant is usually (not always!) 0
#   elsif ($body =~ /^\(\(\w+(\s+\**)?\)\s*(.*)\)$/ && FIsNumConst($2)) {
#       $cCastedConstant++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: CastedConstant: $name $fullbody\n";
#     }
#   #FIX: these regexps could be better
#   elsif (FIsNumConst($body) ||
# 	 $body =~ /^'(\\?.|\\[0-7][0-7][0-7])'$/) { # single character constant 'g'
#     # is it just a number, possibly like "(4.566)" or "7" or "0x5FaB" or "'g'"
#     if ($lastline =~ /^\#[ \t]*ifndef[ \t]* $name$/) {
#       $cSimpleConstantWithDefault++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: SimpleConstantWithDefault: $name $fullbody\n";
#     }
#     else {
#       $cSimpleConstant++;
#       $fShowCategorization &&
# 	print CATEG "$currentfile:$.: SimpleConstant: $name $fullbody\n";
#     }
#   }
#   elsif ($body =~ /^(L|x|\d|\(|\s|\)|\<|\>|\+|\-|\=|\*|\||\&|\%|\!)*$/) {
#     # FIX: this regexp is lame-- L,x needed for 0x80 << 3 or 1L << 25
#     # is it a numeric expression?
#     $cSimpleExpression++;
#     $fShowCategorization &&
#       print CATEG "$currentfile:$.: SimpleExpression: $name $fullbody\n";
#   }
#   else {
#     $cUncategorized++;
#     $fShowCategorization &&
#       print CATEG "$currentfile:$.: Uncategorized: $name $fullbody\n";
#   }
# }

# arguments are in @_, that is $_[0], $_[1], etc.
sub checkmacrodef
{
}

# returns zero if it was ok
# otherwise $EVIL $DANGER $OBSOLETE $ILLEGAL
# (each individual bits)
sub check_macro_body
{ my ($body) = @_;
  check_args(1, "check_macro_body", caller, @_);
  my $result = 0;
  if ($#_ != 0) { die "Wrong number of arguments to check_macro_body."; }
  # print "check_macro_body: $body\n";
  my $indquote = 0;
  my $insquote = 0;
  my $incomment = 0;
  my @nesting = ();
  while ($body =~ m/[\]\[(){}\"\'\#]|\/\/|\/\*|\*\//) #'FIXCOLOR
    # Found paren, quote, cpp directive, or comment
    { my $match = $&;
      my $body = $';
      # print "$match ||| $body\n";
      if ($match =~ /[\[\(\{]/)
        { push(@nesting,$match); }
      elsif ($match =~ /[\]\)\}]/)
	{ if ($#nesting == -1)
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: close $match without open in $mname\n    $_[0]\n"; }
	  else
	    { my $popped = pop(@nesting);
	      if ((($match eq "\]") && ($popped ne "\["))
		  || (($match eq "\)") && ($popped ne "\("))
		  || (($match eq "\}") && ($popped ne "\{")))
		{ $result |= $DANGER;
		  print EVIL "$currentfile:$.: dangerous: $popped matched by $match in $mname:\n    $_[0]\n"; } } }
      elsif ($match eq "\"")
        { if ($body =~ m/$non_escaped_double_quote_re/o)
            # Empty string OK only if that is the entire body.
            { if ($false	# turn off the test for now
		  && ((length($`) + length($1) + length($2)) == 0)
		  && (length($_[0]) > 2))
                { $result |= $DANGER;
		  print EVIL "$currentfile:$.: dangerous: empty string in $mname:\n    $_[0]\n"; }
              $body = $'; }
          else
           { $result |= $ILLEGAL;
	     print EVIL "$currentfile:$.: illegal: unterminated string $& in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "\'")
        { if (($body =~ m/^\\''/) || ($body =~ m/\'/))
	    { # do this first because we're going to do more matching
	      $body = $';
	      my $char = $` . $&;
              chop($char);	# remove trailing '
	      # Perhaps don't bother with this test; getline already checked
	      # for illegal character constants.
	      if (! ($char =~ m/^$char_literal_contents_re$/o))
	        { $result |= $ILLEGAL;
		  print EVIL "$currentfile:$.: illegal: bad character constant $char in $mname:\n    $_[0]\n"; }
    	       }
          else
            { $result |= $ILLEGAL;
	      print EVIL "$currentfile:$.: illegal: unterminated character constant $& in $mname:\n    $_[0]\n";
              $body = ""; } }
      elsif ($match eq "#")
	{ if (substr($', 0, 1) eq "#")
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: ## pasting in $mname:\n    $_[0]\n";
	      $body = substr($body, 1); }
	  # This list from GNU C preprocessor manual
	  # It's not complete, since #assert introduces new preprocessor commands.
	  elsif ($' =~ m/(assert|cpu|define|elif|else|error|ident|if|ifdef|ifndef|import|include|include_next|line|machine|pragma|system|unassert|warning)\b/)
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: preprocessor directive #$& in $mname:\n    $_[0]\n"; }
	  else
	    { $result |= $DANGER;
	      print EVIL "$currentfile:$.: dangerous: stringization in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "/*")
	# This test probably fails for a/**//**/b.  Oh, well.
        { my $postmatch = $';
	  my $precedingabuts = ($` =~ m/\w$/);
	  while (not ($postmatch =~ m!\*/!))
	    { my $nextline;
	      if ($nextline = getline())
		# Get some more text, and look for the comment close there.
		{ $body = append_lines($body, $nextline);
		  $postmatch = append_lines($', $nextline);
		}
	      else
		{ $result |= $EVIL;
		  print EVIL "$currentfile:$.: evil: unterminated comment in $mname:\n    $_[0]\n";
		  $body = "";
		  $postmatch = ""; } }
	  # print "Setting $body to $'; $`; $&.\n";
	  # Redo this because the one in the while test is considered
	  #   in the block, so we lost the (localized) match data.
	  $postmatch =~ m/\*\//;
	  $body = $';
	  if ($precedingabuts && ($body =~ m/^\w/))
	    { $result |= $OBSOLETE;
	      print EVIL "$currentfile:$.: obsoleted: comment pasting in $mname:\n    $_[0]\n"; } }
      elsif ($match eq "//")
        { # print "$currentfile:$.: evil: //-style comment in $mname:\n    $_[0]\n";
          $body = ""; }
      elsif ($match eq "*/")
	# $_[0] doesn't give me the whole thing; why?  ($body only contains
	#   what follows the match at this point.)
        { $result |= $EVIL;
	  print EVIL "$currentfile:$.: evil: comment terminator */ not in comment in $mname:\n    $_[0]\n"; }
      else
        { die "$currentfile:$.: ???: match = $match before $body in $mname:\n    $_[0]\n"; }
        }
  if ($#nesting != -1)
    { $result |= $EVIL;
      print EVIL "$currentfile:$.: evil: no match for ", @nesting, " in $mname:\n    $_[0]\n"; }
  return $result;
}



###########################################################################
### Miscellaneous
###

# A sample call:   check_args(2, "parse_declarator", caller, @_);
# The last two arguments should always be "caller" and "@_";
# Maybe have this return the arglist, so it can be merged in with the my line???

sub check_args
{
  my ($num_formals, $function_name, $package, $filename, $line, @args) = @_;
  if (@_ < 5) { die "check_args needs at least 5 args, got: @_\n"; }
  my $num_actuals = @args;
  if ($num_actuals != $num_formals)
    { die "function $function_name expected $num_formals argument",
      ($num_formals == 1) ? "" : "s",
      ", got $num_actuals at $filename line $line",
      ($num_actuals == 0) ? "" : ": @args", "\n"; }
  my $index;
  for $index (0..$#args)
    { if (!defined($args[$index]))
	{ die "function $function_name undefined argument ", $index+1, " at $filename line $line: @args\n"; } }
}

sub check_args_range
{
  my ($min_formals, $max_formals, $function_name, $package, $filename, $line, @args) = @_;
  if (@_ < 6) { die "check_args_range needs at least 6 args, got: @_\n"; }
  my $num_actuals = @args;
  if (($num_actuals < $min_formals) || ($num_actuals > $max_formals))
    { die "function $function_name expected $min_formals-$max_formals arguments, got $num_actuals at $filename line $line",
      ($num_actuals == 0) ? "" : ": @args", "\n"; }
  my $index;
  for $index (0..$#args)
    { if (!defined($args[$index]))
	{ die "function $function_name undefined argument ", $index+1, " at $filename line $line: @args\n"; } }
}

sub check_args_at_least
{
  my ($min_formals, $function_name, $package, $filename, $line, @args) = @_;
  if ($min_formals == 0)
    { die "Isn't it pointless to check for at least zero args to $function_name?\n"; }
  if (@_ < 6) { die "check_args_at_least needs at least 6 args, got: @_\n"; }
  my $num_actuals = @args;
  if ($num_actuals < $min_formals)
    { die "function $function_name expected at least $min_formals argument",
      ($min_formals == 1) ? "" : "s",
      ", got $num_actuals at $filename line $line",
      ($num_actuals == 0) ? "" : ": @args", "\n"; }
  my $index;
  for $index (0..$#args)
    { if (!defined($args[$index]))
	{ die "function $function_name undefined argument ", $index+1, " at $filename line $line: @args\n"; } }
}



###########################################################################
### Testing
###

# This comes before the main loop so we can avoid executing it (the main loop).

# { my $argdecls = "int argc;char **argv;{";
#   if ($argdecls =~ /^\s*$type_declarator_re\s*([,;])/)
#     { print "$1|$3|$7|$9|$'\n"; } }

# print "<<" . parse_expression ("(uch)get_byte()") . "\n";
# print "<<" . parse_expression ("get_byte()") . "\n";
# print "<<" . parse_expression ("(uch)get_byte") . "\n";
# print "<<" . parse_expression ("(strcmp((s1),(s2)) == 0)") . "\n";
# print "<<" . parse_expression ("strcmp((s1),(s2))") . "\n";
# print "<<" . parse_expression ("((s1),(s2))") . "\n";
# print "<<" . parse_expression ("(s1),(s2)") . "\n";
# print "<<" . parse_expression ("(s1)") . "\n";
# print "<<" . parse_expression ("s1,s2") . "\n";
# print "<<" . parse_expression ("strcmp(s1,s2)") . "\n";
# print "<<" . parse_expression ("'\\'") . "\n";
# print "<<" . parse_expression ("(1L << (n))") . "\n";
# print "<<" . parse_expression ("(1 << (n))") . "\n";
# print "<<" . parse_expression ("(1 << n)") . "\n";
# print "<<" . parse_expression ("(unsigned)(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("(1<<HASH_BITS)") . "\n";
# print "<<" . parse_expression ("\"foo\"") . ">>\n";
# print "<<" . test_categorize_macro("\"\\037\\235\"") . ">>\n";
# print "<<" . test_categorize_macro("\"\037\235\"") . ">>\n";
# if (parse_expression ("\"foo\"")) { print "FOO is true "; } else { print "false"; }
# if (0) { print "ZERO is true "; } else { print "false"; }
# print type_name(parse_expression("0400")) . "\n";
# print type_name(parse_expression("0x8000")) . "\n";
# print type_name(parse_expression("33 ? 55 : 0x8000")) . "\n";
# print type_name(parse_expression("tab_prefix[i]")) . "\n";
# print defined($type_num["foo"]);
# print "foo" + 0;
# print type_name(1);
# print type_name(parse_expression("flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("(block_start >= 0L ? (char*)&window[(unsigned)block_start] :  (char*)NULL, (long)strstart - block_start, (eof))")) . "\n";
# print type_name(parse_expression("block_start >= 0L")) . "\n";
# print type_name(parse_expression("(char*)&window[(unsigned)block_start]")) . "\n";
# print type_name(parse_expression("(char*)NULL, (long)strstart - block_start, (eof)")) . "\n";
# print type_name(parse_expression("&window")) . "\n";
# print type_name(parse_expression("(char*)NULL")) . "\n";
# print type_name(parse_expression("NULL")) . "\n";
# print type_name(parse_expression("(long)strstart - block_start")) . "\n";
# print type_name(parse_expression("(eof)")) . "\n";
# print type_name(parse_expression("(uch)get_byte()")) . "\n";
# test_categorize_macro("(uch)get_byte()");
# print type_name(parse_expression("memset ((voidp)(s), 0, (n))")) . "\n";
# print type_name(parse_expression("((char_type *)(&d_buf[DIST_BUFSIZE-1]))")) . "\n";
# print type_name(parse_expression("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))")) . "\n";
# print type_name(parse_expression("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))")) . "\n";
# print type_name(parse_expression("malloc((size_t)(items)*(size_t)(size))")) . "\n";
# test_categorize_macro("memset ((voidp)(s), 0, (n))");
# test_categorize_macro("((char_type *)(&d_buf[DIST_BUFSIZE-1]))");
# test_categorize_macro("((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8))");
# test_categorize_macro("((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16))");
# test_categorize_macro("malloc((size_t)(items)*(size_t)(size))");
# $foo = "x"; $foo =~ /x/; print defined($'), defined($'), defined($'), "\n";
# print ("" eq "\n"), "\n";
# test_categorize_macro("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))");
# print type_name(parse_expression("(inptr < insize ? inbuf[inptr++] : fill_inbuf(0))")) . "\n";
# print type_name(parse_expression("inptr < insize")) . "\n";
# print type_name(parse_expression("inbuf[inptr++]")) . "\n";
# # This is failing because of the function call, I suppose.
# print type_name(parse_expression("fill_inbuf(0)")) . "\n";
# print scalar("int fill_inbuf(eof_ok)" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# "abaababb" =~ /(((a+)(b+))*)/; print "<<$1>><<$2>><<$3>><<$4>><<$&>>\n";
# print scalar("static char  *license_msg[] =" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# print scalar("static char *license_msg[] =" =~ /^\s*$type_declarator_re\s*([,=;\(])/o), "\n";
# print scalar("static char" =~ /^\s*$type_specifier_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_re$/o), "\n";
# print scalar("*license_msg[]" =~ /^\s*$declarator_unparenthesized_re$/o), "\n";
# print scalar("*" =~ /^$pointer_declarator_prefix_re/o), "\n";
# print scalar("license_msg" =~ /^\s*$identifier_re/o), "\n";
# print scalar("[]" =~ /^\s*$array_declarator_suffix_re/o), "\n";
# print scalar("char" =~ /^$type_re$/o), "\n";
# print scalar("char" =~ /^$type_specifier_re$/o), "\n";
# print scalar("char" =~ /^$identifier_re$/o), "\n";
# print type_name(parse_expression("(ct_data near *)0")), "\n";
# print scalar("(ct_data near *)" =~ /^\s*\(\s*$type_re\s*\)\s*$/o), "\n";
# print parse_array_initializer("bl_tree, (ct_data near *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS, 0};\n"), "\n";
# exit;


###########################################################################
### Main loop
###

# This is at the end of the file so that constants and variables can be
# introduced and set near where they are used rather than at the top of the
# file (before the main loop).  This is especially nice for globals that
# are only used by one or two routines.

use Getopt::Std;
getopts('ihvD:S:c:e:');

usage() if ($opt_h);

$fShowCategorization = $opt_c;

if ($opt_i) {
  while (<STDIN>) {
    next if /^-.*$/;
    chop ($_);
    push @ARGV, $_;
  }
}

if ($opt_e) { open(EVIL,">$opt_e") || die "Failed opening $opt_e"; }
  else { open(EVIL,">-") || die "Failed opening stdout!"; }
if ($opt_S) { open(STATS,">$opt_S") || die "Failed opening $opt_S"; }
if ($opt_D) { open(DEFINES,">$opt_D") || die "Failed opening $opt_D"; }
if ($opt_c) { open(CATEG,">$opt_c") || die "Failed opening $opt_c"; }


$fDebugCmdProcessing && print "@ARGV";

# Testing
# test_typedecl_regexp(); exit();

find_macro_definitions();	# also counts other preprocessor usage

# Kind of a hack
{ my $name;
  for $name (keys %macros)
    { if (is_fun_decl_arg_macro($name))
	{ $fun_decl_arg_macros{$name} = $true; } } }
print "fun_decl_arg_macros: ", join(" ", (keys %fun_decl_arg_macros)), "\n";
print "OF: ", is_fun_decl_arg_macro("OF"), "\n";

# { my $ofdefs;
#   for $ofdefs (1..$macros{"OF"}[0])
#     { print "|", join("|", $mname[$macros{"OF"}[$ofdefs]], $margs[$macros{"OF"}[$ofdefs]], $mbody[$macros{"OF"}[$ofdefs]], $mfile[$macros{"OF"}[$ofdefs]], $mline[$macros{"OF"}[$ofdefs]]), "|\n"; } }


# Print number of definitions for each macro
{ my $name;
  for $name (sort keys %macros)
    { print "$name $macros{$name}[0]\n"; } }

get_macro_call_types();

### All the files have been read; now process the macros
print "Processing " . $cppcmdcount{"define"} . " macros\n";
{ my $index;
  for $index (0..$cppcmdcount{"define"}-1)
    { # print "$index:  . "" . $mbody[$index] . "\n";
      #   print &parse_expression($mbody[$index]) . ": ";
      #   foreach $var (keys(%parsevars)) { print $var . " "; }
      #   print "\n  $mname[$index]";
      #   if (defined($margs[$index])) { print $margs[$index]; }
      #   print " $mbody[$index]\n";
      categorize_macro($index);
    } }

# 	  # Nothing to check if this is just making the macro defined w/o a body.
# 	  if (defined($mdef) && ($flags = check_macro_body($mdef)) != 0) {
# 	    $cEvil++ if $flags & $EVIL;
# 	    $cIllegal++ if $flags & $ILLEGAL;
# 	    $cObsoleted++ if $flags & $OBSOLETE;
# 	    $cDanger++ if $flags & $DANGER;
# 	  }

output_stats();

exit();
