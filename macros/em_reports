#!/uns/bin/perl -w
# $Id$
# em-reports

# TERMS:
#   project file == a file passed in via -i, or on cmd line
#                   it is also called an NI (not-included) file
#   system file == a file that got parsed because another file
#                  #include-d it
#   ncnb == non-comment, non-blank; a line containing code
#   c_ == count of, an integer variable
#   rg_ = region, an array of indices for extracting slices from another array
#   _ni = non-include; for a file, means it was on command line (?)
#   mi = method of inclusion; why this file is being processed

# FIX: what are all these extra letters doing in here?
my $getopts_option_letters = 'ihvtIAau1pTg:d:D:M:S:F:L:C:P:c:s:';

# FIX: remove -D -U -S -F -L -C options.

# Usage: something like this
# for i in ../*.state; do NM=${i:t:r}; em_reports -s $i -d .:$NM > $NM.repout 2> $NM.reperr; done

# Remove the asterisks below when the options are known to the users.

sub usage () {
  die "@_\nUsage: $0 [-$getopts_option_letters]
New options marked with *; options with ':', above, take an argument
  -t  use [TAB] as the OFS for the statistics files (not space)
* -g [num]  set the num'th debugging option to true  {ought to be able to name}
	-g 0 turns off all debugging flags.
* -d [directory:basename]  use standard filenames under the given directory
	If basename is not supplied, use extensions (sans .) as whole name.
  -D [file]  output the names of the macros (and number of times defined)
  -U [file]  output macro usage information
  -S [file]  output the per directive statistics to file
  -F [file]  output the function information to file
  -L [file]  output the file's lines/functions information to file
  -C [file]  output categorizations to file
  -P [file]  output dependence info to file
  -c [file]  output cond. compilation directive statistics to file
* -l [file]  output macro lint information to file
  -E [file]  send evil macros to file instead of stdout
  -s [file]  the state file to use [\"state\" by default]
* -v  verbose: report phases as they are encountered

(Note: -{D,S,F,C,c,E,P} options take precedence over the -d option)

e.g.

em_reports -s ../../evilout.state -d ../../:evilout
";
}


###########################################################################
### Strictures
###

require 5.004;  # uses "for my $var"

# Use strict requires that for each global, either
#  * all uses are fully qualified with the package name ($main::$true), or
#  * it is declared with "my" or appears in a use vars qw( ... ) declaration.
use strict;
## This gives Mike an error as of 1/27/97.
# use diagnostics;

# Permit use of $MATCH for $& and so forth.
use English;

## Other packages

use Carp;
use checkargs;
use em_constants;
use em_util;
use paren;
use cline;
use IO::Handle;


###########################################################################
### Variables
###

## Integers:

## Five different kinds of line counts that we care about are:
# (physical,ncnb_phys,cpp_phys,cpp_phys_ncnb)
# We care about these five line counts, %cppcmdcount, $cpp_cmds
# in each of the 8 possible kinds of file-types
# Dimension 1: header file vs code file (use regexp-s)
# Dimension 2: method of inclusion: (input,arg,#include<>,#include"")
#              Maybe only care about first 2 kinds vs. last 2 kinds.
#	       Currently the former are distinguished because we can do
#              so easily, and it might come in handy some day, to generate
#              separate statistics for arbitrary subset of files.
# Note: #include"" or <> is only our filetype if the file was included
# from another file we parsed and it was not given as an input/arg file.
# Generalize the variables for each of these to be lists of eight values.

# This enumeration gives indices into the lists

# Output field separator
my $outOFS;

## Debugging; should add more
my $fDebugCmdProcessing = $false;
my $fDebugCommentRemoval = $false;
my $debug_scopes = $false;
my $debug_type_match = $false;
my $debug_parse_function = $false;
my $debug_parse_expression = $false;
my $debug_parse_statement = $false;
my $debug_merge_branches = $false;
my $debug_parse_array_init = $false;
my $debug_peek = $false;
my $debug_getline = $false;	# a LOT of output; use only on small inputs
my $debug_categorize_macro = $false;
my $debug_cpp_if_comments = $false;

## Command-line processing
# Are these in any order?
use vars qw($opt_i $opt_I $opt_h $opt_v $opt_t $opt_d
	    $opt_D $opt_M $opt_S $opt_F $opt_L $opt_C $opt_P $opt_c $opt_p $opt_l
	    $opt_u $opt_1 $opt_A $opt_a $opt_g $opt_T $opt_s);
my $fIgnoreIncludes = $false;


###########################################################################
### Print output statistics
###

# FIXGJB: why does this include variables not imported from elsewhere, like
# $type_specifier_re?
use vars qw($getopts_option_letters $c_reserved_type_word_alternatives
    $c_reserved_nontype_word_alternatives
    $c_plus_plus_reserved_type_word_alternatives
    $c_plus_plus_reserved_nontype_word_alternatives
    $reserved_type_word_re $reserved_nontype_word_re $reserved_word_re
    $constant_exp_re $constant_or_upcase_exp_re
    $float_literal_whole_re $float_literal_frac_re
    $float_literal_exp_re $float_literal_noexp_re $hex_literal_re
    $dec_oct_literal_re $number_literal_re $char_literal_contents_re
    $char_literal_re $non_escaped_double_quote_re $string_literal_re
    $identifier_no_dollar_re $identifier_re $type_specifier_re
    $type_special $type_re_special_1 $type_re_special_2
    $type_re_special $type_suffix_re $type_re $type_qualifier_re
    $pointer_declarator_prefix_re $pointer_declarator_prefixes_re
    $array_declarator_suffix_re $array_declarator_suffixes_re
    $declarator_unparenthesized_re $declarator_parenthesized_re
    $declarator_re $type_declarator_re $simple_arglist_re
    $type_declarator_arglist_re $numeric_type_word_re $numeric_type_re
    $non_numeric_type_re $builtin_type_base_re $builtin_type_re
    $numeric_binop_regexp $bool_binop_regexp $arb_type_binop_regexp
    $binop_regexp @rg_physical_lines @rg_ncnb_lines @rg_cpp_phys_lines
    @rg_cpp_phys_ncnb_lines @rg_cpp_cmds @rg_category_counts
    @rg_cppcmdcounts $ncnb_physical_lines_ni $cpp_cmds $cpp_cmds_ni
    $cpp_cmds_hdr $cpp_cmds_hdr_ni $cpp_cmds_c $cpp_cmds_c_ni
    $symtab_scopes $line $cBuiltinMacros $cMacrosInTables
    %files_function_lines %function_to_locs
    %function_name_to_macros_it_uses $current_file
    $current_ftype_index $current_function
    $current_function_start_line $current_macro_line_number @files
    %file_inclusion_method @files_included $outOFS %macros
    %macros_c_undefs %macros_uses %macros_file_line_uses
    %macros_used_in_functions @mdef_name @mdef_args @mdef_body
    @mdef_file @mdef_line @mdef_physical_lines
    @mdef_physical_ncnb_lines %mdef_freevars @mdef_freefuns
    @mdef_dependenton @mdef_direct_expansion_uses @mdef_type
    @mdef_category @mdef_properties
    @mdef_evilness %mntype %mncategory %fun_decl_arg_macros
    %semi_fun_decl_arg_macros %void_macros $fDebugCmdProcessing
    $fDebugCommentRemoval $debug_scopes $debug_type_match
    $debug_parse_function $debug_parse_expression $debug_parse_statement
    $debug_merge_branches $debug_parse_array_init $debug_peek
    $debug_getline $debug_categorize_macro $debug_cpp_if_comments
    $fIgnoreIncludes @getline_ungot_raw_lines
    @getline_ungot_simple_lines @dependenton $incomment $instring
    %parsevars %parsefuns %parsetypes $parse_exp_saw_equals
    @symtab_identifiers @symtab_types $scopemarker $wf_last_filename
    $wf_last_line_no $wf_last_index
    %inclusion_dependenton %inclusion_dependees %inclusion_dependee_lines
    %expansion_dependenton %expansion_dependees %expansion_dependee_lines
    %either_dependee_lines
    @mdef_direct_inclusion_dependenton
    @rg_ccd_cat_counts
    %macros_used_by_cpp
);
# Computed from the above, but not in state file.
my @mdef_body_simple;


use vars qw(%macros_c_all_uses @freq_use_buckets @freq_def_buckets
	   @macros_c_number_uses @macros_c_number_defs
	   @macros_c_number_uses_for @macros_c_number_defs_for
	   $macros_c_most_uses   $macros_c_most_defs
	   @macros_c_most_uses_for @macros_c_most_defs_for);


my (%cppcmdcount, %cppcmdcount_ni, %cppcmdcount_hdr_ni, %cppcmdcount_c_ni);
my (%category_counts_ni, %category_counts_c_ni, %category_counts_hdr_ni);


sub args_array ($)
{ my ($args) = check_args(1, @_);
  $args =~ s/^\s*\(\s*//;
  $args =~ s/\s*\)\s*$//;
  return split(/\s*,\s*/,$args);
}


# FIX: these sub-parts might better be broken up into functions
sub output_stats ()
{
  check_args(0, @_);

  local $OFS = (defined($outOFS) ? $outOFS : " ");
  #   if (defined($outOFS)) {
  #     $OFS = $outOFS;
  #   } else {
  #     $OFS = " ";
  #   }
  # Use ".", not ",", here, because $OFS has been set!
  # print "OFS: " . (defined($OFS) ? "'$OFS'" : "undef") . ", outOFS: " . (defined($outOFS) ? "'$outOFS'" : "undef") . "\n";

  my $physical_lines = sum_array(@rg_physical_lines);
  my $ncnb_physical_lines = sum_array(@rg_ncnb_lines);
  my $cpp_physical_lines = sum_array(@rg_cpp_phys_lines);
  my $cpp_physical_ncnb_lines = sum_array(@rg_cpp_phys_ncnb_lines);

  my $physical_lines_ni =
    sum_array(@rg_physical_lines[@ftype_NOT_INCLUDED]);
  my $ncnb_physical_lines_ni =
    sum_array(@rg_ncnb_lines[@ftype_NOT_INCLUDED]);
  my $cpp_physical_lines_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_NOT_INCLUDED]);

  my $physical_lines_hdr_ni =
    sum_array(@rg_physical_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $ncnb_physical_lines_hdr_ni =
    sum_array(@rg_ncnb_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $cpp_physical_lines_hdr_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_HEADER_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_hdr_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_HEADER_NOT_INCLUDED]);

  my $physical_lines_c_ni =
    sum_array(@rg_physical_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $ncnb_physical_lines_c_ni =
    sum_array(@rg_ncnb_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $cpp_physical_lines_c_ni =
    sum_array(@rg_cpp_phys_lines[@ftype_NONHEADER_NOT_INCLUDED]);
  my $cpp_physical_ncnb_lines_c_ni =
    sum_array(@rg_cpp_phys_ncnb_lines[@ftype_NONHEADER_NOT_INCLUDED]);

  if ($opt_v) { STDOUT->autoflush(1); }

  if ($opt_S) {
    my ($h, $v);
    # Dump statistics on frequencies of directives
    if ($opt_v) { print STDOUT "stats..."; }
    select STATS;

    print "#LINES#: physical ncnb_phys cpp_phys cpp_phys_ncnb\n";
    print "$physical_lines $ncnb_physical_lines $cpp_physical_lines $cpp_physical_ncnb_lines\n";
    print "#LINESNI#: physical ncnb_phys cpp_phys cpp_phys_ncnb\n";
    print "$physical_lines_ni $ncnb_physical_lines_ni $cpp_physical_lines_ni $cpp_physical_ncnb_lines_ni\n";

    print "\n";

    OutputHistogram("DIRECTIVES_ALL",\%cppcmdcount,1,$true);

    OutputHistogram("DIRECTIVES_NI",\%cppcmdcount_ni,1);
    OutputHistogram("DIRECTIVES_NI%NCNB",\%cppcmdcount_ni,$ncnb_physical_lines_ni);
    OutputHistogram("DIRECTIVES_NI%PHYS",\%cppcmdcount_ni,$physical_lines_ni);

    OutputHistogram("DIRECTIVES_HNI",\%cppcmdcount_hdr_ni,1);
    OutputHistogram("DIRECTIVES_HNI%NCNB",\%cppcmdcount_hdr_ni,$ncnb_physical_lines_hdr_ni);
    OutputHistogram("DIRECTIVES_HNI%PHYS",\%cppcmdcount_hdr_ni,$physical_lines_hdr_ni);

    OutputHistogram("DIRECTIVES_CNI",\%cppcmdcount_c_ni,1);
    OutputHistogram("DIRECTIVES_CNI%NCNB",\%cppcmdcount_c_ni,$ncnb_physical_lines_c_ni);
    OutputHistogram("DIRECTIVES_CNI%PHYS",\%cppcmdcount_c_ni,$physical_lines_c_ni);

    print "\n";


    OutputHistogram("CATEGORIES_NI",\%category_counts_ni,1,$true);
    OutputHistogram("CATEGORIES_HNI",\%category_counts_hdr_ni,1);
    OutputHistogram("CATEGORIES_CNI",\%category_counts_c_ni,1);

    print "\n";

#    OutputHistogram("FAILED_CATEG",\%failed_categorization_type_count,1,$true);
#    print "\n";
  }

  # -M = dump the macro stats
  if ($opt_M) {
    if ($opt_v) { print STDOUT "macros..."; }
    select MACROS;
    print "#MACROS#: name cDefs cUndefs cCodeUses cMacroUses cCondUses cTotalUses HowUsed Categories InclusionMethods (%functionsThatUseIt)\n";
    foreach my $name (sort keys %macros) {
      #print STDERR "MNAME=$name, @{$macros{$name}}\n";
      #my $i = $macros{$name}[1];  #Should this now be 0?
      #die "i not defined for $name" if (!defined($i));

      #next if ($mdef_file[$i] eq $built_in_fake_file);

      die if (!defined($macros_uses{$name}));
      die if (!defined($macros_c_undefs{$name}));
      die if (!defined($macros_used_in_functions{$name}));

      # FIXPERL: cperl mode doesn't count , as a statement continuer
      # in a print

      my $cCodeUses = $macros_uses{$name}[$i_usage_code];
      my $cMacroUses = $macros_uses{$name}[$i_usage_macro];
      my $cCondUses = $macros_uses{$name}[$i_usage_cond];
      my $cTotalUses = $cCodeUses + $cMacroUses + $cCondUses;

      print "$name", $#{$macros{$name}}+1, $macros_c_undefs{$name},
      $cCodeUses, $cMacroUses, $cCondUses, $cTotalUses,
      how_used_from_code_cpp_uses($cCodeUses, $cMacroUses, $cCondUses),
      # These next two will be blank for things not defined, but only
      # used in cond. comp. directives
      join(",",CategoriesForMacroName($name)),
      join(",",InclusionMethodsForMacroName($name)),
      "\n%" . join("\n%",@{$macros_used_in_functions{$name}}),
      "\n";
    }
  }

  if ($opt_D) {
    if ($opt_v) { print STDOUT "defines..."; }
    select DEFINES;
# don't want extra lines-- harder for postprocessing tools
#    print  "\n";
    print "#DEFINITIONS#: name iDef inclusion_method filename line args plines p_ncnb_lines categorization (%macrosUsedInExpansion)\n";
    foreach my $name (sort keys %macros) {
      # Could also print number of times it's defined.
      for (my $iDef = 0; $iDef <= $#{$macros{$name}}; $iDef++ ) {
	my $i = $macros{$name}[$iDef];
	if ($mdef_file[$i] ne $built_in_fake_file) {
	  #print STDERR "NAME=$name,", join(", ",@{$macros{$name}}),"\n";
	  # Used to output $i third here, but it's irrelevant.
	  print "$name", $iDef+1, $file_inclusion_method{$mdef_file[$i]},
	  $mdef_file[$i], $mdef_line[$i], count_macro_args($mdef_args[$i]),
	  $mdef_physical_lines[$i], $mdef_physical_ncnb_lines[$i],
	  $categoryname[$mdef_category[$i]],
	  # FIX: add type name back in when we get that working
	  #$type_name_array[$mdef_type[$i]],
	  "\n%" . join("\n%",@{$mdef_direct_expansion_uses[$i]}), "\n";
	}
      }
    }
  }

  # -F = dump the function information
  # Want a histogram of this info?  try something like:
  # awk '$0 !~ /^[%#]/ {print $2}' < gzip.func | sort -n | uniq -c
  if ($opt_F) {
    if ($opt_v) { print STDOUT "functions..."; }
    select FUNCTIONS;
    print "#functionId cMacroExpansions (%the macros)\n";
    foreach my $function_name_id (sort keys %function_name_to_macros_it_uses) {
      print $function_name_id,scalar(@{$function_name_to_macros_it_uses{$function_name_id}}),"\n%",
      join(",",@{$function_name_to_macros_it_uses{$function_name_id}}), "\n";
    }
  }

  if ($opt_L) {
    if ($opt_v) { print STDOUT "funclines..."; }
    select FUNCLINES;
    foreach my $filename (sort keys %files_function_lines) {
      print "file: $filename\n", join("\n ",@{$files_function_lines{$filename}}), "\n";
    }
    foreach my $function (sort keys %function_to_locs) {
      print "function: $function ";
      my @infos = @{$function_to_locs{$function}};
      if ($#infos == 0)
	{ print join(', ',@{$infos[0]}); }
      else {
	# avoid extra semicolon at end of line
	my @one_file_results = (); # each elt describes one file
	foreach my $info (@infos) {
	  # Don't really need semicolon at end of last entry
	  push(@one_file_results, join(', ',@$info));
	}
	print join('; ',@one_file_results);
      }
      print "\n";
    }

    # Use "local" instead; it seems to work.
    # FIXPERL: Why does this give me an unitialized variable warning?
    # undef $OFS if (defined($OFS));
  }

  # conditional compilation directive statistics
  # output them as two rows, one with "# cat1 cat2 .... catn"
  # the second with the results
  if ($opt_c) {
    if ($opt_v) { print STDOUT "ccdstats..."; }
    select CCDSTATS;
    print "#$OFS";
    foreach my $cname (@cond_category_name) {
      print $cname . $OFS;
    }
    print "\n";
    foreach my $i (0..$#cond_category_name) {
      print sum_array(map {$_->[$i]} @rg_ccd_cat_counts[@ftype_ALL]) . $OFS;
    }
    print "\n";
  }

  # macro categories
  if ($opt_C) {
    if ($opt_v) { print STDOUT "categ..."; }
    select CATEG;
    foreach my $name (sort keys %macros) {
      for (my $iDef = 0 ; $iDef <= $#{$macros{$name}}; $iDef++ ) {
	my $index = $macros{$name}[$iDef];
	my $category = $mdef_category[$index];
	my $type = $mdef_type[$index];
	if (!defined($mdef_file[$index])) {
	  print STDERR "mdef_file[$index] not defined\n"
	}
	if (!defined($mdef_line[$index])) {
	  print STDERR "mdef_line[$index] not defined\n"
	}
	if (!defined($categoryname[$category])) {
	  print STDERR "categoryname[$category] not defined\n";
	}
	print "$mdef_file[$index]:$mdef_line[$index]: "
	  . ($mdef_args[$index] ? "function, " : "") . $categoryname[$category];
	if (($category == $catEXP)
	    || ($category == $catLITERAL)
	    || ($category == $catCONSTANT)
	    || ($category == $catSOME_CONSTANT))
	  { # These used to be commas, but those turn into tabs with -t option
	    print "(" . type_name($type) . ")"; }
	print ": $mdef_name[$index]$mdef_args[$index] $mdef_body[$index]\n";
      }
    }
  }

  if ($opt_P)
    { if ($opt_v) { print STDOUT "depend..."; }
      select DEPEND;
      # print "===========================================================================\n";
      print "Macro dependence info\n";
      for my $macro_name (sort keys %macros)
	{ print "$macro_name\n";
	  if (scalar(@{$macros{$macro_name}}) > 0)
	    { for my $i (@{$macros{$macro_name}})
		{ print "  def #$i: incl_dep: @{$mdef_direct_inclusion_dependenton[$i]}\n";
		    print "           exp_dep: @{$mdef_direct_expansion_uses[$i]}\n"; } }
	  else
	    { print "  no def; used on $macros_used_by_cpp{$macro_name}\n"; }
	  if (scalar(keys %{$inclusion_dependenton{$macro_name}}) > 0)
	    { print "  i_depon: ", join(' ',sort keys %{$inclusion_dependenton{$macro_name}}), "\n"; }
	  if (scalar(keys %{$inclusion_dependees{$macro_name}}) > 0)
	    { print "  i_depee: ", join(' ',sort keys %{$inclusion_dependees{$macro_name}}), "\n"; }
	  if ($inclusion_dependee_lines{$macro_name} > 0)
	    { print "  i_depee_lines: ", $inclusion_dependee_lines{$macro_name}, "\n"; }
	  if (scalar(keys %{$expansion_dependenton{$macro_name}}) > 0)
	    { print "  e_depon: ", join(' ',sort keys %{$expansion_dependenton{$macro_name}}), "\n"; }
	  if (scalar(keys %{$expansion_dependees{$macro_name}}) > 0)
	    { print "  e_depee: ", join(' ',sort keys %{$expansion_dependees{$macro_name}}), "\n"; }
	  if ($expansion_dependee_lines{$macro_name} > 0)
	    { print "  e_depee_lines: ", $expansion_dependee_lines{$macro_name}, "\n"; }
	  if ($either_dependee_lines{$macro_name} > 0)
	    { print "  tot_depee_lines: ", $either_dependee_lines{$macro_name}, "\n"; } }

      my %defs_lines = ();
      my %mndefs = ();;
      my %mndistinct_defs = ();
      { my $total_product = 0;
	for my $macro_name (keys %macros)
	  { my $num_defs = scalar(@{$macros{$macro_name}});
	    $mndefs{$macro_name} = $num_defs;
	    my $num_distinct_defs;
	    if ($num_defs < 2)
	      { $num_distinct_defs = 1; }
	    else
	      { my %def_hash;
		for my $i (@{$macros{$macro_name}})
		  { my $body = $mdef_body_simple[$i];
		    my $args = $mdef_args[$i];
		    # Canonicalize formal names to avoid gratuitous differences
		    if ($args)
		      { my @formals = args_array($args);
			for my $fno (0 .. $#formals)
			  { $body =~ s/\b$formals[$fno]\b/EM_ARG_NUM_$fno/g; } }
		    $body =~ s/\s+//g; # collapse all spaces
		    $def_hash{$body} = $true; }
		$num_distinct_defs = scalar(keys %def_hash); }
	    $mndistinct_defs{$macro_name} = $num_distinct_defs;
	    my $dep_lines = $either_dependee_lines{$macro_name};
	    my $this_product = $num_distinct_defs * $dep_lines;
	    $defs_lines{$macro_name} = $this_product;
	    $total_product += $this_product; }
	print "\n\nDEFS BY LINES PRODUCT: $total_product\n"; }
      print "  product = distinct_defs [defs] * (inclusion_dependees + expansion_dependees)";

      { my $prev_product = -1;
	for my $macro_name (sort { ($defs_lines{$b} <=> $defs_lines{$a})
				     || (scalar(@{$macros{$b}}) <=> scalar(@{$macros{$a}})) }
			    (keys %macros))
	  # At this point we are at the end, not beginning, of an output line
	  { my $this_product = $defs_lines{$macro_name};
	    ## Print one line per product
	    #  if ($this_product == $prev_product)
	    #	{ print ", ", $macro_name; }
	    #  else
	    #	{ print "\n", $this_product, "\t", $macro_name;
	    #	  $prev_product = $this_product; }
	    # Print one line per macro name
	    print "\n$this_product\t$macro_name\t= $mndistinct_defs{$macro_name} [$mndefs{$macro_name}] * ($inclusion_dependee_lines{$macro_name} + $expansion_dependee_lines{$macro_name})";
	  } }
      print "\n";
    }

  if ($opt_l)
    { if ($opt_v) { print STDOUT "lint..."; }
      select LINT;
      my $old_ofs = $OFS;
      $OFS = "\n    ";
      for my $macro_name (sort keys %macros)
	{ for my $i (@{$macros{$macro_name}})
	    { if ($file_inclusion_method{$mdef_file[$i]} ne "FromInclude<>")
		{ my @complaints = ();
		  my $body = $mdef_body_simple[$i];
		  my $args = $mdef_args[$i];
		  my $category = $mdef_category[$i];
		  my $category_is_expression
		    = (($category == $catEXP)
		       || ($category == $catLITERAL)
		       || ($category == $catCONSTANT)
		       || ($category == $catSOME_CONSTANT));
		  my $category_is_statement
		    = (($category == $catSTATEMENT)
		       || ($category == $catSTATEMENT_SANS_SEMI)
		       || ($category == $catPARTIAL_STATEMENT)
		       || ($category == $catSTATEMENTS)
		       || ($category == $catSTATEMENTS_SANS_SEMI)
		       || ($category == $catPARTIAL_STATEMENTS));
		  my $properties = $mdef_properties[$i];

		  # Check for formals but no body -- "#define foo(bar)" might
		  # have been intended as "#define foo (bar)".
		  # Suppress if body contains an empty comment.
		  if ((!$body) && $args && !($mdef_body[$i] =~ /\/\*\s*\*\/$/))
		    { push(@complaints,
			   (($args =~ /\(\s*\Q$macro_name\E\s*\)/) ? "" : "possible ")
			   . "missing space between macro name and parenthesized body (suppress w/empty comment)"); }
		  # Check uses of each formal
		  if ($args)
		    { my @args = args_array($args);
		      for my $arg (@args)
			{ my @formal_complaints = ();
			  if ($arg !~ /^$identifier_re$/o)
			    { push(@formal_complaints, "not an identifier"); }
			  # Add spaces to make sure that there's a first and last part
			  my @parts = split(/\b\Q$arg\E\b/, " $body ");
			  for my $i (0..$#parts)
			    { $parts[$i] =~ s/^\s+//;
			      $parts[$i] =~ s/\s+$//; }

			  my @unparen_uses = ();
			  my @sideeff_uses = ();
			  my $is_selector = $false;
			  for my $i (1..$#parts)
			    { my $pre = $parts[$i-1];
			      my $post = $parts[$i];
			      # if ($macro_name eq "__isctype") { print STDOUT "pre = $pre\nmatch = " . ($pre =~ /[\?:,\)]$/) . "  " . ($pre !~ /\($/) . "  " . ($post !~ /^\)/) . "  " . ($arg ne $body) . "\n" ; }
			      if (($i < $#parts) && (!$post))
				{ push(@formal_complaints,
				       "adjacent uses \#$i and \#" . $i+1); }

			      if (!$is_selector && ($pre =~ /$selector_regexp$/o))
				{ $is_selector = $true; }

			      # Maybe only do this test if body is an expression (nah).
			      if (# only (unparenthesized) names follow selectors
				  (!$is_selector)
				  && (($pre !~ /\($/) || ($post !~ /^\)/))
				  # Don't complain if arg is whole body --
				  # probably a syntactic macro.
				  && ($arg ne $body)
				  # A better test than category == 'expression'
				  # is whether this use is adjacent to an operator.
				  # && $category_is_expression
				  && (($pre =~ /$binop_regexp$/o)
				      || ($pre =~ /$prefix_unop_regexp$/o)
				      #  for ? : and , and casting
				      || ($pre =~ /[\?:,\)]$/)
				      || ($post =~ /^$binop_regexp/o)
				      || ($post =~ /^$postfix_unop_regexp/o)
				      || ($post =~ /^$selector_regexp/o)
				      # no comma: it's lowest precedence and left-associative
				      || ($post =~ /^[\?:]/o) #  for ? :
				      )
				  )
				{ push(@unparen_uses, $i); }
			      if (($pre =~ /(--|\+\+)$/)
				  || ($post =~ /^(--|\+\+)/)
				  || ($post =~ /^([-+*\/%&^\|]|<<|>>)?=[^=]/))
				{ push(@sideeff_uses, $i); }
			    }
			  if (!$is_selector)
			    { if (scalar(@unparen_uses) == 1)
				{ push(@formal_complaints,
				       "unparenthesized use \#$unparen_uses[0]"); }
			      elsif (scalar(@unparen_uses) > 1)
				{ push(@formal_complaints,
				       "unparenthesized uses \#"
				       . join(",#", @unparen_uses)); } }
			  if (scalar(@sideeff_uses) > 0)
			    { my $prefix = ($is_selector
					    ? "structure side-effected through "
					    : "side-effected ");
			      if (scalar(@sideeff_uses) == 1)
				{ push(@formal_complaints,
				       $prefix . "use \#$sideeff_uses[0]"); }
			      elsif (scalar(@sideeff_uses) > 1)
				{ push(@formal_complaints,
				       $prefix . "uses \#"
				       . join(",#", @sideeff_uses)); } }
			  if ((!$is_selector) && (scalar(@parts) > 2))
			    { # Make this complaint first (except that "not an identifier" should precede it)
			      unshift(@formal_complaints, "multiple uses"); }
			  if (scalar(@formal_complaints) > 0)
			    { push(@complaints,
				   "formal $arg: " . join("; ", @formal_complaints)); }
			} }

		  # Check body
		  if ($body =~ /\n/)
		    { die "$mdef_file[$i]:$mdef_line[$i]: newline in $macro_name (def #$i): '$body'"; }
		      if ($mdef_body[$i] =~ /\n/)
			{ push(@complaints,
			       "multi-line comment or string"); }
		  if ($category_is_expression && ($category != $catLITERAL))
		    { # Don't demand parentheses around a single identifier,
		      # number, or string, or around a function call (which has
		      # high precedence).
		      if (!	# complain if not one of the following:
			  (# parenthesized, or function call
			   (($body =~ /^($identifier_re\s*)?\(/o)
			    # For testing
			    # && (print STDERR "match = $MATCH, close = \n")
			    && (find_close_paren($body, length($MATCH)) == length($body)-1))
			   # identifier or number
			   || ($body =~ /^\w+$/)
			   # string
			   || ($body =~ /^$string_literal_re$/o)
			   # character
			   || ($body =~ /^$char_literal_re$/o)))
			{ push(@complaints,
			       "macro body should be enclosed in parentheses"
			       # If it has args and assignment, maybe it's really a semicolonless statement.
			       . (($args && ($properties & $propASSIGN)) ? " (if used as expression)" : "")); } }
		  if ($category_is_statement)
		    { if (($category == $catSTATEMENTS)
			  || ($category == $catSTATEMENTS_SANS_SEMI))
			{ push(@complaints,
			       "multiple statements: enclose in \"do ... while (0)\""); }
		      elsif (($category == $catSTATEMENT)
			     || ($category == $catSTATEMENTS))
			{ push(@complaints,
			       "semicolon-swallowing problem: enclose statement in \"do ... while (0)\""); } }
		  if (scalar(@complaints) > 0)
		    { print LINT "$mdef_file[$i]:$mdef_line[$i]:\n        #define $macro_name$args $mdef_body[$i]", @complaints;
			# Separate print statement so we don't get $OFS before it
			print LINT "\n"; }
		} } }
      $OFS = $old_ofs;
    } # end of if $opt_l (lint)

  if ($opt_v) { print STDOUT "frequse..."; }
  compute_freq_use_info();
  select(FREQUSE);
  OutputCountsHistogramCum(0,$macros_c_most_uses,
			   make_cum_array(@macros_c_number_uses));
  foreach my $cat (0..$catLast) {
    local $WARNING = 0;
    print "\n#Category: $categoryname[$cat]\n";
    OutputCountsHistogramCum(0,$macros_c_most_uses_for[$cat],
			     make_cum_array(@{$macros_c_number_uses_for[$cat]}));
  }

  if ($opt_v) { print STDOUT "freqdef..."; }
  compute_freq_def_info();
  select(FREQDEF);
  OutputCountsHistogramCum(1,$macros_c_most_defs,
			   make_cum_array(@macros_c_number_defs));
  foreach my $cat (0..$catLast) {
    local $WARNING = 0;
    print "\n#Category: $categoryname[$cat]\n";
    OutputCountsHistogramCum(1,$macros_c_most_defs_for[$cat],
			     make_cum_array(@{$macros_c_number_defs_for[$cat]}));
  }

  if ($opt_v) { print STDOUT "done\n"; }
}


# Returns a categorization string describing how the macro was used
# (one of eight (was four)); in alphabetical order:
#   Code CodeCond CodeMacro CodeMacroCond Cond Macro MacroCond NoUses
sub how_used_from_code_cpp_uses ($$$) {
  my ($cCodeUses, $cMacroUses, $cCondUses) = check_args(3,@_);
  my $result = "";
  $result .= "Code" if ($cCodeUses > 0);
  $result .= "Macro" if ($cMacroUses > 0);
  $result .= "Cond" if ($cCondUses > 0);
  $result = "NoUses" if ($result eq "");
  return $result;
}


# Return a sorted version of the list
# passed in, with duplicates removed
sub UniquifyAndSortList (@) {
  my (@list) = check_args_at_least(0, @_);
  if (!wantarray) {
    die "UniquifyAndSortList should return to an array context.";
  }
  my %seen = ();
  foreach (@list) {
    $seen{$_} = $true;
  }
  return sort (keys %seen);
}

# Returns a list of the categories for the various definitions
# of the macro with a given name
sub CategoriesForMacroName ($) {
  my ($name) = check_args(1,@_);
  my @list = ();
  for (my $iDef = 0 ; $iDef <= $#{$macros{$name}}; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    die if !defined($macros{$name});
    die if !defined($macros{$name}[$iDef]);
    die if !defined($mdef_category[$index]);
    push @list, $categoryname[$mdef_category[$index]];
  }
  #print STDERR "CFMN\n";
  return UniquifyAndSortList(@list);
}

# Returns a list of the inclusion methods of the various
# files in which the macro with a given name is defined
sub InclusionMethodsForMacroName ($) {
  my ($name) = check_args(1,@_);
  my @list = ();
  for (my $iDef = 0 ; $iDef <= $#{$macros{$name}}; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    die if !defined($macros{$name});
    die if !defined($macros{$name}[$iDef]);
    die if !defined($mdef_file[$index]);
    my $filename = $mdef_file[$index];
    die "$filename has no inclusion method" if !defined($file_inclusion_method{$filename});
    push @list, $file_inclusion_method{$filename};
  }
  #print STDERR "IMFMN\n";
  return UniquifyAndSortList(@list);
}



sub OutputHistogram ($$$;$) {
  my ($heading,$hashref,$divisor,$fPrintHeading) = check_args_range(3,4,@_);
  if (!defined($fPrintHeading))
    { $fPrintHeading = $false; }
  my @headings_list = ();
  my @values_list = ();
  foreach my $h (sort keys %$hashref) {
    push @headings_list, $h;
    my $v = $hashref->{$h};
    if ($divisor == 0) {
      if ($v != 0)
	{ croak "How can divisor be 0 but numerator be $v for $h?"; }
      push @values_list, $v;
    } elsif ($divisor == 1) {
      # This case feels gratuitous
      push @values_list, $v;
    } else {
      push @values_list, sprintf "%2.2f",pct2($v,$divisor);
    }
  }
  if ($fPrintHeading)
    { print "#${heading}#: ", join($OFS,@headings_list) . "\n"; }
  print "$heading: ", join($OFS,@values_list) . "\n";
}

# compute $cpp_cmds, $cpp_cmds_ni
# %cppcmpdcount, %cppcmdcount_ni
sub compute_global_cpp_sums () {
  check_args(0, @_);

  $cpp_cmds = sum_array(@rg_cpp_cmds[@ftype_ALL]);
  $cpp_cmds_ni = sum_array(@rg_cpp_cmds[@ftype_NOT_INCLUDED]);

  $cpp_cmds_c = sum_array(@rg_cpp_cmds[@ftype_CODE]);
  $cpp_cmds_c_ni = sum_array(@rg_cpp_cmds[@ftype_NONHEADER_NOT_INCLUDED]);

  $cpp_cmds_hdr = sum_array(@rg_cpp_cmds[@ftype_HEAD]);
  $cpp_cmds_hdr_ni = sum_array(@rg_cpp_cmds[@ftype_HEADER_NOT_INCLUDED]);

  sum_parallel_hashes(\%cppcmdcount,@rg_cppcmdcounts[@ftype_ALL]);
  sum_parallel_hashes(\%cppcmdcount_ni,@rg_cppcmdcounts[@ftype_NOT_INCLUDED]);
  sum_parallel_hashes(\%cppcmdcount_c_ni,@rg_cppcmdcounts[@ftype_NONHEADER_NOT_INCLUDED]);
  sum_parallel_hashes(\%cppcmdcount_hdr_ni,@rg_cppcmdcounts[@ftype_HEADER_NOT_INCLUDED]);

  sum_parallel_hashes(\%category_counts_ni,@rg_category_counts[@ftype_NOT_INCLUDED]);
  sum_parallel_hashes(\%category_counts_c_ni,@rg_category_counts[@ftype_NONHEADER_NOT_INCLUDED]);
  sum_parallel_hashes(\%category_counts_hdr_ni,@rg_category_counts[@ftype_HEADER_NOT_INCLUDED]);

}

@freq_use_buckets = (0,1,2,3,4,5,6,8,10,20,40,80);
@freq_def_buckets = (1,2,3,4,5,6,7,8,10,12,14);

# Return false if any of the definitions of the macro name
# occur inside the package
sub MacroNotDefinedInsidePackage ($) { # returns bool
  my ($name) = check_args(1,@_);
  for (my $iDef = 0 ; $iDef <= $#{$macros{$name}}; $iDef++ ) {
    my $index = $macros{$name}[$iDef];
    my $filename = $mdef_file[$index];
    if ($file_inclusion_method{$filename} eq "FromStdin") {
      # it is defined inside the package
      return $false;
    }
  }
  # it isn't defined inside the package
  return $true;
}


sub compute_freq_use_info () {
  check_args(0, @_);
  $macros_c_most_uses = 0;
  # sum of slice @{$macros_uses{$name}}[@i_usage_all] is the total no. uses for macro
  foreach my $name (keys %macros) {
    next if MacroNotDefinedInsidePackage($name);
    my $index = $macros{$name}[0];
    if ($mdef_category[$index] == $catNULL_DEFINE) {
      # if the first definition's category is NULLDEFINE, use
      # a different category if any of its other definitions were
      # not NULLDEFINEs.
      my $i = 1;
      while (defined($macros{$name}[$i]) &&
	     $mdef_category[$macros{$name}[$i]] == $catNULL_DEFINE) {
	$i++;
      }
      if (defined($macros{$name}[$i])) {
	$index = $i;
      }
    }
    my $category = $mdef_category[$index];
    my $c = sum_array(@{$macros_uses{$name}}[@i_usage_all]);
    local $WARNING = 0;# want to exploit scalars being 0 when undefined
    $macros_c_number_uses_for[$category][$c]++;
    $macros_c_number_uses[$c]++;
    $macros_c_most_uses = $c if ($c > $macros_c_most_uses);
    $macros_c_most_uses_for[$category] = $c if ($c > $macros_c_most_uses_for[$category]);
  }
}

sub compute_freq_def_info () {
  check_args(0, @_);
  $macros_c_most_defs = 0;
  # $#{$macros{$name}} is the number of macro definitions of $name
  foreach my $name (keys %macros) {
    next if MacroNotDefinedInsidePackage($name);
    my $index = $macros{$name}[0];
    if ($mdef_category[$index] == $catNULL_DEFINE) {
      # if the first definition's category is NULLDEFINE, use
      # a different category if any of its other definitions were
      # not NULLDEFINEs.
      my $i = 1;
      while (defined($macros{$name}[$i]) &&
	     $mdef_category[$macros{$name}[$i]] == $catNULL_DEFINE) {
	$i++;
      }
      if (defined($macros{$name}[$i])) {
	$index = $i;
      }
    }
    my $category = $mdef_category[$index];
    my $c = $#{$macros{$name}} + 1;
    local $WARNING = 0; # want to exploit scalars being 0 when undefined
    $macros_c_number_defs_for[$category][$c]++;
    $macros_c_number_defs[$c]++;
    $macros_c_most_defs = $c if ($c > $macros_c_most_defs);
    $macros_c_most_defs_for[$category] = $c if ($c > $macros_c_most_defs_for[$category]);
  }
}

sub OutputCountsHistogramRaw ($$@) {
  my ($low,$high,@counts) = @_;
  my $total = sum_array(@counts);
  print "Total", $total, "\n";
  for (my $i = $low; $i <= $high; $i++) {
    print $i, defined($counts[$i])? $counts[$i] : 0 , "\n";
  }
}

sub OutputCountsHistogramCum ($$@) {
  my ($low,$high,@counts) = @_;
  my $total = (scalar(@counts) == 0) ? 0 : $counts[$#counts];
  print "Total", $total, "\n";
  for (my $i = $low; $i <= $high; $i++) {
    print $i, defined($counts[$i])? $counts[$i] : 0 , "\n";
  }
}

###########################################################################
### Utilities
###

# pct2(x) returns a percentage (not a fraction) which corresponds to arg1/arg2.
sub pct2 ($$) {
  my ($x,$w) = check_args(2, @_);
  if ($w <= 0) {
    croak("pct2: Bad divisor: $x / $w");
    return 0;
  }
  if ($x < 0 || $x > $w) {
    print STDERR "pct2: Percentage out of range: $x / $w\n";
  }
  return (100*$x/$w);
}


# sum_array sums all its inputs, typically the elements of an array.
# Pass in a slice of the array in order to sum that part.
sub sum_array (@) {
  my (@args) = @_;
  my $sum = 0;
  { foreach my $elt (@args)
      { $sum += $elt if defined $elt; } }
  return $sum;
}

# make_cum_array returns an array that is the running total of the
# elements in the array passed in.
# e.g.     1, 3, 2,  1,  6,  2
# returns  1, 4, 6,  7, 13, 15
sub make_cum_array (@) { # returns @cum_array
  my (@args) = @_;
  my @cum_array = ();
  my $sum = 0;
  foreach my $elt (@args) {
    $sum += $elt if defined $elt;
    push @cum_array, $sum;
  }
  return @cum_array;
}


# Sum corresponding elements of an array (or array slice)
# into the destination reference provided
sub sum_parallel_hashes { # returns void; output in $_[0]
  my ($dest_hashref,@array_of_hash_refs) = check_args_at_least(1,@_);
  no strict 'refs';  #FIX: Must I do this?
  foreach my $hashref (@array_of_hash_refs) {
    foreach my $key (keys %{$hashref}) {
      if (!defined($dest_hashref->{$key})) {
	# print STDERR "UNDEF: $key\n";
	$dest_hashref->{$key} = 0;
      }
      $dest_hashref->{$key} += $hashref->{$key};
    }
  }
  return;
}



# Add newline to end of string; return string unchanged if it already has one.
sub add_newline ($)
{ my ($string) = check_args(1, @_);
  if ($string =~ m/\n$/)
    { return $string; }
  else
    { return $string . "\n"; }
}

###########################################################################
### Persistence

sub ReadMacroAnalysisState {
  my ($file) = check_args(1,@_);
  local $WARNING = 0;
  no strict;
  open(INPUTSTATE,"<$file") or die "Couldn't open state file $file: $!";
  $INPUT_RECORD_SEPARATOR = ");\n"; #FIX: this separator could blow up
  my $in;
  while (defined($in = <INPUTSTATE>))
  {
#    print "$in\n----------------\n\n";
    eval $in;
  }
  close(INPUTSTATE);

  # If @mdef_body_simple wasn't in the state file, compute it from @mdef_body.
  if (!defined($mdef_body_simple[0]))
    { @mdef_body_simple = map { cline_simplify($_) } @mdef_body; }
}

###########################################################################
### Main loop
###

# This is at the end of the file so that constants and variables can be
# introduced and set near where they are used rather than at the top of the
# file (before the main loop).  This is especially nice for globals that
# are only used by one or two routines.


use Getopt::Std;
getopts($getopts_option_letters);

usage() if ($opt_h);

my $statename = ($opt_s || "state");

# Do a quick test early, to avoid blowing away old output files if state
# file can't be opened.
open(INPUTSTATE,"<$statename") or die "Couldn't open state file $statename: $!";
close(INPUTSTATE);

# using a default directory-- only open the files that
# aren't explicitly given
if (!$opt_d) { $opt_d = '.'; }
if ($opt_d) {
  my ($dir,$basename) = split /:/,$opt_d;

  if (!defined($basename) || $basename eq "") {
    $basename = "";
  } else {
    $basename .= ".";
  }

  if ($dir !~ /\/$/) {
    $dir .= "/";
  }

  print STDERR "Outputting to $dir with prefix '$basename'\n";

  if (!$opt_S) {
    open(STATS,">$dir/${basename}stat") || die "Failed opening $!";
  }

  if (!$opt_D) {
    open(DEFINES,">$dir/${basename}def") || die "Failed opening $!";
  }

  if (!$opt_M) {
    open(MACROS,">$dir/${basename}mac") || die "Failed opening $!";
  }

  if (!$opt_F) {
    open(FUNCTIONS,">$dir/${basename}func") || die "Failed opening $!";
  }

  if (!$opt_L) {
    open(FUNCLINES,">$dir/${basename}fnln") || die "Failed opening $!";
  }

  if (!$opt_C) {
    open(CATEG,">$dir/${basename}catg") || die "Failed opening $!";
  }

  if (!$opt_P) {
    open(DEPEND,">$dir/${basename}depend") || die "Failed opening $!";
  }

  if (!$opt_c) {
    open(CCDSTATS,">$dir/${basename}ccd") || die "Failed opening $!";
  }

  if (!$opt_l) {
    open(LINT,">$dir/${basename}lint") || die "Failed opening $!";
  }

  open(FREQDEF,">$dir/${basename}freqdef_cum") || die "Failed opening $!";
  open(FREQUSE,">$dir/${basename}frequse_cum") || die "Failed opening $!";

}

if ($opt_S) { open(STATS,">$opt_S") || die "Failed opening $opt_S"; }
if ($opt_F) { open(FUNCTIONS,">$opt_F") || die "Failed opening $opt_F"; }
if ($opt_L) { open(FUNCLINES,">$opt_L") || die "Failed opening $opt_L"; }
if ($opt_D) { open(DEFINES,">$opt_D") || die "Failed opening $opt_D"; }
if ($opt_M) { open(MACROS,">$opt_M") || die "Failed opening $opt_M"; }
if ($opt_C) { open(CATEG,">$opt_C") || die "Failed opening $opt_C"; }
if ($opt_P) { open(DEPEND,">$opt_P") || die "Failed opening $opt_P"; }
if ($opt_c) { open(CCDSTATS,">$opt_c") || die "Failed opening $opt_c"; }
if ($opt_l) { open(LINT,">$opt_l") || die "Failed opening $opt_l"; }
if ($opt_I) { $fIgnoreIncludes = $true; }
if ($opt_t) { $outOFS = "\t"; } # use tab for OFS

if ($opt_d) {
  # Now set these so we'll actually do the output
  # (output_stats uses $opt_X as a guard for printing)
  # Note that we didn't want to do this in the above $opt_d
  # guarded block since then we couldn't override specific files
  # in the above if conditionals
  $opt_S = $true;
  $opt_D = $true;
  $opt_M = $true;
  $opt_F = $true;
  $opt_L = $true;
  $opt_C = $true;
  $opt_P = $true;
  $opt_c = $true;
  $opt_l = $true;
}

# Clunky, but faster than editing and saving the file over NFS.
if ($opt_g)
{ if ($opt_g == 0)
    { $fDebugCmdProcessing = $false;
      $fDebugCommentRemoval = $false;
      $debug_scopes = $false;
      $debug_type_match = $false;
      $debug_parse_function = $false;
      $debug_parse_expression = $false;
      $debug_parse_statement = $false;
      $debug_merge_branches = $false;
      $debug_parse_array_init = $false;
      $debug_peek = $false;
      $debug_getline = $false;
      $debug_categorize_macro = $false;
    }
  elsif ($opt_g == 1) { $fDebugCmdProcessing = $true; }
  elsif ($opt_g == 2) { $fDebugCommentRemoval = $true; }
  elsif ($opt_g == 3) { $debug_scopes = $true; }
  elsif ($opt_g == 4) { $debug_type_match = $true; }
  elsif ($opt_g == 5) { $debug_parse_function = $true; }
  elsif ($opt_g == 6) { $debug_parse_expression = $true; }
  elsif ($opt_g == 7) { $debug_merge_branches = $true; }
  elsif ($opt_g == 8) { $debug_parse_array_init = $true; }
  elsif ($opt_g == 9) { $debug_peek = $true; }
  elsif ($opt_g == 10) { $debug_getline = $true; }
  elsif ($opt_g == 11) { $debug_categorize_macro = $true; }
  elsif ($opt_g == 12) { $debug_cpp_if_comments = $true; }
  elsif ($opt_g == 15) { $debug_parse_statement = $true; }
  else { die "Bad -g option $opt_g"; }
}

if ($opt_T) {
  exit 0;
}

$fDebugCmdProcessing && print "@ARGV";

ReadMacroAnalysisState($statename);
#$WARNING = 0;
#require "dumpvar.pl";
#dumpvar();
#exit 0;
#print STDERR "Computing various global statistics...\n";
compute_global_cpp_sums();

output_stats();

#print STDERR "Included files:", join("\n",@files_included), "\n";

exit();

### Local Variables:
### page-delimiter: "^#################################################*\n"
### End:
