X-From-Line: mernst@nishin.cs.washington.edu  Fri May  9 09:32:28 1997
Received: from nishin.cs.washington.edu (nishin.cs.washington.edu [128.95.4.39]) by june.cs.washington.edu (8.8.5+CS/7.2ju) with ESMTP id JAA12734; Fri, 9 May 1997 09:32:27 -0700
Received: (from mernst@localhost) by nishin.cs.washington.edu (8.8.4/8.8.2) id JAA04322; Fri, 9 May 1997 09:32:27 -0700
Date: Fri, 9 May 1997 09:32:27 -0700
Message-Id: <199705091632.JAA04322@nishin.cs.washington.edu>
From: Michael Ernst <mernst@cs.washington.edu>
To: David Notkin <notkin@cs.washington.edu>,         Greg Badros <gjb@cs.washington.edu>
Subject: Notes from meeting of 5/5
Lines: 35
Xref: tolt.cs.washington.edu inbox:525
X-Gnus-Article-Number: 525   Fri May  9 09:35:57 1997

Remove glibc from suite (or, separate it out and add other libraries for
comparison).

Possible additional statistics to compute (see em_analyze for more ideas):
 * number of macros per function
 * types: number of different types at which a macro result is used
          how many different types are supplied for a macro argument
 * configurations in which a macro is used (ie, what cpp symbols are true)
 * how many lines are dependent on each macro -- directly or indirectly
   equivalently, for each line, how many macros it depends on
     This includes macros which control its inclusion via conditional
     compilation, macros that are invoked on the line, and macros that
     control the definitions of, or are called by, directly invoked macros
 * macro lint:  what percentage of macros are bug-prone?
 * macros common across multiple packages
 * effect on statistics of running cppp (partial cpp)
	for instance, how many macros are defined just once, so are
	effectively known.
 * prevalence of use of free variables (separate out globals vs. dynamic
   scoping)

Need to select an audience:  programmers, testers, maintainers, managers?

The current graphs are very busy.  Maybe just present min, max, mean, and
standard deviation instead of all 27 values.

All data needs to be gathered by May 31; sooner is more convenient for
Mike, who has to give a talk on this at IBM.

Determine what a macro is used for (eg portability, speed, abstraction,
debugging).  Maybe compile by hand (via "grep '# *if") a list of macro
symbols that are related to each (eg, contains "DEBUG", or gives info about
hardware or operating system), then collect info about those.  Or look for
heuristics we can apply to others.


