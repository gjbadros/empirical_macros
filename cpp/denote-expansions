#!/uns/bin/perl -w
# $Id$ -*-Perl-*-
# denote-expansions
# By Greg J. Badros -- 1-May-1998
#
# Use after pcp3 w/ expansions.pm as cpphook.pm; e.g.:
#
# pcp3 -q --noparse bzip2.c >/dev/null # creates expansions.listing file
# denote-expansions expansions.listing # creates, e.g., munged/** dir hierarchy
#

use strict;
use File::Basename;
use File::Path;

my $getopts_option_letters = "hf";
use vars qw($opt_h $opt_f);

sub usage {
    die "@_\nUsage: $0 [-$getopts_option_letters] <input_file>";
}

######## Customization parameters

# this prefix will be added to identifiers
# that are macros that are expanded
my $expansion_prefix = "EXPANDED_GJB_MDE_";

# this directory hierarchy will out the processed
# files with all expansions of macros denoted by
# the prefix given above
my $dir_for_munged = "munged/";

# use 1, below, to debug the creation of directories
# below the above directory
my $fShowDirsCreated = 0;

######## End parameters

use Getopt::Std;
getopts("$getopts_option_letters");

usage() if ($opt_h);

# this file contains the lines listing the expansions,
# as generated by pcp3 using the expansions.pm script
# e.g.:
# /usr/include/libio.h: __P, 8227, 8243
# /usr/include/stdio.h: _IO_size_t, 1805, 1815
# /usr/include/stdio.h: _IO_fpos_t, 1884, 1894

my $input_file = $ARGV[0] or die "Usage: $0 [input_file]\n";

# current output file;  when this changes
# we need to create a new file and start copying to it
my $out_file = "";


open(IN,"<$input_file") or die "Could not open file $input_file for reading: $!";

if (!$opt_f && -d $dir_for_munged) {
  print STDERR "Directory \"$dir_for_munged\" already exists -- (re)move it out of the way\n";
  exit -1;
}

sub create_new_file {
  my ($filename) = @_;
  $filename = $dir_for_munged . $filename;
  $filename =~ s%//%/%g;
  my $dirname = dirname($filename);
  # FIXGJB: is there a perl-native way to make a directory hierarchy?
  mkpath($dirname, $fShowDirsCreated);
  open(OUT,">$filename") or die "Could not open file $filename for writing: $!";
}

sub flush_to_end_of_file {
  my $source_data;
  # flush the file
  while ( read( INFILE, $source_data, 16384) > 0) {
    print OUT $source_data;
  }
}


while (<IN>) {
  my ($filename, $mname, $ichStart, $ichEnd) = m/(.*): ([^,]*), ([^,]*), ([^,]*)\n/;
  if ($filename ne $out_file) {
    # see if there is an old file we need to flush
    if ($out_file ne "") {
      flush_to_end_of_file();
    }
    # create_new_file associates the OUT filehandle with the new output file
    create_new_file($filename);
    $out_file = $filename;
    open(INFILE,"<$filename") or die "Could not open source file $filename for reading: $!";
  }
#  print OUT "$mname, $ichStart, $ichEnd\n";
  my $ichLast = tell INFILE;
  my $cchToRead = $ichStart - $ichLast -1;
  my $source_data;
  # read through to the end of the next expansion
  read INFILE, $source_data, $cchToRead;
  print OUT $source_data;
  my $macro_expansion;
  read INFILE, $macro_expansion, ($ichEnd - $ichStart + 1);
  print OUT $expansion_prefix, $macro_expansion;
}

flush_to_end_of_file();

