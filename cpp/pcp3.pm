#!/uns/bin/perl -w
# Update load path
use lib "/tmp/gjb/cpp/xs/cpp/blib/arch";
use lib "/tmp/gjb/cpp/xs/cpp/blib/lib";
use lib "/tmp/gjb/cpp";

use English;               # standard package
#use strict;

use hook_index_constants;  # auto generated by makefile
use enum_node_type;        # auto generated
use em_util;               # from empirical study
use vars qw( *CHOUT @Hooks );
use Boolean;               # optional package

# List of empirically identified "Ok" states for the parsers stack in order
# to insert a declaration
@state_stacks_decl_allowable = ( [],
				    [0],
				    [0,26] );

# Note, for efficiency this is a hash, so the 0s are dummies
%non_c_tokens = qw(CPP_HSPACE 0 CPP_VSPACE 0 CPP_POP 0 CPP_DIRECTIVE 0);

# From The C++ Programming Language, 3rd Edition, p. 817
@new_cpp_keywords = 
  qw(
     and and_eq asm bitand bitor bool catch class compl const_cast
     delete dynamic_cast explicit false friend inline mutable namespace 
     new not not_eq operator or or_eq private protected public reinterpret_cast
     static_cast template this throw true try typeid typename using virtual wchar_t
     xor xor_eq );

# This is a list of all the hooks supported;  FIXGJB should be mechanically
# generated like hook_index_constants
@pcp3_hooks = 
  qw(     
     STARTUP
     DO_DEFINE
     HANDLE_DIRECTIVE
     CREATE_PREDEF
     CREATE_DEF
     DO_UNDEF
     PRE_DO_UNDEF
     DELETE_DEF
     CPP_ERROR
     CPP_OUT
     EXPAND_MACRO
     MACARG_EXP
     MACRO_CLEANUP
     IFDEF_MACRO
     IFDEF_LOOKUP_MACRO
     SPECIAL_SYMBOL
     COMMENT
     STRING_CONSTANT
     DO_INCLUDE
     DO_IF
     DO_ELIF
     DO_XIFDEF
     DO_IFDEF
     DO_IFNDEF
     DO_ELSE
     DO_ENDIF
     ADD_IMPORT
     INCLUDE_FILE
     DONE_INCLUDE_FILE
     EXIT
     TOKEN
     TOKEN
     FUNCTION
     FUNC_CALL
     ANNOTATE
     POP_BUFFER
     TYPEDEF
     VARDECL
     POP_PERL_BUFFER
    );


@bitmap_masks = (1,2,4,8,16,32,64,128,256,512,1024,2048);


(
$PREDEFINED,
$RESTARGS,
) = @bitmap_masks;

(
$STRINGIFY,
$RAW_BEFORE,
$RAW_AFTER,
$REST_ARGS,
) = @bitmap_masks;

(
$ANGLE_BRACKETS,
$SKIP_DIRS,
$IMPORTING,
) = @bitmap_masks;


sub make_printable {
  my ($str) = @_;
  $str =~ s/([\000-\037])/sprintf("\\%03o",ord($1))/ge;
  return $str;
}

# FIXGJB: Should this return undef instead of 0 for false?
sub is_set {
  my ($flag, $bitmask) = @_;
  return ($flag & $bitmask)? 1 : 0;
}

sub AddHook {
  my ($indexname,$fnref) = @_;
  if (!defined($$indexname)) {
    die "Cannot find hook named $indexname";
  }
  push @{$Hooks[$$indexname]}, $fnref;
# Below line would still work, but uses the less general, 
# single hook interface  --10/02/97 gjb
#  $Hooks[$$indexname] = $fnref;
}


# List of empirically identified "Ok" states for the parsers stack in order
# to insert a declaration; see also the gram.output file for a less
# touchy-feely way to derive this, perhaps.
my @state_stacks_decl_allowable = ( [],
				    [0],
				    [0,26] );


sub FIsDeclAllowable {
  my @state_stack;
  if (@_) {
    @state_stack = @_;
  } else {
    @state_stack = pcp3::ParseStateStack();
  }
  foreach my $stackref (@state_stacks_decl_allowable) {
    # String interpolation of an array works for comparing them
    # iff the elements are all numeric [otherwise might work if you change $"
    return TRUE if "@$stackref" eq "@state_stack";
  }
  return FALSE;
}


# Support doc-property-display; this requires the defuns included there
# All these assume filehandle TPSOURCE!
sub AddProperty {
  my ($kind,$fname,$s_start,$s_end,$prop,$val) = @_;
  if ($s_start != $s_end) {
    print TPSOURCE "#$fname:(add-$kind-property $s_start $s_end \'$prop \"$val\")\n";
  }
}

sub AddTextProperty {
  AddProperty("text",@_);
}

sub AddListProperty {
  AddProperty("list",@_);
}

sub PutFaceProperty {
  my ($fname,$s_start,$s_end,$font) = @_;
  if ($s_start != $s_end) {
    print TPSOURCE "#$fname:(put-face-property-if-none $s_start $s_end \'$font)\n";
  }
}

sub PutMouseFaceProperty {
  my ($fname,$s_start,$s_end,$font) = @_;
  if ($s_start != $s_end) {
    print TPSOURCE "#$fname:(put-mouse-face-property-if-none $s_start $s_end \'$font)\n";
  }
}

1;
